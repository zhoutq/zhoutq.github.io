<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhoutq</title>
  <subtitle>Zhoutq&#39;s Blog</subtitle>
  <link href="/zhoutq.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/zhoutq/zhoutq.github.io/"/>
  <updated>2017-09-26T15:26:44.000Z</updated>
  <id>https://github.com/zhoutq/zhoutq.github.io/</id>
  
  <author>
    <name>zhoutq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转]Objective-C Runtime 详解</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/26/17.09.26_Objective-C_Runtime%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/26/17.09.26_Objective-C_Runtime详解/</id>
    <published>2017-09-26T08:44:53.000Z</published>
    <updated>2017-09-26T15:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime" target="_blank" rel="external">http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime</a></p>
<p>本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容如下：  </p>
<ul>
<li>引言</li>
<li>简介</li>
<li>与 Runtime 交互</li>
<li>Runtime 基础数据结构</li>
<li>消息</li>
<li>动态方法解析</li>
<li>消息转发</li>
<li>健壮的实例变量 (Non Fragile ivars)</li>
<li>Objective-C Associated Objects</li>
<li>Method Swizzling</li>
<li>总结</li>
</ul>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><a href="#引言" title="引言"></a>引言</h2><p>曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把 <code>[receiver message]</code> 当成简单的方法调用，而无视了<strong>“发送消息”</strong>这句话的深刻含义。其实 <code>[receiver message]</code> 会被编译器转化为： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>如果消息含有参数，则为：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>如果消息的接收者能够找到对应的 <code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 <code>selector</code> 对应的实现内容，要么就干脆玩完崩溃掉。  </p>
<p>现在可以看出 <code>[receiver message]</code> 真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送 <code>message</code> 这条消息，而 <code>receive</code> 将要如何响应这条消息，那就要看运行时发生的情况来决定了。  </p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。  </p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="#简介" title="简介"></a>简介</h2><p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。  </p>
<p>Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。  </p>
<p>Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime 版本，这两个版本之间都在努力的保持一致。   </p>
<h2 id="与-Runtime-交互"><a href="#与-Runtime-交互" class="headerlink" title="与 Runtime 交互"></a><a href="#与-Runtime-交互" title="与 Runtime 交互"></a>与 Runtime 交互</h2><p>Objc 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的<code>NSObject</code>类定义的方法，通过对 runtime 函数的直接调用。  </p>
<h3 id="Objective-C-源代码"><a href="#Objective-C-源代码" class="headerlink" title="Objective-C 源代码"></a><a href="#Objective-C-源代码" title="Objective-C 源代码"></a>Objective-C 源代码</h3><p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如 <code>objc_msgSend</code> 函数及其参数列表中的 <code>id</code> 和 <code>SEL</code> 都是啥）</p>
<h3 id="NSObject-的方法"><a href="#NSObject-的方法" class="headerlink" title="NSObject 的方法"></a><a href="#NSObject-的方法" title="NSObject 的方法"></a>NSObject 的方法</h3><p>Cocoa 中大多数类都继承于 <code>NSObject</code> 类，也就自然继承了它的方法。最特殊的例外是 <code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。  </p>
<p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。   </p>
<h3 id="Runtime-的函数"><a href="#Runtime-的函数" class="headerlink" title="Runtime 的函数"></a><a href="#Runtime-的函数" title="Runtime 的函数"></a>Runtime 的函数</h3><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime Reference</a> 中有对 Runtime 函数的详细文档。  </p>
<h2 id="Runtime-基础数据结构"><a href="#Runtime-基础数据结构" class="headerlink" title="Runtime 基础数据结构"></a><a href="#Runtime-基础数据结构" title="Runtime 基础数据结构"></a>Runtime 基础数据结构</h2><p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend ( id <span class="keyword">self</span>, <span class="type">SEL</span> op, ... );</div></pre></td></tr></table></figure>
<p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。熟悉 Objective-C 类的内存模型或看过相关源码的可以直接跳过。  </p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><a href="#SEL" title="SEL"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 <code>@selector()</code> 或者 Runtime 系统的 <code>sel_registerName</code> 函数来获得一个 <code>SEL</code> 类型的方法选择器。  </p>
<p>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(<code>NSNumber</code> 一堆抽象工厂方法拿走不谢)，Cocoa 中有好多长长的方法哦。  </p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a><a href="#id" title="id"></a>id</h3><p><code>objc_msgSend</code> 第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div></pre></td></tr></table></figure>
<p>那<code>objc_object</code>又是啥呢，参考 objc-private.h 文件部分源码：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    isa_t isa;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></div><div class="line">    <span class="type">Class</span> <span class="type">ISA</span>();</div><div class="line"></div><div class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></div><div class="line">    <span class="type">Class</span> getIsa();</div><div class="line">    ... 此处省略其他方法声明</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，类型为 <code>isa_t</code> 联合体。根据 <code>isa</code> 就可以顺藤摸瓜找到对象所属的类。<code>isa</code> 这里还涉及到 tagged pointer 等概念。因为 <code>isa_t</code> 使用 <code>union</code> 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。有关 <code>isa_t</code> 联合体的更多内容可以查看 <a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-指针（NONPOINTER-ISA）" target="_blank" rel="external">Objective-C 引用计数原理</a>。</p>
<p>PS: <code>isa</code> 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 <code>class</code> 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 <code>isa</code> 指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a><a href="#Class" title="Class"></a>Class</h3><p><code>Class</code> 其实是一个指向 <code>objc_class</code> 结构体的指针：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div></pre></td></tr></table></figure>
<p>而 <code>objc_class</code> 包含很多方法，主要都为围绕它的几个成员做文章： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> : <span class="title">objc_object</span> </span>&#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    <span class="type">Class</span> superclass;</div><div class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></div><div class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t  plus custom rr/alloc flags</span></div><div class="line">    class_rw_t data() &#123; </div><div class="line">        <span class="keyword">return</span> bits.data();</div><div class="line">    &#125;</div><div class="line">    ... 省略其他方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_class</code> 继承于 <code>objc_object</code>，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 <code>[NSObject alloc]</code> 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code> 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg" alt="">  </p>
<p>上图实线是 <code>superclass</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是 <code>NSObject</code>，而 <code>isa</code> 指向了自己，而 <code>NSObject</code> 的超类为 <code>nil</code>，也就是它没有超类。</p>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。  </p>
<h4 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a><a href="#cache-t" title="cache_t"></a>cache_t</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *<span class="title">_buckets</span>;</span></div><div class="line">    <span class="title">mask_t</span> <span class="title">_mask</span>;</div><div class="line">    <span class="title">mask_t</span> <span class="title">_occupied</span>;</div><div class="line">    ... 省略其他方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_buckets</code> 存储 <code>IMP</code>，<code>_mask</code> 和 <code>_occupied</code> 对应 <code>vtable</code>。</p>
<p><code>cache</code> 为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在<code>isa</code>指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在 <code>cache</code> 中查找。Runtime 系统会把被调用的方法存到 <code>cache</code> 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。</p>
<p><code>bucket_t</code> 中存储了指针与 IMP 的键值对：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> </span>&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    cache_key_t _key;</div><div class="line">    <span class="type">IMP</span> _imp;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    inline cache_key_t key() const &#123; <span class="keyword">return</span> _key; &#125;</div><div class="line">    inline <span class="type">IMP</span> imp() const &#123; <span class="keyword">return</span> (<span class="type">IMP</span>)_imp; &#125;</div><div class="line">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</div><div class="line">    inline void setImp(<span class="type">IMP</span> newImp) &#123; _imp = newImp; &#125;</div><div class="line"></div><div class="line">    void <span class="keyword">set</span>(cache_key_t newKey, <span class="type">IMP</span> newImp);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有关缓存的实现细节，可以查看 objc-cache.mm 文件。</p>
<h4 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a><a href="#class-data-bits-t" title="class_data_bits_t"></a>class_data_bits_t</h4><p><code>objc_class</code> 中最复杂的是 <code>bits</code>，<code>class_data_bits_t</code> 结构体所包含的信息太多了，主要包含 <code>class_rw_t</code>, <code>retain/release/autorelease/retainCount</code> 和 <code>alloc</code> 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classdata_bits_t</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Values are the FAST flags above.</span></div><div class="line">    uintptr_t bits;</div><div class="line">    class_rw_t data() &#123;</div><div class="line">       <span class="keyword">return</span> (class_rw_t )(bits &amp; <span class="type">FAST_DATA_MASK</span>);</div><div class="line">    &#125;</div><div class="line">... 省略其他方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>objc_class</code> 的 <code>data</code> 方法直接将 <code>class_data_bits_t</code> 的<code>data</code> 方法返回，最终是返回 <code>class_rw_t</code>，保了好几层。</p>
<p>可以看到 <code>class_data_bits_t</code> 里又包了一个 <code>bits</code>，这个指针跟不同的 <code>FAST_</code> 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。<code>bits</code> 在内存中每个位的含义有三种排列顺序：</p>
<table><br><br><tr><br><th style="text-align:left">32 位：</th><br></tr><br><br><tr><br><th style="text-align:center">0</th><br><th style="text-align:center">1</th><br><th style="text-align:center">2 - 31</th><br></tr><br><br><tr><br><td style="text-align:center">FAST_IS_SWIFT</td><br><td style="text-align:center">FAST_HAS_DEFAULT_RR</td><br><td style="text-align:center">FAST_DATA_MASK</td><br></tr><br><br></table>



<table><br><tr><br><th style="text-align:left">64 位兼容版：</th><br></tr><br><tr><br><th style="text-align:center">0</th><br><th style="text-align:center">1</th><br><th style="text-align:center">2</th><br><th style="text-align:center">3 - 46</th><br><th style="text-align:center">47 - 63</th><br></tr><br><tr><br><td style="text-align:center">FAST_IS_SWIFT</td><br><td style="text-align:center">FAST_HAS_DEFAULT_RR</td><br><td style="text-align:center">FAST_REQUIRES_RAW_ISA</td><br><td style="text-align:center">FAST_DATA_MASK</td><br><td style="text-align:center">空闲</td><br></tr><br></table>



<table><br><tr><br><th style="text-align:left">64 位不兼容版：</th><br></tr><br><tr><br><th style="text-align:center">0</th><br><th style="text-align:center">1</th><br><th style="text-align:center">2</th><br><th style="text-align:center">3 - 46</th><br><th style="text-align:center">47</th><br></tr><br><tr><br><td style="text-align:center">FAST_IS_SWIFT</td><br><td style="text-align:center">FAST_REQUIRES_RAW_ISA</td><br><td style="text-align:center">FAST_HAS_CXX_DTOR</td><br><td style="text-align:center">FAST_DATA_MASK</td><br><td style="text-align:center">FAST_HAS_CXX_CTOR</td><br></tr><br><tr><br><td style="text-align:center">48</td><br><td style="text-align:center">49</td><br><td style="text-align:center">50</td><br><td style="text-align:center">51</td><br><td style="text-align:center">52 - 63</td><br></tr><br><tr><br><td style="text-align:center">FAST_HAS_DEFAULT_AWZ</td><br><td style="text-align:center">FAST_HAS_DEFAULT_RR</td><br><td style="text-align:center">FAST_ALLOC</td><br><td style="text-align:center">FAST_SHIFTED_SIZE_SHIFT</td><br><td style="text-align:center">空闲</td><br></tr><br></table>

<p>其中 64 位不兼容版每个宏对应的含义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class is a Swift class</span></div><div class="line">#define <span class="type">FAST_IS_SWIFT</span>           (1UL&lt;&lt;<span class="number">0</span>)</div><div class="line"><span class="comment">// class's instances requires raw isa</span></div><div class="line">#define <span class="type">FAST_REQUIRES_RAW_ISA</span>   (1UL&lt;&lt;<span class="number">1</span>)</div><div class="line"><span class="comment">// class or superclass has .cxx_destruct implementation</span></div><div class="line"><span class="comment">//   This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.</span></div><div class="line">#define <span class="type">FAST_HAS_CXX_DTOR</span>       (1UL&lt;&lt;<span class="number">2</span>)</div><div class="line"><span class="comment">// data pointer</span></div><div class="line">#define <span class="type">FAST_DATA_MASK</span>          0x00007ffffffffff8UL</div><div class="line"><span class="comment">// class or superclass has .cxx_construct implementation</span></div><div class="line">#define <span class="type">FAST_HAS_CXX_CTOR</span>       (1UL&lt;&lt;<span class="number">47</span>)</div><div class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></div><div class="line"><span class="comment">// Note this is is stored in the metaclass.</span></div><div class="line">#define <span class="type">FAST_HAS_DEFAULT_AWZ</span>    (1UL&lt;&lt;<span class="number">48</span>)</div><div class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></div><div class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></div><div class="line">#define <span class="type">FAST_HAS_DEFAULT_RR</span>     (1UL&lt;&lt;<span class="number">49</span>)</div><div class="line"><span class="comment">// summary bit for fast alloc path: !hasCxxCtor and </span></div><div class="line"><span class="comment">//   !instancesRequireRawIsa and instanceSize fits into shiftedSize</span></div><div class="line">#define <span class="type">FAST_ALLOC</span>              (1UL&lt;&lt;<span class="number">50</span>)</div><div class="line"><span class="comment">// instance size in units of 16 bytes</span></div><div class="line"><span class="comment">//   or 0 if the instance size is too big in this field</span></div><div class="line"><span class="comment">//   This field must be LAST</span></div><div class="line">#define <span class="type">FAST_SHIFTED_SIZE_SHIFT</span> <span class="number">51</span></div></pre></td></tr></table></figure>
<p>这里面除了 <code>FAST_DATA_MASK</code> 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。<code>class_data_bits_t</code> 提供了三个方法用于位操作：<code>getBit</code>,<code>setBits</code> 和 <code>clearBits</code>，对应到存储 bool 值的掩码也有封装函数，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bool isSwift() &#123;</div><div class="line">   <span class="keyword">return</span> getBit(<span class="type">FAST_IS_SWIFT</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void setIsSwift() &#123;</div><div class="line">   setBits(<span class="type">FAST_IS_SWIFT</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重头戏在于最大的那块存储区域–<code>FAST_DATA_MASK</code>，它其实就存储了指向 <code>class_rw_t</code> 的指针：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class_rw_t data() &#123;</div><div class="line">   <span class="keyword">return</span> (class_rw_t )(bits &amp; <span class="type">FAST_DATA_MASK</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。</p>
<p><code>class_data_bits_t</code> 甚至还包含了一些对 <code>class_rw_t</code> 中 <code>flags</code> 成员存取的封装函数。</p>
<h4 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a><a href="#class-ro-t" title="class_ro_t"></a>class_ro_t</h4><p><code>objc_class</code> 包含了 <code>class_data_bits_t</code>，<code>class_data_bits_t</code> 存储了 <code>class_rw_t</code> 的指针，而 <code>class_rw_t</code> 结构体又包含 <code>class_ro_t</code> 的指针。</p>
<p><code>class_ro_t</code> 中的 <code>method_list_t</code>, <code>ivar_list_t</code>, <code>property_list_t</code> 结构体都继承自 <code>entsize_list_tt&amp;lt;Element, List, FlagMask&amp;gt;</code>。结构为 <code>xxx_list_t</code> 的列表元素结构为 <code>xxx_t</code>，命名很工整。<code>protocol_list_t</code> 与前三个不同，它存储的是 <code>protocol_t *</code> 指针列表，实现比较简单。</p>
<p><code>entsize_list_tt</code> 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 <code>NSObject</code> 类增加了一些内容，<code>NSObject</code> 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 <code>NSObject</code> 内存有重叠部分。于是在编译期会给 <code>instanceStart</code> 和 <code>instanceSize</code> 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classrot</span> </span>&#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;</div><div class="line">#ifdef __LP64</div><div class="line">    uint32_t reserved;</div><div class="line">#endif</div><div class="line"></div><div class="line">    const uint8_t  ivarLayout;</div><div class="line">    </div><div class="line">    const char  name;</div><div class="line">    method_list_t  baseMethodList;</div><div class="line">    protocol_list_t  baseProtocols;</div><div class="line">    const ivar_list_t  ivars;</div><div class="line"></div><div class="line">    const uint8_t  weakIvarLayout;</div><div class="line">    property_list_t baseProperties;</div><div class="line"></div><div class="line">    method_list_t baseMethods() const &#123;</div><div class="line">        <span class="keyword">return</span> baseMethodList;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>class_ro_t-&amp;gt;flags</code> 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 <code>RO_</code> 前缀的宏标记了 <code>flags</code> 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 <code>class_rw_t</code> 的类型强转。运行时会用到它做判断，后面会讲解。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#define <span class="type">ROMETA</span>               (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) <span class="comment">// class is a metaclass</span></div><div class="line">#define <span class="type">RO_ROOT</span>               (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) <span class="comment">// class is a root class</span></div><div class="line">#define <span class="type">RO_HAS_CXX_STRUCTORS</span>  (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) <span class="comment">// class has .cxx_construct/destruct implementations</span></div><div class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3) // class has +load implementation</span></div><div class="line">#define <span class="type">RO_HIDDEN</span>             (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) <span class="comment">// class has visibility=hidden set</span></div><div class="line">#define <span class="type">RO_EXCEPTION</span>          (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) <span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE$_ThisClass is non-weak</span></div><div class="line"><span class="comment">// #define RO_REUSE_ME           (1&lt;&lt;6) // this bit is available for reassignment</span></div><div class="line">#define <span class="type">RO_IS_ARC</span>             (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) <span class="comment">// class compiled with ARC</span></div><div class="line">#define <span class="type">RO_HAS_CXX_DTOR_ONLY</span>  (<span class="number">1</span>&lt;&lt;<span class="number">8</span>) <span class="comment">// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)</span></div><div class="line">#define <span class="type">RO_HAS_WEAK_WITHOUT_ARC</span> (<span class="number">1</span>&lt;&lt;<span class="number">9</span>) <span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></div><div class="line"></div><div class="line">#define <span class="type">RO_FROM_BUNDLE</span>        (<span class="number">1</span>&lt;&lt;<span class="number">29</span>) <span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></div><div class="line">#define <span class="type">RO_FUTURE</span>             (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) <span class="comment">// class is unrealized future class - must never be set by compiler</span></div><div class="line">#define <span class="type">RO_REALIZED</span>           (<span class="number">1</span>&lt;&lt;<span class="number">31</span>) <span class="comment">// class is realized - must never be set by compiler</span></div></pre></td></tr></table></figure>
<h4 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a><a href="#class-rw-t" title="class_rw_t"></a>class_rw_t</h4><p><code>class_rw_t</code> 提供了运行时对类拓展的能力，而 <code>class_ro_t</code> 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。</p>
<p><code>class_rw_t</code> 中使用的 <code>method_array_t</code>, <code>property_array_t</code>, <code>protocol_array_t</code> 都继承自 <code>list_array_tt&amp;lt;Element, List&amp;gt;</code>, 它可以不断扩张，因为它可以存储 list 指针，内容有三种：</p>
<ol>
<li>空</li>
<li>一个 <code>entsize_list_tt</code> 指针</li>
<li><code>entsize_list_tt</code> 指针数组</li>
</ol>
<p><code>class_rw_t</code> 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> </span>&#123;</div><div class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line"></div><div class="line">    const class_ro_t ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line"></div><div class="line">    <span class="type">Class</span> firstSubclass;</div><div class="line">    <span class="type">Class</span> nextSiblingClass;</div><div class="line"></div><div class="line">    char demangledName;</div><div class="line"></div><div class="line">#<span class="keyword">if</span> <span class="type">SUPPORT_INDEXED_ISA</span></div><div class="line">    uint32_t index;</div><div class="line">#endif</div><div class="line">    ... 省略操作 flags 的相关方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>class_rw_t-&amp;gt;flags</code> 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 <code>RW_</code> 前缀的宏标记了 <code>flags</code> 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#define <span class="type">RW_REALIZED</span>           (<span class="number">1</span>&lt;&lt;<span class="number">31</span>) <span class="comment">// class_t-&gt;data is class_rw_t, not class_ro_t</span></div><div class="line">#define <span class="type">RW_FUTURE</span>             (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) <span class="comment">// class is unresolved future class</span></div><div class="line">#define <span class="type">RW_INITIALIZED</span>        (<span class="number">1</span>&lt;&lt;<span class="number">29</span>) <span class="comment">// class is initialized</span></div><div class="line">#define <span class="type">RW_INITIALIZING</span>       (<span class="number">1</span>&lt;&lt;<span class="number">28</span>) <span class="comment">// class is initializing</span></div><div class="line">#define <span class="type">RW_COPIED_RO</span>          (<span class="number">1</span>&lt;&lt;<span class="number">27</span>) <span class="comment">// class_rw_t-&gt;ro is heap copy of class_ro_t</span></div><div class="line">#define <span class="type">RW_CONSTRUCTING</span>       (<span class="number">1</span>&lt;&lt;<span class="number">26</span>) <span class="comment">// class allocated but not yet registered</span></div><div class="line">#define <span class="type">RW_CONSTRUCTED</span>        (<span class="number">1</span>&lt;&lt;<span class="number">25</span>) <span class="comment">// class allocated and registered</span></div><div class="line"><span class="comment">// #define RW_24 (1&lt;&lt;24) // available for use; was RW_FINALIZE_ON_MAIN_THREAD</span></div><div class="line">#define <span class="type">RW_LOADED</span>             (<span class="number">1</span>&lt;&lt;<span class="number">23</span>) <span class="comment">// class +load has been called</span></div><div class="line">#<span class="keyword">if</span> !<span class="type">SUPPORT_NONPOINTER_ISA</span></div><div class="line">#define <span class="type">RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS</span> (<span class="number">1</span>&lt;&lt;<span class="number">22</span>) <span class="comment">// class instances may have associative references</span></div><div class="line">#endif</div><div class="line">#define <span class="type">RW_HAS_INSTANCE_SPECIFIC_LAYOUT</span> (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) <span class="comment">// class has instance-specific GC layout</span></div><div class="line"><span class="comment">// #define RW_20       (1&lt;&lt;20) // available for use</span></div><div class="line">#define <span class="type">RW_REALIZING</span>          (<span class="number">1</span>&lt;&lt;<span class="number">19</span>) <span class="comment">// class has started realizing but not yet completed it</span></div><div class="line">#define <span class="type">RW_HAS_CXX_CTOR</span>       (<span class="number">1</span>&lt;&lt;<span class="number">18</span>) <span class="comment">// class or superclass has .cxx_construct implementation</span></div><div class="line">#define <span class="type">RW_HAS_CXX_DTOR</span>       (<span class="number">1</span>&lt;&lt;<span class="number">17</span>) <span class="comment">// class or superclass has .cxx_destruct implementation</span></div><div class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></div><div class="line"><span class="comment">// Note this is is stored in the metaclass.</span></div><div class="line">#define <span class="type">RW_HAS_DEFAULT_AWZ</span>    (<span class="number">1</span>&lt;&lt;<span class="number">16</span>)</div><div class="line">#<span class="keyword">if</span> <span class="type">SUPPORT_NONPOINTER_ISA</span></div><div class="line">#define <span class="type">RW_REQUIRES_RAW_ISA</span>   (<span class="number">1</span>&lt;&lt;<span class="number">15</span>) <span class="comment">// class's instances requires raw isa</span></div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><code>demangledName</code> 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。</p>
<h4 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a><a href="#realizeClass" title="realizeClass"></a>realizeClass</h4><p>在某个类初始化之前，<code>objc_class-&amp;gt;data()</code> 返回的指针指向的其实是个 <code>class_ro_t</code> 结构体。等到 <code>static Class realizeClass(Class cls)</code> 静态方法在类第一次初始化时被调用，它会开辟 <code>class_rw_t</code> 的空间，并将 <code>class_ro_t</code> 指针赋值给 <code>class_rw_t-&amp;gt;ro</code>。这种偷天换日的行为是靠 <code>RO_FUTURE</code> 标志位来记录的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ro = (const class_ro_t )cls-&gt;data();</div><div class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; <span class="type">RO_FUTURE</span>) &#123;</div><div class="line">   <span class="comment">// This was a future class. rw data is already allocated.</span></div><div class="line">   rw = cls-&gt;data();</div><div class="line">   ro = cls-&gt;data()-&gt;ro;</div><div class="line">   cls-&gt;changeInfo(<span class="type">RW_REALIZED</span>|<span class="type">RW_REALIZING</span>, <span class="type">RW_FUTURE</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="comment">// Normal class. Allocate writeable class data.</span></div><div class="line">   rw = (class_rw_t )calloc(<span class="built_in">sizeof</span>(class_rw_t), <span class="number">1</span>);</div><div class="line">   rw-&gt;ro = ro;</div><div class="line">   rw-&gt;flags = <span class="type">RW_REALIZED</span>|<span class="type">RW_REALIZING</span>;</div><div class="line">   cls-&gt;setData(rw);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意之前 RO 和 RW flags 宏标记的一个细节：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define <span class="type">RO_FUTURE</span>             (<span class="number">1</span>&lt;&lt;<span class="number">30</span>)</div><div class="line">#define <span class="type">RO_REALIZED</span>           (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)</div><div class="line"></div><div class="line">#define <span class="type">RW_REALIZED</span>           (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)</div><div class="line">#define <span class="type">RW_FUTURE</span>             (<span class="number">1</span>&lt;&lt;<span class="number">30</span>)</div></pre></td></tr></table></figure>
<p>也就是说 <code>ro = (const class_ro_t *)cls-&amp;gt;data();</code> 这种强转对于接下来的 <code>ro-&amp;gt;flags &amp;amp; RO_FUTURE</code> 操作完全是 OK 的，两种结构体第一个成员都是 <code>flags</code>，<code>RO_FUTURE</code> 与 <code>RW_FUTURE</code> 值一样的。</p>
<p>经过 <code>realizeClass</code> 函数处理的类才是『真正的』类，调用它时不能对类做写操作。</p>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a><a href="#Category" title="Category"></a>Category</h3><p><code>Category</code> 为现有的类提供了拓展性，它是 <code>category_t</code> 结构体的指针。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></div></pre></td></tr></table></figure>
<p><code>category_t</code> 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 <code>category_t</code> 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> </span>&#123;</div><div class="line">    const char name;</div><div class="line">    classref_t cls;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> <span class="title">instanceMethods</span>;</span></div><div class="line">    <span class="title">struct</span> <span class="title">method_list_t</span> <span class="title">classMethods</span>;</div><div class="line">    <span class="title">struct</span> <span class="title">protocol_list_t</span> <span class="title">protocols</span>;</div><div class="line">    <span class="title">struct</span> <span class="title">property_list_t</span> <span class="title">instanceProperties</span>;</div><div class="line">    // <span class="title">Fields</span> <span class="title">below</span> <span class="title">this</span> <span class="title">point</span> <span class="title">are</span> <span class="title">not</span> <span class="title">always</span> <span class="title">present</span> <span class="title">on</span> <span class="title">disk</span>.</div><div class="line">    <span class="title">struct</span> <span class="title">property_list_t</span> <span class="title">_classProperties</span>;</div><div class="line"></div><div class="line">    <span class="title">method_list_t</span> <span class="title">methodsForMeta</span>(<span class="title">bool</span> <span class="title">isMeta</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t propertiesForMeta(bool isMeta, <span class="class"><span class="keyword">struct</span> <span class="title">header_info</span> *<span class="title">hi</span>);</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 App 启动加载镜像文件时，会在 <code>_read_images</code> 函数间接调用到 <code>attachCategories</code> 函数，完成向类中添加 <code>Category</code> 的工作。原理就是向 <code>class_rw_t</code> 中的 <code>method_array_t</code>, <code>property_array_t</code>, <code>protocol_array_t</code> 数组中分别添加 <code>method_list_t</code>, <code>property_list_t</code>, <code>protocol_list_t</code> 指针。之前讲过 <code>xxx_array_t</code> 可以存储对应 <code>xxx_list_t</code> 的指针数组。</p>
<p>在调用 <code>attachCategories</code> 函数之前，会先使用 <code>unattachedCategoriesForClass</code> 函数获取类中还未添加的类别列表。这个列表类型为 <code>locstamped_category_list_t</code>，它封装了 <code>category_t</code> 以及对应的 <code>header_info</code>。<code>header_info</code> 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstampedcategoryt</span> </span>&#123;</div><div class="line">    category_t cat;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header_info</span> <span class="title">hi</span>;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="title">struct</span> <span class="title">locstamped_category_list_t</span> &#123;</div><div class="line">    uint32_t <span class="built_in">count</span>;</div><div class="line">#<span class="keyword">if</span> __LP64</div><div class="line">    uint32_t reserved;</div><div class="line">#endif</div><div class="line">    locstamped_category_t list[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以更具体来说 <code>attachCategories</code> 做的就是将 <code>locstamped_category_list_t.list</code> 列表中每个 <code>locstamped_category_t.cat</code> 中的那方法、协议和属性分别添加到类的 <code>class_rw_t</code> 对应列表中。<code>header_info</code> 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a><a href="#Method" title="Method"></a>Method</h3><p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></div></pre></td></tr></table></figure>
<p>而 <code>objc_method</code> 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> </span>&#123;</div><div class="line">    <span class="type">SEL</span> name;</div><div class="line">    const char *types;</div><div class="line">    <span class="type">IMP</span> imp;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></div><div class="line">        <span class="title">public</span> <span class="title">std</span>::<span class="title">binary_function</span>&lt;<span class="title">const</span> <span class="title">method_t</span>&amp;,</div><div class="line">                                    <span class="title">const</span> <span class="title">method_t</span>&amp;, <span class="title">bool</span>&gt;</div><div class="line">    &#123;</div><div class="line">        bool <span class="keyword">operator</span>() (const method_t&amp; lhs,</div><div class="line">                         const method_t&amp; rhs)</div><div class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>方法名类型为 <code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。*   方法类型 <code>types</code> 是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>imp</code> 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</li>
</ul>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><a href="#Ivar" title="Ivar"></a>Ivar</h3><p><code>Ivar</code> 是一种代表类中实例变量的类型。  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></div></pre></td></tr></table></figure>
<p>而 <code>ivar_t</code> 在上面的成员变量列表中也提到过：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> </span>&#123;</div><div class="line">    int32_t offset;</div><div class="line">    const char name;</div><div class="line">    const char *type;</div><div class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></div><div class="line">    uint32_t alignment_raw;</div><div class="line">    uint32_t size;</div><div class="line"></div><div class="line">    uint32_t alignment() const &#123;</div><div class="line">        <span class="keyword">if</span> (alignment_raw == ~(uint32_t)<span class="number">0</span>) <span class="keyword">return</span> 1U &lt;&lt; <span class="type">WORD_SHIFT</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以根据实例查找其在类中的名字，也就是“反射”：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-(<span class="type">NSString</span> )nameWithInstance:(id)instance &#123;</div><div class="line">    unsigned int numIvars = <span class="number">0</span>;</div><div class="line">    <span class="type">NSString</span> key=<span class="literal">nil</span>;</div><div class="line">    <span class="type">Ivar</span>  ivars = class_copyIvarList([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], &amp;<span class="title">numIvars</span>);</span></div><div class="line">    <span class="title">for</span>(<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">numIvars</span>; <span class="title">i</span>++) &#123;</div><div class="line">        <span class="type">Ivar</span> thisIvar = ivars[i];</div><div class="line">        const char type = ivar_getTypeEncoding(thisIvar);</div><div class="line">        <span class="type">NSString</span> *stringType =  [<span class="type">NSString</span> stringWithCString:type encoding:<span class="type">NSUTF8StringEncoding</span>];</div><div class="line">        <span class="keyword">if</span> (![stringType hasPrefix:@<span class="string">"@"</span>]) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((object_getIvar(<span class="keyword">self</span>, thisIvar) == instance)) &#123;<span class="comment">//此处若 crash 不要慌！</span></div><div class="line">            key = [<span class="type">NSString</span> stringWithUTF8String:ivar_getName(thisIvar)];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>class_copyIvarList</code> 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。  </p>
<h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a><a href="#objc-property-t" title="objc_property_t"></a>objc_property_t</h3><p><code>@property</code> 标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向<code>objc_property</code> 结构体的指针： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></div></pre></td></tr></table></figure>
<p>可以通过 <code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code> 方法来获取类和协议中的属性：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_property_t class_copyPropertyList(<span class="type">Class</span> cls, unsigned int outCount)</div><div class="line">objc_property_t protocol_copyPropertyList(<span class="type">Protocol</span> proto, unsigned int *outCount)</div></pre></td></tr></table></figure>
<p>返回类型为指向指针的指针，哈哈，因为属性列表是个数组，每个元素内容都是一个 <code>objc_property_t</code> 指针，而这两个函数返回的值是指向这个数组的指针。  </p>
<p>举个栗子，先声明一个类：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface <span class="type">Lender</span> : <span class="type">NSObject</span> &#123;</div><div class="line">    float alone;</div><div class="line">&#125;</div><div class="line">@property float alone;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你可以用下面的代码获取属性列表： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id <span class="type">LenderClass</span> = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line">unsigned int outCount;</div><div class="line">objc_property_t *properties = class_copyPropertyList(<span class="type">LenderClass</span>, &amp;outCount);</div></pre></td></tr></table></figure>
<p>你可以用 <code>property_getName</code> 函数来查找属性名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *property_getName(objc_property_t property)</div></pre></td></tr></table></figure>
<p>你可以用<code>class_getProperty</code> 和 <code>protocol_getProperty</code>通过给出的名称来在类和协议中获取属性的引用：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">objc_property_t class_getProperty(<span class="type">Class</span> cls, const char name)</div><div class="line">objc_property_t protocol_getProperty(<span class="type">Protocol</span> proto, const char *name, <span class="type">BOOL</span> isRequiredProperty, <span class="type">BOOL</span> isInstanceProperty)</div></pre></td></tr></table></figure>
<p>你可以用<code>property_getAttributes</code>函数来发掘属性的名称和<code>@encode</code>类型字符串：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *property_getAttributes(objc_property_t property)</div></pre></td></tr></table></figure>
<p>把上面的代码放一起，你就能从一个类中获取它的属性啦：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id <span class="type">LenderClass</span> = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line">unsigned int outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(<span class="type">LenderClass</span>, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    objc_property_t property = properties[i];</div><div class="line">    fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比下 <code>class_copyIvarList</code> 函数，使用 <code>class_copyPropertyList</code> 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的。</p>
<h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a><a href="#protocol-t" title="protocol_t"></a>protocol_t</h3><p>虽然 Objective-C 的 <code>Category</code> 和 <code>protocol</code> 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。</p>
<p><code>flags</code> 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。</p>
<p><code>protocol</code> 主要内容其实是（可选）方法，其次就是继承其他 <code>protocol</code>。Swift 还支持 <code>protocol</code> 多继承，所以需要 <code>protocols</code> 数组来做兼容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> : <span class="title">objc_object</span> </span>&#123;</div><div class="line">    const char mangledName;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> <span class="title">protocols</span>;</span></div><div class="line">    <span class="title">method_list_t</span> <span class="title">instanceMethods</span>;</div><div class="line">    <span class="title">method_list_t</span> <span class="title">classMethods</span>;</div><div class="line">    <span class="title">method_list_t</span> <span class="title">optionalInstanceMethods</span>;</div><div class="line">    <span class="title">method_list_t</span> <span class="title">optionalClassMethods</span>;</div><div class="line">    <span class="title">property_list_t</span> <span class="title">instanceProperties</span>;</div><div class="line">    <span class="title">uint32_t</span> <span class="title">size</span>;   // <span class="title">sizeof</span>(<span class="title">protocol_t</span>)</div><div class="line">    <span class="title">uint32_t</span> <span class="title">flags</span>;</div><div class="line">    // <span class="title">Fields</span> <span class="title">below</span> <span class="title">this</span> <span class="title">point</span> <span class="title">are</span> <span class="title">not</span> <span class="title">always</span> <span class="title">present</span> <span class="title">on</span> <span class="title">disk</span>.</div><div class="line">    <span class="title">const</span> <span class="title">char</span> **<span class="title">_extendedMethodTypes</span>;</div><div class="line">    <span class="title">const</span> <span class="title">char</span> <span class="title">_demangledName</span>;</div><div class="line">    <span class="title">property_list_t</span> *<span class="title">_classProperties</span>;</div><div class="line">    ... 省略一些封装的便捷 <span class="title">get</span> 方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><a href="#IMP" title="IMP"></a>IMP</h3><p><code>IMP</code>在<code>objc.h</code>中的定义是：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void (<span class="type">IMP</span>)(void / id, <span class="type">SEL</span>, ... */ );</div></pre></td></tr></table></figure>
<p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="external">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。  </p>
<p>你会发现 <code>IMP</code> 指向的方法与 <code>objc_msgSend</code> 函数类型相同，参数都包含 <code>id</code> 和 <code>SEL</code> 类型。每个方法名都对应一个 <code>SEL</code> 类型的方法选择器，而每个实例对象中的 <code>SEL</code> 对应的方法实现肯定是唯一的，通过一组 <code>id</code> 和 <code>SEL</code> 参数就能确定唯一的方法实现地址；反之亦然。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a><a href="#消息" title="消息"></a>消息</h2><p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。  </p>
<p><strong>有关消息发送和消息转发机制的原理，可以查看<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">这篇文章</a>。</strong></p>
<h3 id="objc-msgSend-函数"><a href="#objc-msgSend-函数" class="headerlink" title="objc_msgSend 函数"></a><a href="#objc-msgSend-函数" title="objc_msgSend 函数"></a>objc_msgSend 函数</h3><p>在引言中已经对<code>objc_msgSend</code>进行了一点介绍，看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤： </p>
<ol>
<li>检测这个 <code>selector</code> 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>
<li>检测这个 target 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。6.  如果还找不到就要开始进入<strong>动态方法</strong>解析了，后面会提到。</li>
</ol>
<p>PS:这里说的分发表其实就是<code>Class</code>中的方法列表，它将方法选择器和方法实现地址联系起来。  </p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="">  </p>
<p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。排列组合正好四个方法。  </p>
<p>值得一提的是在 i386 平台处理返回类型为浮点数的消息时，需要用到<code>objc_msgSend_fpret</code>函数来进行处理，这是因为返回类型为浮点数的函数对应的 ABI(Application Binary Interface) 与返回整型的函数的 ABI 不兼容。此时<code>objc_msgSend</code>不再适用，于是<code>objc_msgSend_fpret</code>被派上用场，它会对浮点数寄存器做特殊处理。不过在 PPC 或 PPC64 平台是不需要麻烦它的。   </p>
<p>PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。  </p>
<h3 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a><a href="#方法中的隐藏参数" title="方法中的隐藏参数"></a>方法中的隐藏参数</h3><p>我们经常在方法中使用<code>self</code>关键字来引用实例本身，但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧。其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的。  </p>
<p>当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:  </p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    <span class="type">SEL</span> method = getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，<code>self</code> 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径。  </p>
<p>而当方法中的<code>super</code>关键字接收到消息时，编译器会创建一个<code>objc_super</code>结构体： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123; id receiver; <span class="type">Class</span> <span class="class"><span class="keyword">class</span>; &#125;;</span></div></pre></td></tr></table></figure>
<p>这个结构体指明了消息应该被传递给特定超类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的SEL传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&amp;gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。    </p>
<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a><a href="#获取方法地址" title="获取方法地址"></a>获取方法地址</h3><p>在<code>IMP</code>那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。  </p>
<p><code>NSObject</code>类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的<code>IMP</code>，举个栗子：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (setter)(id, <span class="type">SEL</span>, <span class="type">BOOL</span>);</div><div class="line">int i;</div><div class="line"> </div><div class="line">setter = (void ()(id, <span class="type">SEL</span>, <span class="type">BOOL</span>))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), <span class="type">YES</span>);</div></pre></td></tr></table></figure>
<p>当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。上面的例子调用了1000次函数，你可以试试直接给<code>target</code>发送1000次<code>setFilled:</code>消息会花多久。  </p>
<p>PS：<code>methodForSelector:</code>方法是由 Cocoa 的 Runtime 系统提供的，而不是 Objc 自身的特性。  </p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a><a href="#动态方法解析" title="动态方法解析"></a>动态方法解析</h2><p>你可以动态地提供一个方法的实现。例如我们可以用<code>@dynamic</code>关键字在类的实现文件中修饰一个属性： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">dynamic</span> propertyName;</div></pre></td></tr></table></figure>
<p>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成<code>setPropertyName:</code>和<code>propertyName</code>方法，而需要我们动态提供。我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void dynamicMethodIMP(id <span class="keyword">self</span>, <span class="type">SEL</span> _cmd) &#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div><div class="line">@implementation <span class="type">MyClass</span></div><div class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], <span class="title">aSEL</span>, (<span class="title">IMP</span>) <span class="title">dynamicMethodIMP</span>, "<span class="title">v</span>@:");</span></div><div class="line">          <span class="title">return</span> <span class="title">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="title">return</span> [<span class="title">super</span> <span class="title">resolveInstanceMethod</span>:<span class="title">aSEL</span>];</div><div class="line">&#125;</div><div class="line">@<span class="title">end</span></div></pre></td></tr></table></figure>
<p>上面的例子为<code>resolveThisMethodDynamically</code>方法添加了实现内容，也就是<code>dynamicMethodIMP</code>方法中的代码。其中 “<code>v@:</code>” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Type Encoding</a>   </p>
<p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code>方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的<code>IMP</code>的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code>返回<code>NO</code>。  </p>
<p>评论区有人问如何用 <code>resolveClassMethod:</code> 解析类方法，我将他贴出有问题的代码做了纠正和优化后如下，可以顺便将实例方法和类方法的动态方法解析对比下：</p>
<p>头文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface <span class="type">Student</span> : <span class="type">NSObject</span></div><div class="line">+ (void)learnClass:(<span class="type">NSString</span> ) string;</div><div class="line">- (void)goToSchool:(<span class="type">NSString</span> ) name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>m 文件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">import</span> "Student.h"</div><div class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation <span class="type">Student</span></div><div class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(<span class="type">SEL</span>)sel &#123;</div><div class="line">    <span class="keyword">if</span> (sel == @selector(learnClass:)) &#123;</div><div class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), @selector(myClassMethod:)), <span class="string">"v@:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="type">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(<span class="type">SEL</span>)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == @selector(goToSchool:)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>], <span class="title">aSEL</span>, <span class="title">class_getMethodImplementation</span>([<span class="title">self</span> <span class="title">class</span>], @<span class="title">selector</span>(<span class="title">myInstanceMethod</span>:)), "<span class="title">v</span>@:");</span></div><div class="line">        <span class="title">return</span> <span class="title">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="title">return</span> [<span class="title">super</span> <span class="title">resolveInstanceMethod</span>:<span class="title">aSEL</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="title">void</span>)<span class="title">myClassMethod</span>:(<span class="title">NSString</span> )<span class="title">string</span> &#123;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"myClassMethod = %@"</span>, string);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)myInstanceMethod:(<span class="type">NSString</span> )string &#123;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"myInstanceMethod = %@"</span>, string);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>需要深刻理解 <code>[self class]</code> 与 <code>object_getClass(self)</code> 甚至 <code>object_getClass([self class])</code> 的关系，其实并不难，重点在于 <code>self</code> 的类型：</p>
<ol>
<li>当 <code>self</code> 为实例对象时，<code>[self class]</code> 与 <code>object_getClass(self)</code> 等价，因为前者会调用后者。<code>object_getClass([self class])</code> 得到元类。</li>
<li>当 <code>self</code> 为类对象时，<code>[self class]</code> 返回值为自身，还是 <code>self</code>。<code>object_getClass(self)</code> 与 <code>object_getClass([self class])</code> 等价。</li>
</ol>
<p>凡是涉及到类方法时，一定要弄清楚元类、selector、IMP 等概念，这样才能做到举一反三，随机应变。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a><a href="#消息转发" title="消息转发"></a>消息转发</h2><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/QQ20141113-1@2x.png?imageView2/2/w/800/q/75|watermark/2/text/eXVsaW5ndGlhbnhpYQ==/font/Y29taWMgc2FucyBtcw==/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="">  </p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><a href="#重定向" title="重定向"></a>重定向</h3><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(aSelector == @selector(mysteriousMethod:))&#123;</div><div class="line">        <span class="keyword">return</span> alternateObject;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，<del>不过千万别返回<code>self</code>，因为那样会死循环。</del> 如果此方法返回nil或self,则会进入消息转发机制(<code>forwardInvocation:</code>);否则将向返回的对象重新发送消息。  </p>
<p>如果想替换<strong>类方法</strong>的接受者，需要覆写 <code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法，并返回<strong>类对象</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (id)forwardingTargetForSelector:(<span class="type">SEL</span>)aSelector &#123;</div><div class="line">    <span class="keyword">if</span>(aSelector == @selector(xxx)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">NSClassFromString</span>(@<span class="string">"Class name"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a><a href="#转发" title="转发"></a>转发</h3><p>当动态方法解析不作处理返回<code>NO</code>时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(<span class="type">NSInvocation</span> *)anInvocation</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</div><div class="line">            [anInvocation selector]])</div><div class="line">        [anInvocation invokeWithTarget:someOtherObject];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。  </p>
<p>这里需要注意的是参数<code>anInvocation</code>是从哪的来的呢？其实在<code>forwardInvocation:</code>消息发送前，Runtime系统会向对象发送<code>methodSignatureForSelector:</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code>方法，否则会抛异常。  </p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过<code>forwardInvocation:</code>消息通知该对象。每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation:</code>方法。然而，<code>NSObject</code>中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。  </p>
<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。  </p>
<p>注意： <code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将<code>negotiate</code>消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p>
<h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a><a href="#转发和多继承" title="转发和多继承"></a>转发和多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。    </p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="">  </p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。  </p>
<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。  </p>
<h3 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a><a href="#替代者对象-Surrogate-Objects" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h3><p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="external">官方文档</a>。  </p>
<h3 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a><a href="#转发与继承" title="转发与继承"></a>转发与继承</h3><p>尽管转发很像继承，但是<code>NSObject</code>类不会将两者混淆。像<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个<code>Warrior</code>对象如果被问到是否能响应<code>negotiate</code>消息：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:@selector(negotiate)] )</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>结果是<code>NO</code>，尽管它能够接受<code>negotiate</code>消息而不报错，因为它靠转发消息给<code>Diplomat</code>类来响应消息。  </p>
<p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code>继承到了<code>Diplomat</code>的<code>negotiate</code>方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>来加入你的转发算法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="type">BOOL</span>)respondsToSelector:(<span class="type">SEL</span>)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</div><div class="line">        <span class="keyword">return</span> <span class="type">YES</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        / <span class="type">Here</span>, test whether the aSelector message can     </div><div class="line">          be forwarded to another object and whether that  </div><div class="line">          object can respond to it. <span class="type">Return</span> <span class="type">YES</span> <span class="keyword">if</span> it can.  /</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code>同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现<code>methodSignatureForSelector:</code>： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="type">NSMethodSignature</span>)methodSignatureForSelector:(<span class="type">SEL</span>)selector</div><div class="line">&#123;</div><div class="line">    <span class="type">NSMethodSignature</span> signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">       signature = [surrogate methodSignatureForSelector:selector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量 (Non Fragile ivars)"></a><a href="#健壮的实例变量-Non-Fragile-ivars" title="健壮的实例变量 (Non Fragile ivars)"></a>健壮的实例变量 (Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf1.png" alt="">  </p>
<p>上图左边是<code>NSObject</code>类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果哪天苹果更新了<code>NSObject</code>类，发布新版本的系统的话，那就悲剧了：  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf2.png" alt="">  </p>
<p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？  </p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf3.png" alt="">  </p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。  </p>
<p>需要注意的是在健壮的实例变量下，不要使用<code>sizeof(SomeClass)</code>，而是用<code>class_getInstanceSize([SomeClass class])</code>代替；也不要使用<code>offsetof(SomeClass, SomeIvar)</code>，而要用<code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &amp;quot;SomeIvar&amp;quot;))</code>来代替。</p>
<p><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/" target="_blank" rel="external">优化 App 的启动时间</a> 讲过加载 Mach-O 文件时有个步骤是通过 fix-up 修改偏移量来解决 fragile base class。</p>
<h2 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a><a href="#Objective-C-Associated-Objects" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h2><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void objc_setAssociatedObject ( id object, const void key, id value, objc_AssociationPolicy policy );</div><div class="line">id objc_getAssociatedObject ( id object, const void key );</div><div class="line">void objc_removeAssociatedObjects ( id object );</div></pre></td></tr></table></figure>
<p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;</div><div class="line">   <span class="type">OBJC_ASSOCIATION_ASSIGN</span>  = <span class="number">0</span>,</div><div class="line">   <span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>  = <span class="number">1</span>,</div><div class="line">   <span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>  = <span class="number">3</span>,</div><div class="line">   <span class="type">OBJC_ASSOCIATION_RETAIN</span>  = <span class="number">01401</span>,</div><div class="line">   <span class="type">OBJC_ASSOCIATION_COPY</span>  = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。<strong>有关 Objective-C 引用计数机制的原理，可以查看<a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="external">这篇文章</a></strong>。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a><a href="#Method-Swizzling" title="Method Swizzling"></a>Method Swizzling</h2><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。  </p>
<p>PS: 对于熟练使用 Method Swizzling 的开发者，可以跳过此章节，看看我另一篇『稍微深入』一点的文章 <a href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/" target="_blank" rel="external">Objective-C Method Swizzling</a>。</p>
<p>这里摘抄一个 NSHipster 的例子： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt; </div><div class="line"> </div><div class="line">@implementation <span class="type">UIViewController</span> (<span class="type">Tracking</span>) </div><div class="line"> </div><div class="line">+ (void)load &#123; </div><div class="line">    <span class="keyword">static</span> dispatch_once_t onceToken; </div><div class="line">    dispatch_once(&amp;onceToken, ^&#123; </div><div class="line">        <span class="type">Class</span> aClass = [<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>]; </span></div><div class="line"> </div><div class="line">        <span class="title">SEL</span> <span class="title">originalSelector</span> = @<span class="title">selector</span>(<span class="title">viewWillAppear</span>:); </div><div class="line">        <span class="title">SEL</span> <span class="title">swizzledSelector</span> = @<span class="title">selector</span>(<span class="title">xxx_viewWillAppear</span>:); </div><div class="line"> </div><div class="line">        <span class="title">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">aClass</span>, <span class="title">originalSelector</span>); </div><div class="line">        <span class="title">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">aClass</span>, <span class="title">swizzledSelector</span>); </div><div class="line">        </div><div class="line">        // <span class="title">When</span> <span class="title">swizzling</span> <span class="title">a</span> <span class="title">class</span> <span class="title">method</span>, <span class="title">use</span> <span class="title">the</span> <span class="title">following</span>:</div><div class="line">        // <span class="title">Class</span> <span class="title">aClass</span> = <span class="title">object_getClass</span>((<span class="title">id</span>)<span class="title">self</span>);</div><div class="line">        // ...</div><div class="line">        // <span class="title">Method</span> <span class="title">originalMethod</span> = <span class="title">class_getClassMethod</span>(<span class="title">aClass</span>, <span class="title">originalSelector</span>);</div><div class="line">        // <span class="title">Method</span> <span class="title">swizzledMethod</span> = <span class="title">class_getClassMethod</span>(<span class="title">aClass</span>, <span class="title">swizzledSelector</span>);</div><div class="line"> </div><div class="line">        <span class="title">BOOL</span> <span class="title">didAddMethod</span> = </div><div class="line">            <span class="title">class_addMethod</span>(<span class="title">aClass</span>, </div><div class="line">                <span class="title">originalSelector</span>, </div><div class="line">                <span class="title">method_getImplementation</span>(<span class="title">swizzledMethod</span>), </div><div class="line">                <span class="title">method_getTypeEncoding</span>(<span class="title">swizzledMethod</span>)); </div><div class="line"> </div><div class="line">        <span class="title">if</span> (<span class="title">didAddMethod</span>) &#123; </div><div class="line">            class_replaceMethod(aClass, </div><div class="line">                swizzledSelector, </div><div class="line">                method_getImplementation(originalMethod), </div><div class="line">                method_getTypeEncoding(originalMethod)); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class="line">        &#125; </div><div class="line">    &#125;); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">#pragma mark - <span class="type">Method</span> <span class="type">Swizzling</span> </div><div class="line"> </div><div class="line">- (void)xxx_viewWillAppear:(<span class="type">BOOL</span>)animated &#123; </div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"viewWillAppear: %@"</span>, <span class="keyword">self</span>); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。  </p>
<p>如果类中不存在要替换的方法，那就先用<code>class_addMethod</code>和<code>class_replaceMethod</code>函数添加和替换两个方法的实现；如果类中已经有了想要替换的方法，那么就调用<code>method_exchangeImplementations</code>函数交换了两个方法的 <code>IMP</code>，这是苹果提供给我们用于实现 Method Swizzling 的便捷方法。  </p>
<p>可能有人注意到了这行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// When swizzling a class method, use the following:</span></div><div class="line"><span class="comment">// Class aClass = object_getClass((id)self);</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class="line"><span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure>
<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object class]</code> 的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="type">Class</span>)<span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="type">Class</span>)<span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PS:如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现；否则调用<code>method_setImplementation</code>方法，<code>types</code>参数会被忽略。<code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">IMP</span> imp1 = method_getImplementation(m1);</div><div class="line"><span class="type">IMP</span> imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure>
<p>最后<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]</code>换成<code>[self viewWillAppear:animated]</code>反而会引发死循环。  </p>
<p>看到有人说<code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 stackoverflow 上也有大神给出了另一个 Method Swizzling 的实现：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)replacementReceiveMessage:(const <span class="class"><span class="keyword">struct</span> <span class="title">BInstantMessage</span> *)<span class="title">arg1</span> </span>&#123;</div><div class="line">    <span class="type">NSLog</span>(@<span class="string">"arg1 is %@"</span>, arg1);</div><div class="line">    [<span class="keyword">self</span> replacementReceiveMessage:arg1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    <span class="type">SEL</span> originalSelector = @selector(<span class="type">ReceiveMessage</span>:);</div><div class="line">    <span class="type">SEL</span> overrideSelector = @selector(replacementReceiveMessage:);</div><div class="line">    <span class="type">Method</span> originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</div><div class="line">    <span class="type">Method</span> overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</div><div class="line">    <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</div><div class="line">            class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, overrideMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码同样要添加在某个类的类别中，相比第一个种实现，只是去掉了<code>dispatch_once</code> 部分。  </p>
<p>Method Swizzling 的确是一个值得深入研究的话题，找了几篇不错的资源推荐给大家：  </p>
<ul>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）:  Method Swizzling</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>*   <a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="external">How do I implement method swizzling?</a></li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></li>
</ul>
<p>在用 SpriteKit 写游戏的时候,因为 API 本身有一些缺陷(增删节点时不考虑父节点是否存在啊,很容易崩溃啊有木有!),我在 Swift 上使用 Method Swizzling弥补这个缺陷:  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxyswizzleAddChild</span>() </span>&#123;</div><div class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></div><div class="line">        <span class="keyword">let</span> originalSelector = #selector(<span class="type">SKNode</span>.addChild(:))</div><div class="line">        <span class="keyword">let</span> swizzledSelector = #selector(<span class="type">SKNode</span>.yxyaddChild(:))</div><div class="line">        <span class="keyword">let</span> originalMethod = classgetInstanceMethod(cls, originalSelector)</div><div class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</div><div class="line">        method_exchangeImplementations(originalMethod!, swizzledMethod!)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleRemoveFromParent</span>() </span>&#123;</div><div class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></div><div class="line">        <span class="keyword">let</span> originalSelector = #selector(<span class="type">SKNode</span>.removeFromParent)</div><div class="line">        <span class="keyword">let</span> swizzledSelector = #selector(<span class="type">SKNode</span>.yxy_removeFromParent)</div><div class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</div><div class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</div><div class="line">        method_exchangeImplementations(originalMethod!, swizzledMethod!)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">yxy_addChild</span><span class="params">( node: SKNode)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> node.parent == <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">self</span>.yxy_addChild(node)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"This node has already a parent!(String(describing: node.name))"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">yxy_removeFromParent</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> parent != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="type">DispatchQueue</span>.main.async(execute: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">                <span class="keyword">self</span>.yxy_removeFromParent()</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"This node has no parent!(String(describing: name))"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后其他地方调用那两个类方法: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">SKNode</span>.yxy_swizzleAddChild()</div><div class="line"><span class="type">SKNode</span>.yxy_swizzleRemoveFromParent()</div></pre></td></tr></table></figure>
<p>因为 Swift 中的 extension 的特殊性,最好在某个类的<code>load()</code> 方法中调用上面的两个方法.我是在AppDelegate 中调用的,于是保证了应用启动时能够执行上面两个方法.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h2><p>我们之所以让自己的类继承 <code>NSObject</code> 不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。可能我们平时写代码时可能很少会考虑一句简单的 <code>[receiver message]</code> 背后发生了什么，而只是当做方法或函数调用。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 Method Swizzling 等。</p>
<p>Update 20170820: 使用 objc4-709 源码重写部分章节，更新至 Swift 4 代码示例。</p>
<p>参考链接： </p>
<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="external">Objective-C runtime之运行时的基本特点</a></li>
<li><a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">Understanding the Objective-C Runtime</a></li>
</ul>
<p>相关推荐:</p>
<ul>
<li><a href="http://www.cocoachina.com/ios/20160523/16386.html" target="_blank" rel="external">Runtime全方位装逼指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/20
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="runtime" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/runtime/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="runtime" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/runtime/"/>
    
      <category term="动态运行时" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
      <category term="消息" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之排序基本用法(C语言)</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/17/17.09.16_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C(C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/17/17.09.16_数据结构与算法之排序基本操作(C语言)/</id>
    <published>2017-09-17T14:40:19.000Z</published>
    <updated>2017-09-18T14:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目Git地址：<a href="https://github.com/zhoutq/DataStructuresAndAlgorithms-Sort">DataStructuresAndAlgorithms-Sort</a>。</p>
<p>基本用法：</p>
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>折半插入排序</li>
<li>选择排序</li>
<li>快速排序</li>
<li>归并排序</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  main.c</span></div><div class="line"><span class="comment">//  SortTest</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by zhoutq on 2017/9/17.</span></div><div class="line"><span class="comment">//  Copyright © 2017年 zhoutq. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> printfSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line"></div><div class="line">        printf(<span class="string">"%d,"</span>,a[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 冒泡排序：时间复杂度 -- O(n^2)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">在冒泡排序过程中会将数组分成两部分，一部分是已经有序的数列，一部分是无序的数列。</div><div class="line">无序数列中不断的将其中最小的值往有序序列中冒泡，泡冒完后，我们的序列就创建好了。</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> bubbleSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 如果前面的大于后面的，将大的放到后面</span></div><div class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">int</span> temp;</div><div class="line">                    temp = a[j];</div><div class="line">                    a[j] = a[j + <span class="number">1</span>];</div><div class="line">                    a[j + <span class="number">1</span>] = temp;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 再用后面的和它后面的比较</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 插入排序：时间复杂度 -- O(n^2)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">插入排序算是比较好理解的排序方式，插入排序也是将要排序的数列分为两部分，</div><div class="line">前半部分是已经排好序的，后半部分则是无序的。插入排序中的插入是指“取出无序数列中第一个值，</div><div class="line">插入到有序数列中相应的位置”。其实这个插入过程也是不断比较和交换的过程。</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> insertSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">//有序数列end</span></div><div class="line">        <span class="keyword">int</span> num = a[i]; <span class="comment">// 带插入数</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; num) &#123;</div><div class="line">            <span class="comment">// 如果num比有序比较数大，则将比较数往后移动 （从后往前查找，大的往后移动）</span></div><div class="line">            a[j + <span class="number">1</span>] = a[j];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        a[j + <span class="number">1</span>] = num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//折半插入</span></div><div class="line"><span class="keyword">void</span> binaryInsertSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=i;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> num = a[i];        <span class="comment">//复制为哨兵，即存储待排序元素</span></div><div class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;  <span class="comment">//查找在有序表的插入位置  (遍历表)</span></div><div class="line"></div><div class="line">            <span class="keyword">int</span> m = (low + high) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(num&lt;a[m]) &#123;</div><div class="line"></div><div class="line">                high = m - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                low = m + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = i<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= high + <span class="number">1</span>; j--) &#123;</div><div class="line">            a[j + <span class="number">1</span>] = a[j];</div><div class="line">        &#125;</div><div class="line">        a[j+<span class="number">1</span>] = num;      <span class="comment">//插入到正确位置</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 选择排序：时间复杂度 -- O(n^2)</span></div><div class="line"><span class="comment">/* 在选择排序过程中，数组仍然被分作有序和无序两部分。而选择排序中的“选择”</span></div><div class="line">是指不断从无序序列中选择最小的值放入到有序序列的最后的位置，换句话说就是</div><div class="line">从现有的无序序列中找出那个最小的值，然后与无序序列的第一个值进行交换，然后</div><div class="line">缩小无序序列的范围即可。因为有序序列的最后一个值与无序序列的第一个值紧挨着，</div><div class="line">交换后，这个无序序列中的第一个值就成了有序序列的最后一个值。重复这个选择的过程，</div><div class="line">我们的数组就会变得有序。</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> selectSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</div><div class="line"></div><div class="line">                min = j; <span class="comment">//记录最小的数，继续查询</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (min != i) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> temp;</div><div class="line">            temp = a[i];</div><div class="line">            a[i] = a[min];</div><div class="line">            a[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 快速排序：时间复杂度 -- O(nlogn)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">    快速排序的思想主要是取出无序序列中第一个值，然后通过比较将比该值小的元素放到该值的前方，将比该值大的元素放在该值的后方。</div><div class="line">    这样一来该值前方的数据都要比该值小，该值后方的数据都要比该值大。然后再次对前半部分和后边半部分无序的数列进行上述操作，</div><div class="line">    这样不断的操作，无序的序列的规模不断被缩小。等问题的规模被缩小到一定程度后，我们的序列就变的有序了</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> quickSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = left, j = right, k = a[left];</div><div class="line"></div><div class="line">    <span class="comment">// 当 i = j 时说明已经找到 k 的位置，停止查找</span></div><div class="line">    <span class="keyword">while</span> (i &lt; j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= k) j--; <span class="comment">// 从右向左找小于k的数</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(i &lt; j) a[i++] = a[j]; <span class="comment">// 如果 i &lt; j说明 j 已查到，则将其填入 a[i]( a[i] 已被暂存：k = a[left] 或者a[j--] = a[i])，i 后移</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= k) i++; <span class="comment">// 从左向右找大于k的数</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(i &lt; j) a[j--] = a[i]; <span class="comment">// 如果 i &lt; j说明 i 已查到，则将其填入 a[j]( a[j] 已被暂存：a[i++] = a[j])，j 前移</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 结束循环时 i = j 已经确定 k 的位置，将 k 填入。</span></div><div class="line">    a[i] = k;</div><div class="line">    <span class="comment">// 递归调用</span></div><div class="line">    quickSort(a, left, i - <span class="number">1</span>);</div><div class="line">    quickSort(a, i + <span class="number">1</span>, right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 归并排序：时间复杂度 -- O(nlogn)</span></div><div class="line"><span class="comment">/*</span></div><div class="line">归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> merge(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high);</div><div class="line"></div><div class="line"><span class="keyword">void</span> mergeSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line"></div><div class="line">        mergeSort(a, low, mid);</div><div class="line">        mergeSort(a, mid + <span class="number">1</span>, high);</div><div class="line">        merge(a, low, mid, high);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> merge(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start1 = low, end1 = mid, start2 = mid + <span class="number">1</span>, end2 = high;</div><div class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)malloc((high - low + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 开辟对应大小的内存空间</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="comment">// 两部分相互比较，按照升序将数据暂存入temp</span></div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; start1 &lt;= end1 &amp;&amp; start2 &lt;= end2; k++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a[start1] &lt; a[start2]) &#123;</div><div class="line">            temp[k] = a[start1++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            temp[k] = a[start2++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检测是否有剩余项，直接拷贝到temp</span></div><div class="line">    <span class="keyword">while</span> (start1 &lt;= end1) temp[k++] = a[start1++];</div><div class="line">    <span class="keyword">while</span> (start2 &lt;= end2) temp[k++] = a[start2++];</div><div class="line"></div><div class="line">    <span class="comment">// 将temp拷贝到原数组地址范围内</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; high - low + <span class="number">1</span>; i++) &#123;</div><div class="line"></div><div class="line">        a[low + i] = temp[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    free(temp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</div><div class="line">    <span class="comment">//    int a[10] = &#123;2,2,2,2,2,1,1,1,1,1&#125;;</span></div><div class="line"></div><div class="line">    printfSort(a, <span class="number">10</span>);</div><div class="line">    <span class="comment">//    bubbleSort(a, 10);</span></div><div class="line">    <span class="comment">//    insertSort(a, 10);</span></div><div class="line">    <span class="comment">//    binaryInsertSort(a, 10);</span></div><div class="line">    <span class="comment">//    selectSort(a, 10);</span></div><div class="line">    <span class="comment">//    quickSort(a, 0, 9);</span></div><div class="line">    mergeSort(a, <span class="number">0</span>, <span class="number">9</span>);</div><div class="line">    printfSort(a, <span class="number">10</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;项目Git地址：&lt;a href=&quot;https://github.com/zhoutq/DataStructuresAndAlgorithms
    
    </summary>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/"/>
    
      <category term="排序" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/c-c/"/>
    
      <category term="排序" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之二叉树基本用法(C语言)</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/16/17.09.16_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/16/17.09.16_数据结构与算法之二叉树基本用法(C语言)/</id>
    <published>2017-09-16T11:32:19.000Z</published>
    <updated>2017-09-17T14:45:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目Git地址：<a href="https://github.com/zhoutq/DataStructuresAndAlgorithms-BTree">DataStructuresAndAlgorithms-BTree</a>。</p>
<p>基本用法：</p>
<ul>
<li>创建二叉树</li>
<li>前序遍历二叉树</li>
<li>中序遍历二叉树</li>
<li>后序遍历二叉树</li>
<li>二叉树节点个数</li>
<li>二叉树叶子节点个数</li>
<li>二叉树第k层节点个数</li>
<li>二叉树深度</li>
<li>二叉树转换为有序双向链表</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  main.c</span></div><div class="line"><span class="comment">//  BTreeTest</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by zhoutq on 2017/9/16.</span></div><div class="line"><span class="comment">//  Copyright © 2017年 zhoutq. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">定义二叉树节点类型</div><div class="line">*/</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BNode &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> data;</div><div class="line">    <span class="keyword">struct</span> BNode *lChild, *rChild;</div><div class="line">&#125;BTree;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">创建二叉树:先创建根节点，然后递归用同样的方法创建其左右子节点</div><div class="line"></div><div class="line">     a</div><div class="line">    / \</div><div class="line">    b  e</div><div class="line">   / \ /</div><div class="line">  c  d f</div><div class="line"></div><div class="line">  如果创建上面二叉树，‘ ’表示结束子节点创建，则输入字符串为:</div><div class="line">  ‘a’ - 'b' - 'c' - ' ' - ' ' - 'd' - ' ' - ' ' - 'e' - 'f' - ' ' - ' ' - ' '</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 键盘输入读取</span></div><div class="line">BTree *CreateBTree() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    printf(<span class="string">"please input btree data:"</span>);</div><div class="line">    scanf(<span class="string">"%c"</span>,&amp;c);</div><div class="line">    getchar(); <span class="comment">// 屏蔽回车</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BTree *bt = (BTree *)malloc(<span class="keyword">sizeof</span>(BTree));</div><div class="line">    bt-&gt;data = c;</div><div class="line">    bt-&gt;lChild = CreateBTree(); <span class="comment">// 递归创建左子节点</span></div><div class="line">    bt-&gt;rChild = CreateBTree(); <span class="comment">// 递归创建右子节点</span></div><div class="line">    <span class="keyword">return</span> bt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组读取</span></div><div class="line">BTree *CreateBTree2(<span class="keyword">char</span> a[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> c = a[n++];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BTree *bt = (BTree *)malloc(<span class="keyword">sizeof</span>(BTree));</div><div class="line">    bt-&gt;data = c;</div><div class="line">    bt-&gt;lChild = CreateBTree2(a); <span class="comment">// 递归创建左子节点</span></div><div class="line">    bt-&gt;rChild = CreateBTree2(a); <span class="comment">// 递归创建右子节点</span></div><div class="line">    <span class="keyword">return</span> bt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">前序遍历二叉树：遍历顺序 root -&gt; lChild -&gt; rChild，示例结果：abcdef</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> PreorderPrintfBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printf(<span class="string">"%c"</span>,bt-&gt;data);</div><div class="line">    PreorderPrintfBTree(bt-&gt;lChild);</div><div class="line">    PreorderPrintfBTree(bt-&gt;rChild);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">中序遍历二叉树：遍历顺序 lChild -&gt; root -&gt; rChild，示例结果：cbdafe</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> InorderPrintfBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InorderPrintfBTree(bt-&gt;lChild);</div><div class="line">    printf(<span class="string">"%c"</span>,bt-&gt;data);</div><div class="line">    InorderPrintfBTree(bt-&gt;rChild);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">后序遍历二叉树：遍历顺序 lChild -&gt; rChild -&gt; root，示例结果：cdbfea</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> PostorderPrintfBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PostorderPrintfBTree(bt-&gt;lChild);</div><div class="line">    PostorderPrintfBTree(bt-&gt;rChild);</div><div class="line">    printf(<span class="string">"%c"</span>,bt-&gt;data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">二叉树节点个数：如果二叉树为空，则二叉树节点个数为 0 ，</div><div class="line">如果不为空，则二叉树节点个数为左子节点个数 + 右子节点个数 + 1(该根节点)</div><div class="line">*/</div><div class="line"><span class="keyword">int</span> NodeCountBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (NodeCountBTree(bt-&gt;lChild) + NodeCountBTree(bt-&gt;rChild) + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">二叉树叶子节点个数：如果二叉树为空，则二叉树叶子节点个数为 0 ，</div><div class="line">如果不为空，但左右子节点都为空，则二叉树叶子节点个数为 1</div><div class="line">如果不为空，则二叉树叶子节点个数为左右子节点叶子节点个数之和</div><div class="line">*/</div><div class="line"><span class="keyword">int</span> LeafNodeCountBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt-&gt;lChild &amp;&amp; !bt-&gt;rChild) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (LeafNodeCountBTree(bt-&gt;lChild) + LeafNodeCountBTree(bt-&gt;rChild));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">二叉树第k层节点个数：如果二叉树为空，则二叉树叶子节点个数为 0 ，</div><div class="line">如果是第一层，则二叉树第k层节点个数为 1</div><div class="line">如果不为空，则二叉树第k层节点个数为左右子节点第k-1层节点个数之和</div><div class="line">*/</div><div class="line"><span class="keyword">int</span> KLevelNoteCount(BTree * bt, <span class="keyword">int</span> k)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == k) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> KLevelNoteCount(bt-&gt;lChild, k - <span class="number">1</span>) + KLevelNoteCount(bt-&gt;rChild, k - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">二叉树深度：如果二叉树为空，则二叉树深度为 0 ，</div><div class="line">如果不为空，则二叉树深度为子节点深度(左右子节点深度最大值) + 1(该根节点)</div><div class="line">*/</div><div class="line"><span class="keyword">int</span> DepthBTree(BTree *bt) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!bt) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 定义一个max的block函数</span></div><div class="line">    <span class="keyword">int</span> (^max)(<span class="keyword">int</span> , <span class="keyword">int</span> ) = ^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> a &gt; b ? a:b;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (max(DepthBTree(bt-&gt;lChild),DepthBTree(bt-&gt;rChild)) + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">二叉树转换为有序双向链表：转换顺序为 lChild + root + rChild</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> BTreeToBLinkList(BTree *bt, BTree **head,BTree **end) &#123;</div><div class="line">    <span class="keyword">if</span>(!bt) &#123;</div><div class="line">        *head = <span class="literal">NULL</span>;</div><div class="line">        *end = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BTree *lHead, *lEnd, *rHead, *rEnd;</div><div class="line"></div><div class="line">    BTreeToBLinkList(bt-&gt;lChild, &amp;lHead, &amp;lEnd);</div><div class="line">    BTreeToBLinkList(bt-&gt;rChild, &amp;rHead, &amp;rEnd);</div><div class="line"></div><div class="line">    bt-&gt;lChild = lEnd; <span class="comment">// 左右子节点各自转换完成后，根节点的左子节点指向左子节点的end</span></div><div class="line">    bt-&gt;rChild = rHead; <span class="comment">// 左右子节点各自转换完成后，根节点的右子节点指向右子节点的head</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lEnd) lEnd-&gt;rChild = bt; <span class="comment">// 同时，如果左子节点的end存在，则其右子节点指向根节点</span></div><div class="line">    <span class="keyword">if</span> (rHead) rHead-&gt;lChild = bt; <span class="comment">// 同时，如果右子节点的head存在，则其左子节点指向根节点</span></div><div class="line"></div><div class="line">    <span class="comment">// 返回head和end</span></div><div class="line">    *head = lHead ? : bt; <span class="comment">// 如果左子节点lHead存在，则head为lHead,否则为根节点</span></div><div class="line">    <span class="keyword">if</span> (end) *end = rEnd ? : bt; <span class="comment">// 如果右子节点rEnd存在，则end为rEnd,否则为根节点, 加if判断是因为main函数调用的时候end入参为NULL，赋值会奔溃。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'d'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>&#125;;</div><div class="line">    BTree *bt = CreateBTree2(a); <span class="comment">//CreateBTree();</span></div><div class="line">    PreorderPrintfBTree(bt);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    <span class="comment">//    InorderPrintfBTree(bt);</span></div><div class="line">    <span class="comment">//    printf("\n");</span></div><div class="line">    <span class="comment">//    PostorderPrintfBTree(bt);</span></div><div class="line">    <span class="comment">//    printf("\n");</span></div><div class="line"></div><div class="line">    <span class="comment">//    printf("node count: %d\n",NodeCountBTree(bt));</span></div><div class="line">    <span class="comment">//    printf("leaf node count: %d\n",LeafNodeCountBTree(bt));</span></div><div class="line">    <span class="comment">//    printf("k leve node count: %d\n",KLevelNoteCount(bt, 2));</span></div><div class="line">    <span class="comment">//    printf("depth: %d\n",DepthBTree(bt));</span></div><div class="line"></div><div class="line">    BTree *head;</div><div class="line">    BTreeToBLinkList(bt, &amp;head, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 定义一个打印转换后双链表的block函数</span></div><div class="line">    <span class="keyword">void</span> (^PrintfDLinkList)(BTree *) = ^(BTree *head)&#123;</div><div class="line">        BTree *p = head;</div><div class="line">        <span class="keyword">while</span> (p) &#123;</div><div class="line">            printf(<span class="string">"%c,"</span>,p-&gt;data);</div><div class="line">            p = p-&gt;rChild;</div><div class="line">        &#125;</div><div class="line">        printf(<span class="string">"\n"</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    PrintfDLinkList(head);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;项目Git地址：&lt;a href=&quot;https://github.com/zhoutq/DataStructuresAndAlgorithms
    
    </summary>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/"/>
    
      <category term="二叉树" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/c-c/"/>
    
      <category term="二叉树" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之双链表基本用法(C语言)</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/15/17.09.15_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/15/17.09.15_数据结构与算法之双链表基本用法C语言)/</id>
    <published>2017-09-15T12:14:11.000Z</published>
    <updated>2017-09-17T14:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目Git地址：<a href="https://github.com/zhoutq/DataStructuresAndAlgorithms-DLinkList">DataStructuresAndAlgorithms-DLinkList</a>。</p>
<p>基本用法：</p>
<ul>
<li>创建双链表</li>
<li>打印双链表</li>
<li>双链表指定节点数之前插入新的元素</li>
<li>双链表删除元素</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  main.c</span></div><div class="line"><span class="comment">//  DLinkList</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by zhoutq on 2017/9/15.</span></div><div class="line"><span class="comment">//  Copyright © 2017年 zhoutq. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">定义双链表节点类型</div><div class="line">*/</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> DNode &#123;</div><div class="line">    <span class="keyword">char</span> data;</div><div class="line">    <span class="keyword">struct</span> DNode *pre;</div><div class="line">    <span class="keyword">struct</span> DNode *next;</div><div class="line">&#125;DLinkList;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">创建双链表</div><div class="line">*/</div><div class="line">DLinkList* CreateDLinkList(<span class="keyword">char</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建头结点</span></div><div class="line">    DLinkList *head = (DLinkList *)malloc(<span class="keyword">sizeof</span>(DLinkList));</div><div class="line">    head-&gt;pre = <span class="literal">NULL</span>;</div><div class="line">    head-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    DLinkList *p, *q;</div><div class="line">    p = head; <span class="comment">// p 指向头结点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line"></div><div class="line">        q = (DLinkList *)malloc(<span class="keyword">sizeof</span>(DLinkList));</div><div class="line">        q-&gt;data = a[i];</div><div class="line">        q-&gt;pre = p; <span class="comment">// 新创建节点的pre指向p</span></div><div class="line">        q-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        p-&gt;next = q; <span class="comment">// p的next指向q</span></div><div class="line">        p = q; <span class="comment">// p 后移</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">打印双链表</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> PrintfDLinkList(DLinkList *head) &#123;</div><div class="line"></div><div class="line">    DLinkList *p = head-&gt;next;</div><div class="line">    <span class="keyword">while</span> (p) &#123;</div><div class="line">        printf(<span class="string">"%c,"</span>,p-&gt;data);</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">双链表指定节点数之前插入新的元素: a前面插入c</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> InsterDLinkList(DLinkList *head, <span class="keyword">char</span> a, <span class="keyword">char</span> c) &#123;</div><div class="line"></div><div class="line">    DLinkList *p = head;</div><div class="line">    DLinkList *q = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 判断 p 下一个节点数据是否为 a 数据</span></div><div class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;data == a) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// break 后 创建新节点 q</span></div><div class="line">    q = (DLinkList *)malloc(<span class="keyword">sizeof</span>(DLinkList));</div><div class="line">    q-&gt;data = c;</div><div class="line">    q-&gt;pre = p;</div><div class="line">    q-&gt;next = p-&gt;next;  <span class="comment">// 将 q-&gt;next 为原先 p-&gt;next</span></div><div class="line"></div><div class="line">    p-&gt;next-&gt;pre = q; <span class="comment">// p-&gt;next 即data == a的节点的pre指向q</span></div><div class="line">    p-&gt;next = q; <span class="comment">// 然后 p-&gt;next 指向 q</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">双链表删除元素</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> DeleteDLinkList(DLinkList *head, <span class="keyword">char</span> a) &#123;</div><div class="line"></div><div class="line">    DLinkList *p = head-&gt;next;</div><div class="line">    <span class="keyword">while</span> (p) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt;data == a) &#123;</div><div class="line"></div><div class="line">            p-&gt;pre-&gt;next = p-&gt;next;</div><div class="line">            p-&gt;next-&gt;pre = p-&gt;pre;</div><div class="line">            free(p);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line">    DLinkList *dlist = CreateDLinkList(a, <span class="number">5</span>);</div><div class="line">    PrintfDLinkList(dlist);</div><div class="line">    InsterDLinkList(dlist, <span class="string">'c'</span>, <span class="string">'b'</span>);</div><div class="line">    PrintfDLinkList(dlist);</div><div class="line">    DeleteDLinkList(dlist, <span class="string">'c'</span>);</div><div class="line">    PrintfDLinkList(dlist);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;项目Git地址：&lt;a href=&quot;https://github.com/zhoutq/DataStructuresAndAlgorithms
    
    </summary>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/"/>
    
      <category term="双链表" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/c-c/"/>
    
      <category term="双链表" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之单链表基本用法(C语言)</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/14/17.09.14_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(C%E8%AF%AD%E8%A8%80)/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/14/17.09.14_数据结构与算法之单链表基本用法(C语言)/</id>
    <published>2017-09-14T15:44:53.000Z</published>
    <updated>2017-09-17T14:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于单链表的概念，暂时未写，后期有时间更新。暂时忽律细节处理，以最简单的代码理解单链表基本操作！如果喜欢我的文章，可以关注我的GitHub:<a href="https://github.com/zhoutq">zhoutq</a>,该项目已经上传到Git-&gt;<a href="https://github.com/zhoutq/DataStructuresAndAlgorithms-LinkList">DataStructuresAndAlgorithms-LinkList</a>。</p>
<p>基本用法：</p>
<ul>
<li>创建单链表</li>
<li>打印单链表</li>
<li>销毁单链表</li>
<li>单链表指定节点数之前插入新的元素</li>
<li>单链表删除元素</li>
<li>判断单链表是否为空</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  main.c</span></div><div class="line"><span class="comment">//  LinkList</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by zhoutq on 2017/9/14.</span></div><div class="line"><span class="comment">//  Copyright © 2017年 zhoutq. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">定义单链表节点类型</div><div class="line">*/</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    <span class="keyword">char</span> data;</div><div class="line">    <span class="keyword">struct</span> Node *next;</div><div class="line">&#125;LinkList;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">创建单链表</div><div class="line">*/</div><div class="line">LinkList* CreateLinkList(<span class="keyword">char</span> a[], <span class="keyword">int</span> n) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化头结点</span></div><div class="line">    LinkList *head = (LinkList *)malloc(<span class="keyword">sizeof</span>(LinkList));</div><div class="line">    head-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    LinkList *p, *q; <span class="comment">// p 前一个节点，q 后一个节点</span></div><div class="line">    p = head; <span class="comment">// p 指向头结点</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// q 开辟空间，存储数据</span></div><div class="line">        q = (LinkList *)malloc(<span class="keyword">sizeof</span>(LinkList));</div><div class="line">        q-&gt;data = a[i];</div><div class="line">        q-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        p-&gt;next = q; <span class="comment">// 将 q 接入到 p 后面</span></div><div class="line">        p = q; <span class="comment">// p 后移到q位置</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">打印单链表</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> PrintfLinkList(LinkList *head) &#123;</div><div class="line"></div><div class="line">    LinkList *p = head-&gt;next;</div><div class="line">    <span class="keyword">while</span> (p) &#123;</div><div class="line">        printf(<span class="string">"%c,"</span>,p-&gt;data);</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">销毁单链表</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> DestoryLinkList(LinkList *head) &#123;</div><div class="line"></div><div class="line">    LinkList *p, *q;</div><div class="line"></div><div class="line">    p = head;</div><div class="line">    <span class="keyword">while</span> (p) &#123;</div><div class="line">        q = p-&gt;next;</div><div class="line">        free(p);</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">单链表指定节点数之前插入新的元素</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> InsterLinkList(LinkList *head, <span class="keyword">char</span> a, <span class="keyword">char</span> c) &#123;</div><div class="line"></div><div class="line">    LinkList *p = head;</div><div class="line">    LinkList *q = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (p-&gt;next) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;data == a) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    q = (LinkList *)malloc(<span class="keyword">sizeof</span>(LinkList));</div><div class="line">    q-&gt;data = c;</div><div class="line">    q-&gt;next = p-&gt;next;</div><div class="line">    p-&gt;next = q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">单链表删除元素</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> DeleteLinkList(LinkList *head, <span class="keyword">char</span> a) &#123;</div><div class="line"></div><div class="line">    LinkList *p = head;</div><div class="line">    LinkList *q = p-&gt;next;</div><div class="line">    <span class="keyword">while</span> (q) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (q-&gt;data == a) &#123;</div><div class="line"></div><div class="line">            p-&gt;next = q-&gt;next;</div><div class="line">            free(q);</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        p = q;</div><div class="line">        q = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">获取单链表中某个元素的位置</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">获取单链表中指定位置的元素值</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">求单链表的长度</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">判断单链表是否为空</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">void</span> EmptyLinkList(LinkList *head) &#123;</div><div class="line"></div><div class="line">    LinkList *p = head;</div><div class="line">    <span class="keyword">if</span> (!p-&gt;next) &#123;</div><div class="line">        printf(<span class="string">"LinkList is empty\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        printf(<span class="string">"LinkList not empty\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line">    LinkList *list = CreateLinkList(a, <span class="number">5</span>);</div><div class="line">    PrintfLinkList(list);</div><div class="line">    EmptyLinkList(list);</div><div class="line">    InsterLinkList(list, <span class="string">'c'</span>, <span class="string">'b'</span>);</div><div class="line">    PrintfLinkList(list);</div><div class="line">    EmptyLinkList(list);</div><div class="line">    <span class="comment">//    DestoryLinkList(list);</span></div><div class="line">    <span class="comment">//    PrintfLinkList(list);</span></div><div class="line">    <span class="comment">//    EmptyLinkList(list);</span></div><div class="line">    DeleteLinkList(list, <span class="string">'c'</span>);</div><div class="line">    PrintfLinkList(list);</div><div class="line">    EmptyLinkList(list);</div><div class="line">    DeleteLinkList(list, <span class="string">'f'</span>);</div><div class="line">    PrintfLinkList(list);</div><div class="line">    EmptyLinkList(list);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于单链表的概念，暂时未写，后期有时间更新。暂时忽律细节处理，以最简单的代码理解单链表基本操作！如果喜欢我的文章，可以关注我的GitHub:
    
    </summary>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/"/>
    
      <category term="单链表" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/c-c/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/c-c/"/>
    
      <category term="单链表" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>直播专题</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/09/11/17.9.11_%E7%9B%B4%E6%92%AD%E4%B8%93%E9%A2%98/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/09/11/17.9.11_直播专题/</id>
    <published>2017-09-11T03:14:51.000Z</published>
    <updated>2017-09-11T16:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>[<img src="//upload.jianshu.io/collections/images/523782/258ae8bb4529317c9ddfa67322b4d218.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" alt=""></p>
<hr>
<h2 id="直播协议的选择：RTMP-vs-HLS"><a href="#直播协议的选择：RTMP-vs-HLS" class="headerlink" title="直播协议的选择：RTMP vs. HLS"></a><a href="http://www.jianshu.com/p/4484ac27aa21" target="_blank" rel="external">直播协议的选择：RTMP vs. HLS</a></h2><p>文章转自：直播协议的选择：RTMP vs. HLS 前言 随着直播业务的兴起，越来越多的直播平台开始涌现，这火热的程度好像一个应用不带上直播业务出来都不好意思跟人打招呼。想要…</p>
<hr>
<h2 id="一步步搭建视频直播系统，基于LFLiveKit＋ijkplayer＋rtmp（iOS端）"><a href="#一步步搭建视频直播系统，基于LFLiveKit＋ijkplayer＋rtmp（iOS端）" class="headerlink" title="一步步搭建视频直播系统，基于LFLiveKit＋ijkplayer＋rtmp（iOS端）"></a><a href="http://www.jianshu.com/p/30595a5bff42" target="_blank" rel="external">一步步搭建视频直播系统，基于LFLiveKit＋ijkplayer＋rtmp（iOS端）</a></h2><p>本文主要使用的三个技术： 推流：LFLiveKit 播放：ijkplayer 服务器:nginx+rtmp+ffmpeg 有了这三点技术就可以完成一个简约的直播系统。效果图如…<br><img src="//upload-images.jianshu.io/upload_images/301102-1ad9999f78d7d3c6.png?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt=""></p>
<hr>
<h2 id="iOS-直播开发-开发从底层做起"><a href="#iOS-直播开发-开发从底层做起" class="headerlink" title="iOS-直播开发(开发从底层做起)"></a><a href="http://www.jianshu.com/p/db7b2551538b" target="_blank" rel="external">iOS-直播开发(开发从底层做起)</a></h2><p>一直在忙, 也没写过几次博客! 但一直热衷于直播开发技术, 公司又不是直播方向的, 所以就年前忙里偷闲研究了一下直播开发, 然后翻阅了很多大神的技术博客等, 写了一个简单的D…<br><a href="/p/db7b2551538b"><br> <img src="//upload-images.jianshu.io/upload_images/1981290-b71a56c359c575ce.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="HTTP-Live-Streaming直播-iOS直播-技术分析与实现"><a href="#HTTP-Live-Streaming直播-iOS直播-技术分析与实现" class="headerlink" title="HTTP Live Streaming直播(iOS直播)技术分析与实现"></a><a href="http://www.jianshu.com/p/fae91addab45" target="_blank" rel="external">HTTP Live Streaming直播(iOS直播)技术分析与实现</a></h2><p>作者：HBStream不经意间发现，大半年没写博客了，自觉汗颜。实则2012后半年，家中的事一样接着一样发生，实在是没有时间。快过年了，总算忙里偷闲，把最近的一些技术成果，总…<br><a href="/p/fae91addab45"><br> <img src="//upload-images.jianshu.io/upload_images/678612-4ec5944420d9e3f8.png?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="iOS中集成ijkplayer视频直播框架"><a href="#iOS中集成ijkplayer视频直播框架" class="headerlink" title="iOS中集成ijkplayer视频直播框架"></a><a href="http://www.jianshu.com/p/1f06b27b3ac0" target="_blank" rel="external">iOS中集成ijkplayer视频直播框架</a></h2><p>ijkplayer是一款做视频直播的框架,基于ffmpeg,支持Android和iOS,网上也有很多集成说明,但是个人觉得还是不够详细,在这里详细的讲一下在iOS中如何集成i…<br><a href="/p/1f06b27b3ac0"><img src="//upload-images.jianshu.io/upload_images/1803339-c3b8f8bcae855612.png?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="如何快速的开发一个完整的iOS直播app-原理篇"><a href="#如何快速的开发一个完整的iOS直播app-原理篇" class="headerlink" title="如何快速的开发一个完整的iOS直播app(原理篇)"></a><a href="http://www.jianshu.com/p/bd42bacbe4cc" target="_blank" rel="external">如何快速的开发一个完整的iOS直播app(原理篇)</a></h2><p>目录 【如何快速的开发一个完整的iOS直播app】(原理篇) 【如何快速的开发一个完整的iOS直播app】(播放篇) 【如何快速的开发一个完整的iOS直播app】(采集篇) …<br><a href="/p/bd42bacbe4cc"><img src="//upload-images.jianshu.io/upload_images/304825-17ee0ce99bde2de0.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="iOS视频直播初窥-高仿-lt-喵播APP-gt"><a href="#iOS视频直播初窥-高仿-lt-喵播APP-gt" class="headerlink" title="iOS视频直播初窥:高仿&lt;喵播APP&gt;"></a><a href="http://www.jianshu.com/p/b8db6c142aad" target="_blank" rel="external">iOS视频直播初窥:高仿&lt;喵播APP&gt;</a></h2><p>效果图gif1gif2由于licecap录制的GIF失帧太严重,都模糊掉了,再放两张高清截图png1png2前言今年三月份，斗鱼获腾讯领投的1亿美元融资的消息被各大平台报道转…<br><a href="/p/b8db6c142aad"><br> <img src="//upload-images.jianshu.io/upload_images/1038348-8c2256abd66c7791.png?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="1小时学会：最简单的iOS直播推流（一）介绍"><a href="#1小时学会：最简单的iOS直播推流（一）介绍" class="headerlink" title="1小时学会：最简单的iOS直播推流（一）介绍"></a><a href="http://www.jianshu.com/p/30b82f1e61a9" target="_blank" rel="external">1小时学会：最简单的iOS直播推流（一）介绍</a></h2><p>最简单的iOS 推流代码，视频捕获，软编码(faac，x264)，硬编码（aac，h264），美颜，flv编码，rtmp协议，陆续更新代码解析，你想学的知识这里都有，愿意懂直…</p>
<hr>
<h2 id="做一款仿映客的直播App？看我就够了"><a href="#做一款仿映客的直播App？看我就够了" class="headerlink" title="做一款仿映客的直播App？看我就够了"></a><a href="http://www.jianshu.com/p/5b1341e97757" target="_blank" rel="external">做一款仿映客的直播App？看我就够了</a></h2><p>一、直播现状简介Linkee.101.技术实现层面：技术相对都比较成熟，设备也都支持硬编码。IOS还提供现成的VideoToolBox框架，可以对摄像头和流媒体数据结构进行处…<br><a href="/p/5b1341e97757"><img src="//upload-images.jianshu.io/upload_images/2004362-acd9765f38aa69b7.png?imageMogr2/auto-orient/strip|imageView2/1/w/150/h/120" alt="">
</a></p>
<hr>
<h2 id="快速集成iOS基于RTMP的视频推流"><a href="#快速集成iOS基于RTMP的视频推流" class="headerlink" title="快速集成iOS基于RTMP的视频推流"></a><a href="http://www.jianshu.com/p/8ea016b2720e" target="_blank" rel="external">快速集成iOS基于RTMP的视频推流</a></h2><p>效果图iTools有点卡,但是推到服务器倒是很快的.推流前言这篇blog是iOS视频直播初窥:&amp;lt;喵播APP&amp;gt;的一个补充.因为之前传到github上的项目中没有集成…</p>
<h3 id="更多直播相关文章请关注我的简书专题iOS-直播相关"><a href="#更多直播相关文章请关注我的简书专题iOS-直播相关" class="headerlink" title="更多直播相关文章请关注我的简书专题iOS - 直播相关"></a>更多直播相关文章请关注我的简书专题<a href="http://www.jianshu.com/c/637984ef967a" target="_blank" rel="external">iOS - 直播相关</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[&lt;img src=&quot;//upload.jianshu.io/collections/images/523782/258ae8bb4529317c9ddfa67322b4d218.jpg?imageMogr2/auto-orient/strip|imageView2/1/w
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="直播" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/%E7%9B%B4%E6%92%AD/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="直播" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>[转]教你搭建App内测下载平台</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/08/10/17.08.10_%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAApp%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/08/10/17.08.10_教你搭建App内测下载平台/</id>
    <published>2017-08-10T03:22:13.000Z</published>
    <updated>2017-09-10T13:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自简书作者:<a href="http://www.jianshu.com/p/48b38a2d0bbb" target="_blank" rel="external">zhao0</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>App开发测试过程中，我们会把安装包传到各种第三方的内测分发平台方便下载。这些平台或多或少有这样那样的限制，比如下载量啊、付费啊、不能方便找到历史版本啊。还有一方面，我们经常会打Debug版本的包方便调试，又不希望Debug包流传到外部去，这样就很有必要自己搭一个下载平台，于是就有了这个项目(<a href="https://github.com/zhao0/ipapk-server">github地址</a>)。</p>
<div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/2057602-ba63d6a985727af3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><div class="image-caption"></div><br></div>

<h2 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h2><h5 id="怎么下载"><a href="#怎么下载" class="headerlink" title="怎么下载"></a>怎么下载</h5><p>先说安卓，apk文件通过最简单的http/ftp下载就可以安装了，略过。<br>iOS稍微复杂一点，需要两步才能完成。<br>第一，下载链接必须是这样的格式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">itms-services://?action=download-manifest&amp;amp;url=一个plist文件的地址</div></pre></td></tr></table></figure>
<p>第二，plist内容如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;</div><div class="line">&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;</div><div class="line">&amp;lt;plist version="1.0"&amp;gt;</div><div class="line">&amp;lt;dict&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;items&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;array&amp;gt;</div><div class="line">&amp;lt;dict&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;assets&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;array&amp;gt;</div><div class="line">&amp;lt;dict&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;software-package&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;url&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;ipa文件的地址&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;/dict&amp;gt;</div><div class="line">&amp;lt;/array&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;metadata&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;dict&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;bundle-identifier&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;bundleID&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;bundle-version&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;software&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;key&amp;gt;title&amp;lt;/key&amp;gt;</div><div class="line">&amp;lt;string&amp;gt;AppTitle&amp;lt;/string&amp;gt;</div><div class="line">&amp;lt;/dict&amp;gt;</div><div class="line">&amp;lt;/dict&amp;gt;</div><div class="line">&amp;lt;/array&amp;gt;</div><div class="line">&amp;lt;/dict&amp;gt;</div><div class="line">&amp;lt;/plist&amp;gt;</div></pre></td></tr></table></figure></p>
<p>其中，最重要的就是ipa文件的地址，要求必须是https协议，那就需要SSL证书，幸运的是我们可以信任自签名的证书。下载的过程就是这样，当然我们希望这个链接和plist的生成是自动完成的。</p>
<h5 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h5><p>参考<a href="http://www.cnblogs.com/lihuang/articles/4205540.html" target="_blank" rel="external">如何创建一个自签名的SSL证书(X509)</a></p>
<h5 id="包信息提取"><a href="#包信息提取" class="headerlink" title="包信息提取"></a>包信息提取</h5><p>单单只能下载还不够，我们希望看到更多的信息：App名字、版本号、build号、更新时间、图标等。这些信息虽然可以留给上传者在上传的时候一并带上，但是作为有追求的程序员，把方便留给别人的最基本的，因此我们要从ipa/apk中提取这些信息。<br>无论是ipa还是apk，本质都是zip压缩文件。<br>对于iOS的ipa，包信息都放在Info.plist中，主要有CFBundleVersion、CFBundleIdentifier、CFBundleShortVersionString、CFBundleName等。图标文件的名字也是固定的，只要解压就可以得到。不过，苹果对png图片进行了了自定义的<a href="http://pmt.sourceforge.net/pngcrush/" target="_blank" rel="external">pngcrush</a>压缩，有压缩自然就有还原工具<a href="http://www.jongware.com/pngdefry.html" target="_blank" rel="external">pngdefry</a>。<br>对于Android的apk，解压后还能看到AndroidManifest.xml，但是里面的内容经过编码显示为乱码，不方便查看，需要借助开发工具aapt(Android Asset Packaging Tool)，方法如下<br><code>aapt dump badging apkPath</code><br>输出的文本格式如下，不是标准的歌声，需要手动转换一下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package: name='com.jianshu.haruki' versionCode='16070101' versionName='1.11.2'</div><div class="line">sdkVersion:'14'</div><div class="line">targetSdkVersion:'22'</div><div class="line">...</div><div class="line">application: label='简书' icon='res/drawable-hdpi-v4/icon_jianshu_new.png'</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="找轮子"><a href="#找轮子" class="headerlink" title="找轮子"></a>找轮子</h2><p>程序员有一个习惯，需要某个东西的时候会先一番搜索，直接用别人写好的，用着用着发现别人写的东西有这样那样的不足，然后撸起袖子自己造一个。这次也不例外，我在github上找到了一个<a href="https://github.com/bumaociyuan/ios-ipa-server">ios-ipa-server</a>，它的特点是简单，ipa文件存储在一个目录下，没有数据库，包信息只有上传时间(其实就是文件更新时间)，不能对app归类，只靠文件名区别，不支持上传，如下图：</p>
<div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/2057602-31224eefc821b5a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><div class="image-caption"></div><br></div>

<p>浏览器访问下载页面时，后端实时解析包信息、解压icon图片，这样做效率是非常低的。<br>这么多不足我们就有了造轮子的理由了。</p>
<h2 id="自己造一个"><a href="#自己造一个" class="headerlink" title="自己造一个"></a>自己造一个</h2><p>既然<a href="https://github.com/bumaociyuan/ios-ipa-server">ios-ipa-server</a>是基于node-express写的，正好我<strong>没写过</strong>nodejs，那就在它的基础上继续写吧，借机学(zhuang)习(bi)一下。<br>整个项目的结构是这样的，提供四个API：包上传、获取所有App最新版本、获取某个App的所有版本、动态生成plist文件，数据存储使用sqlite3。</p>
<h5 id="包上传"><a href="#包上传" class="headerlink" title="包上传"></a>包上传</h5><p>接口设计如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">path:</div><div class="line">POST /upload</div><div class="line"></div><div class="line">param: </div><div class="line">package:安装包文件</div><div class="line"></div><div class="line">response:</div><div class="line">&#123;</div><div class="line">id: 6,</div><div class="line">guid: "46269d71-9fda-76fc-3442-a118d6b08bf1",</div><div class="line">bundleID: "com.jianshu.Hugo",</div><div class="line">version: "2.11.4",</div><div class="line">build: "1608051045",</div><div class="line">icon: "https://10.20.30.233:1234/icon/46269d71-9fda-76fc-3442-a118d6b08bf1.png",</div><div class="line">name: "Hugo",</div><div class="line">uploadTime: "2016-12-01 20:50:05",</div><div class="line">platform: "ios",</div><div class="line">url: "itms-services://?action=download-manifest&amp;amp;url=https://10.20.30.233:1234/plist/46269d71-9fda-76fc-3442-a118d6b08bf1"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后端需要拿到安装包，提取出包信息和png图标图片，然后插入到数据库中，最后存储安装包文件和png图片，这也是最关键、最复杂的一个API。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">app.post('/upload', function(req, res) &#123;</div><div class="line">var form = new multiparty.Form();</div><div class="line">form.parse(req, function(err, fields, files) &#123;</div><div class="line">var obj = files.package[0];</div><div class="line">var tmp_path = obj.path;</div><div class="line">parseAppAndInsertToDb(tmp_path, info =&amp;gt; &#123;</div><div class="line">storeApp(tmp_path, info["guid"], error =&amp;gt; &#123;</div><div class="line">if (error) &#123;</div><div class="line">errorHandler(error,res)</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">console.log(info)</div><div class="line">res.send(info)</div><div class="line">&#125;, error =&amp;gt; &#123;</div><div class="line">errorHandler(error,res)</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接收表单信息用到了multiparty模块，<code>parseAppAndInsertToDb</code>内部完成了包信息的提取和存储，<code>storeApp</code>存储包文件。<br><code>parseAppAndInsertToDb</code>的实现如下，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function parseAppAndInsertToDb(filePath, callback, errorCallback) &#123;</div><div class="line">var guid = Guid.create().toString();</div><div class="line">var parse, extract</div><div class="line">if (path.extname(filePath) === ".ipa") &#123;</div><div class="line">parse = parseIpa</div><div class="line">extract = extractIpaIcon</div><div class="line">&#125; else if (path.extname(filePath) === ".apk") &#123;</div><div class="line">parse = parseApk</div><div class="line">extract = extractApkIcon</div><div class="line">&#125;</div><div class="line">Promise.all([parse(filePath),extract(filePath,guid)]).then(values =&amp;gt; &#123;</div><div class="line">var info = values[0]</div><div class="line">info["guid"] = guid</div><div class="line">excuteDB("INSERT INTO info (guid, platform, build, bundleID, version, name) VALUES (?, ?, ?, ?, ?, ?);",</div><div class="line">[info["guid"], info["platform"], info["build"], info["bundleID"], info["version"], info["name"]],function(error)&#123;</div><div class="line">if (!error)&#123;</div><div class="line">callback(info)</div><div class="line">&#125; else &#123;</div><div class="line">errorCallback(error)</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;, reason =&amp;gt; &#123;</div><div class="line">errorCallback(reason)</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据文件后缀名判断安装包类型，因为ipa和apk的处理逻辑不一样，所以分别对应两个方法，包信息的提取和icon提取可以同时进行，所以这里用了<code>Promise.all</code>。<code>parseIpa</code>和<code>parseApk</code>就是包信息的提取。<code>extractApkIcon</code>和<code>extractIpaIcon</code>则是icon的提取，<code>extractIpaIcon</code>多了一步还原png图片的处理。<br><code>parseIpa</code>用到了<code>ipa-extract-info</code>模块，<code>parseApk</code>则使用了<code>apk-parser3</code>，代码都非常简单。详细可进入<a href="https://github.com/zhao0/ipapk-server">github地址</a>。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>其他三个API则比较简单了，无非就是根据参数取数据，不再赘述。</p>
<h2 id="集成和使用"><a href="#集成和使用" class="headerlink" title="集成和使用"></a>集成和使用</h2><p>安装步骤非常简单，首先需要安装node，有了node之后只要一行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g ipapk-server</div></pre></td></tr></table></figure>
<p>安装完成之后输入命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipapk-server</div></pre></td></tr></table></figure>
<p>手机浏览器访问<a href="https://ip:port" target="_blank" rel="external">https://ip:port</a> 即可打开下载页面</p>
<div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/2057602-778cdf6e0a5be67b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><div class="image-caption"></div><br></div><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/2057602-ba63d6a985727af3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><div class="image-caption"></div><br></div>

<p>App的信息获取都设计成了API，提供给开发者更灵活的接入方式，可以做web页面，也可以做成App，我的好朋友mask(<a href="http://www.jianshu.com/users/98ca2b6009b9" target="_blank" rel="external">人格分裂术</a>)贡献了不少工作，完成默认的web下载页面。<br>更详细的内容请参考<a href="https://github.com/zhao0/ipapk-server">github</a>。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>简书作为一个优质原创内容社区，拥有大量优质原创内容，提供了极佳的阅读和书写体验，吸引了大量文字爱好者和程序员。<a href="http://www.jianshu.com/collection/5e84f0a4fbb0" target="_blank" rel="external">简书技术团队</a>在这里分享技术心得体会，是希望抛砖引玉，吸引更多的程序员大神来简书记录、分享、交流自己的心得体会。<a href="http://www.jianshu.com/collection/5e84f0a4fbb0" target="_blank" rel="external">这个专题</a>以后会不定期更新简书技术团队的文章，包括Android、iOS、前端、后端等等，欢迎大家关注。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自简书作者:&lt;a href=&quot;http://www.jianshu.com/p/48b38a2d0bbb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;zhao0&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="App内测下载平台" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/App%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="移动开发" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="App内测下载平台" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/App%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>[转]简单监测iOS卡顿的demo</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/06/21/17.06.21_%E7%AE%80%E5%8D%95%E7%9B%91%E6%B5%8BiOS%E5%8D%A1%E9%A1%BF%E7%9A%84demo/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/06/21/17.06.21_简单监测iOS卡顿的demo/</id>
    <published>2017-06-21T10:13:24.000Z</published>
    <updated>2017-09-10T13:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自简书作者:<a href="http://www.jianshu.com/p/71cfbcb15842" target="_blank" rel="external">game3108</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的demo代码也会更新到<a href="https://github.com/game3108/RunloopMonitorDemo">github</a>上。</p>
<p>做这个demo思路来源于微信team的：<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207890859&amp;idx=1&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;scene=4#wechat_redirect" target="_blank" rel="external">微信iOS卡顿监控系统</a>。<br>主要思路:通过监测Runloop的kCFRunLoopAfterWaiting，用一个子线程去检查，一次循环是否时间太长。<br>其中主要涉及到了runloop的原理。关于整个原理：<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>讲解的比较仔细。<br>以下就是runloop大概的运行方式：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></div><div class="line"><span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line"></div><div class="line"><span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</div><div class="line"><span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"></div><div class="line"><span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</div><div class="line"></div><div class="line"><span class="comment">/// 5. GCD处理main block</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"></div><div class="line"><span class="comment">/// 6. 通知Observers，即将进入休眠</span></div><div class="line"><span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</div><div class="line"></div><div class="line"><span class="comment">/// 7. sleep to wait msg.</span></div><div class="line">mach_msg() -&amp;gt; mach_msg_trap();</div><div class="line"></div><div class="line"><span class="comment">/// 8. 通知Observers，线程被唤醒</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"><span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</div><div class="line"></div><div class="line"><span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></div><div class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</div><div class="line"></div><div class="line"><span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span> (...);</div><div class="line"></div><div class="line"><span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></div><div class="line"><span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中UI主要集中在<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</code><br>和<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</code>之前。<br>获取<code>kCFRunLoopBeforeSources</code>到<code>kCFRunLoopBeforeWaiting</code>再到<code>kCFRunLoopAfterWaiting</code>的状态就可以知道是否有卡顿的情况。</p>
<h2 id="NSTimer的实现"><a href="#NSTimer的实现" class="headerlink" title="NSTimer的实现"></a>NSTimer的实现</h2><p>具体代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="comment">//  MonitorController.h</span></div><div class="line">    <span class="comment">//  RunloopMonitorDemo</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Created by game3108 on 16/4/13.</span></div><div class="line">    <span class="comment">//  Copyright © 2016年 game3108. All rights reserved.</span></div><div class="line">    <span class="comment">//</span></div><div class="line"></div><div class="line">    <span class="meta">#import &amp;lt;Foundation/Foundation.h&amp;gt;</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">@interface</span> <span class="title">MonitorController</span> : <span class="title">NSObject</span></span></div><div class="line">    + (<span class="keyword">instancetype</span>) sharedInstance;</div><div class="line">    - (<span class="keyword">void</span>) startMonitor;</div><div class="line">    - (<span class="keyword">void</span>) endMonitor;</div><div class="line">    - (<span class="keyword">void</span>) printLogTrace;</div><div class="line">    <span class="keyword">@end</span></div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line">``` objectivec</div><div class="line"></div><div class="line">    <span class="comment">//  MonitorController.m</span></div><div class="line">    <span class="comment">//  RunloopMonitorDemo</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Created by game3108 on 16/4/13.</span></div><div class="line">    <span class="comment">//  Copyright © 2016年 game3108. All rights reserved.</span></div><div class="line">    <span class="comment">//</span></div><div class="line"></div><div class="line">    <span class="meta">#import <span class="meta-string">"MonitorController.h"</span></span></div><div class="line">    <span class="meta">#include &amp;lt;libkern/OSAtomic.h&amp;gt;</span></div><div class="line">    <span class="meta">#include &amp;lt;execinfo.h&amp;gt;</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">@interface</span> <span class="title">MonitorController</span>()</span>&#123;</div><div class="line">    <span class="built_in">CFRunLoopObserverRef</span> _observer;</div><div class="line">    <span class="keyword">double</span> _lastRecordTime;</div><div class="line">    <span class="built_in">NSMutableArray</span> *_backtrace;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@end</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">MonitorController</span></span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">double</span> _waitStartTime;</div><div class="line"></div><div class="line">    + (<span class="keyword">instancetype</span>) sharedInstance&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;amp;once, ^&#123;</div><div class="line">    sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> sharedInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>) startMonitor&#123;</div><div class="line">    [<span class="keyword">self</span> addMainThreadObserver];</div><div class="line">    [<span class="keyword">self</span> addSecondaryThreadAndObserver];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>) endMonitor&#123;</div><div class="line">    <span class="keyword">if</span> (!_observer) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</div><div class="line">    <span class="built_in">CFRelease</span>(_observer);</div><div class="line">    _observer = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">#pragma mark printLogTrace</span></div><div class="line">    - (<span class="keyword">void</span>)printLogTrace&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"====================堆栈\n %@ \n"</span>,_backtrace);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">#pragma mark addMainThreadObserver</span></div><div class="line">    - (<span class="keyword">void</span>) addMainThreadObserver &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">//建立自动释放池</span></div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    <span class="comment">//获得当前thread的Run loop</span></div><div class="line">    <span class="built_in">NSRunLoop</span> *myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line"></div><div class="line">    <span class="comment">//设置Run loop observer的运行环境</span></div><div class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</div><div class="line"></div><div class="line">    <span class="comment">//创建Run loop observer对象</span></div><div class="line">    <span class="comment">//第一个参数用于分配observer对象的内存</span></div><div class="line">    <span class="comment">//第二个参数用以设置observer所要关注的事件，详见回调函数myRunLoopObserver中注释</span></div><div class="line">    <span class="comment">//第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行</span></div><div class="line">    <span class="comment">//第四个参数用于设置该observer的优先级</span></div><div class="line">    <span class="comment">//第五个参数用于设置该observer的回调函数</span></div><div class="line">    <span class="comment">//第六个参数用于设置该observer的运行环境</span></div><div class="line">    _observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;amp;myRunLoopObserver, &amp;amp;context);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_observer) &#123;</div><div class="line">    <span class="comment">//将Cocoa的NSRunLoop类型转换成Core Foundation的CFRunLoopRef类型</span></div><div class="line">    <span class="built_in">CFRunLoopRef</span> cfRunLoop = [myRunLoop getCFRunLoop];</div><div class="line">    <span class="comment">//将新建的observer加入到当前thread的run loop</span></div><div class="line">    <span class="built_in">CFRunLoopAddObserver</span>(cfRunLoop, _observer, kCFRunLoopDefaultMode);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> myRunLoopObserver(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</div><div class="line">    <span class="keyword">switch</span> (activity) &#123;</div><div class="line">    <span class="comment">//The entrance of the run loop, before entering the event processing loop.</span></div><div class="line">    <span class="comment">//This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopEntry:</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop entry"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//Inside the event processing loop before any timers are processed</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopBeforeTimers:</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop before timers"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//Inside the event processing loop before any sources are processed</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopBeforeSources:</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop before sources"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="comment">//Inside the event processing loop before the run loop sleeps, waiting for a source or timer to fire.</span></div><div class="line">    <span class="comment">//This activity does not occur if CFRunLoopRunInMode is called with a timeout of 0 seconds.</span></div><div class="line">    <span class="comment">//It also does not occur in a particular iteration of the event processing loop if a version 0 source fires</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopBeforeWaiting:&#123;</div><div class="line">    _waitStartTime = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop before waiting"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//Inside the event processing loop after the run loop wakes up, but before processing the event that woke it up.</span></div><div class="line">    <span class="comment">//This activity occurs only if the run loop did in fact go to sleep during the current loop</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopAfterWaiting:&#123;</div><div class="line">    _waitStartTime = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop after waiting"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//The exit of the run loop, after exiting the event processing loop.</span></div><div class="line">    <span class="comment">//This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode</span></div><div class="line">    <span class="keyword">case</span> kCFRunLoopExit:</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"run loop exit"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    A combination of all the preceding stages</div><div class="line">    case kCFRunLoopAllActivities:</div><div class="line">    break;</div><div class="line">    */</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">#pragma mark addSecondaryThreadAndObserver</span></div><div class="line">    - (<span class="keyword">void</span>) addSecondaryThreadAndObserver&#123;</div><div class="line">    <span class="built_in">NSThread</span> *thread = [<span class="keyword">self</span> secondaryThread];</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(addSecondaryTimer) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="built_in">NSThread</span> *)secondaryThread &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_secondaryThread = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;amp;oncePredicate, ^&#123;</div><div class="line">    _secondaryThread =</div><div class="line">    [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">    selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:)</div><div class="line">    object:<span class="literal">nil</span>];</div><div class="line">    [_secondaryThread start];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _secondaryThread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"monitorControllerThread"</span>];</div><div class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">    [runLoop run];</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>) addSecondaryTimer&#123;</div><div class="line">    <span class="built_in">NSTimer</span> *myTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer&#123;</div><div class="line">    <span class="keyword">if</span> ( _waitStartTime &amp;lt; <span class="number">1</span> )&#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> currentTime = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="keyword">double</span> timeDiff = currentTime - _waitStartTime;</div><div class="line">    <span class="keyword">if</span> (timeDiff &amp;gt; <span class="number">2.0</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (_lastRecordTime - _waitStartTime &amp;lt; <span class="number">0.001</span> &amp;amp;&amp;amp; _lastRecordTime != <span class="number">0</span>)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"last time no :%f %f"</span>,timeDiff, _waitStartTime);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> logStack];</div><div class="line">    _lastRecordTime = _waitStartTime;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (<span class="keyword">void</span>)logStack&#123;</div><div class="line">    <span class="keyword">void</span>* callstack[<span class="number">128</span>];</div><div class="line">    <span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</div><div class="line">    <span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    _backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &amp;lt; frames ; i++ )&#123;</div><div class="line">    [_backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</div><div class="line">    &#125;</div><div class="line">    free(strs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>主要内容是首先在主线程注册了runloop observer的回调<code>myRunLoopObserver</code><br>每次小循环都会记录一下<code>kCFRunLoopAfterWaiting</code>的时间<code>_waitStartTime</code>，并且在<code>kCFRunLoopBeforeWaiting</code>制空。</p>
<p>另外开了一个子线程并开启他的runloop（模仿了AFNetworking的方式），并加上一个timer每隔1秒去进行监测。</p>
<p>如果当前时长与<code>_waitStartTime</code>差距大于2秒，则认为有卡顿情况，并记录了当前堆栈信息。</p>
<p>PS:整个demo写的比较简单，最后获取堆栈也仅获取了当前线程的堆栈信息(<code>[NSThread callStackSymbols]</code>有同样效果)，也在寻找获取所有线程堆栈的方法，欢迎指点一下。</p>
<hr>
<h4 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h4><p>了解到 plcrashreporter (<a href="https://github.com/plausiblelabs/plcrashreporter">github地址</a>) 可以做到获取所有线程堆栈。</p>
<hr>
<h4 id="更新2"><a href="#更新2" class="headerlink" title="更新2:"></a>更新2:</h4><p>这篇文章也介绍了监测卡顿的方法：<a href="http://www.starming.com/index.php?v=index&amp;view=91" target="_blank" rel="external">检测iOS的APP性能的一些方法</a><br>通过Dispatch Semaphore保证同步这里记录一下。</p>
<p>写一个Semaphore版本的代码，也放在<a href="https://github.com/game3108/RunloopMonitorDemo">github</a>上：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//  SeMonitorController.h</span></div><div class="line"><span class="comment">//  RunloopMonitorDemo</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by game3108 on 16/4/14.</span></div><div class="line"><span class="comment">//  Copyright © 2016年 game3108. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import &amp;lt;Foundation/Foundation.h&amp;gt;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SeMonitorController</span> : <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>) sharedInstance;</div><div class="line">- (<span class="keyword">void</span>) startMonitor;</div><div class="line">- (<span class="keyword">void</span>) endMonitor;</div><div class="line">- (<span class="keyword">void</span>) printLogTrace;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//  SeMonitorController.m</span></div><div class="line"><span class="comment">//  RunloopMonitorDemo</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by game3108 on 16/4/14.</span></div><div class="line"><span class="comment">//  Copyright © 2016年 game3108. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"SeMonitorController.h"</span></span></div><div class="line"><span class="meta">#import &amp;lt;libkern/OSAtomic.h&amp;gt;</span></div><div class="line"><span class="meta">#import &amp;lt;execinfo.h&amp;gt;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SeMonitorController</span>()</span>&#123;</div><div class="line"><span class="built_in">CFRunLoopObserverRef</span> _observer;</div><div class="line">dispatch_semaphore_t _semaphore;</div><div class="line"><span class="built_in">CFRunLoopActivity</span> _activity;</div><div class="line"><span class="built_in">NSInteger</span> _countTime;</div><div class="line"><span class="built_in">NSMutableArray</span> *_backtrace;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SeMonitorController</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>) sharedInstance&#123;</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> sharedInstance;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;amp;once, ^&#123;</div><div class="line">sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;);</div><div class="line"><span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) startMonitor&#123;</div><div class="line">[<span class="keyword">self</span> registerObserver];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) endMonitor&#123;</div><div class="line"><span class="keyword">if</span> (!_observer) &#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</div><div class="line"><span class="built_in">CFRelease</span>(_observer);</div><div class="line">_observer = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) printLogTrace&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"====================堆栈\n %@ \n"</span>,_backtrace);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info)</div><div class="line">&#123;</div><div class="line">SeMonitorController *instrance = [SeMonitorController sharedInstance];</div><div class="line">instrance-&amp;gt;_activity = activity;</div><div class="line"><span class="comment">// 发送信号</span></div><div class="line">dispatch_semaphore_t semaphore = instrance-&amp;gt;_semaphore;</div><div class="line">dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)registerObserver</div><div class="line">&#123;</div><div class="line"><span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</div><div class="line">_observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</div><div class="line">kCFRunLoopAllActivities,</div><div class="line"><span class="literal">YES</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;amp;runLoopObserverCallBack,</div><div class="line">&amp;amp;context);</div><div class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</div><div class="line"></div><div class="line"><span class="comment">// 创建信号</span></div><div class="line">_semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 在子线程监控时长</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line"><span class="keyword">while</span> (<span class="literal">YES</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></div><div class="line"><span class="keyword">long</span> st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span>*<span class="built_in">NSEC_PER_MSEC</span>));</div><div class="line"><span class="keyword">if</span> (st != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (_activity==kCFRunLoopBeforeSources || _activity==kCFRunLoopAfterWaiting)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (++_countTime &amp;lt; <span class="number">5</span>)</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">[<span class="keyword">self</span> logStack];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"something lag"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">_countTime = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)logStack&#123;</div><div class="line"><span class="keyword">void</span>* callstack[<span class="number">128</span>];</div><div class="line"><span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</div><div class="line"><span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line">_backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &amp;lt; frames ; i++ )&#123;</div><div class="line">[_backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</div><div class="line">&#125;</div><div class="line">free(strs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>用Dispatch Semaphore简化了代码复杂度，更加简洁。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/game3108/article/details/51147946" target="_blank" rel="external">本文csdn地址</a><br>1.<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207890859&amp;idx=1&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;scene=4#wechat_redirect" target="_blank" rel="external">微信iOS卡顿监控系统</a><br>2.<a href="http://blog.csdn.net/lingedeng/article/details/6870692" target="_blank" rel="external"> </a><a href="http://blog.csdn.net/lingedeng/article/details/6870692" target="_blank" rel="external">iphone——使用run loop对象</a><br>3.<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a><br>4.<a href="http://www.starming.com/index.php?v=index&amp;view=91" target="_blank" rel="external">检测iOS的APP性能的一些方法</a><br>5.<a href="http://www.tanhao.me/code/151113.html/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">iOS实时卡顿监控</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自简书作者:&lt;a href=&quot;http://www.jianshu.com/p/71cfbcb15842&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;game3108&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;h
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="性能优化" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="移动开发" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking3.0 如何取消网络请求</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/04/10/17.4.10_AFNetworking3.0%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E5%8D%95%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/04/10/17.4.10_AFNetworking3.0如何取消单个网络请求/</id>
    <published>2017-04-10T08:44:53.000Z</published>
    <updated>2017-09-11T15:10:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇主要介绍AFNetworking3.0 如何取消网络请求，直接上代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:@http];</div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [manager GET:URL.absoluteString parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line"></div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//取消单个请求</span></div><div class="line"></div><div class="line">[task cancel];</div><div class="line"></div><div class="line"><span class="comment">//取消当前所有</span></div><div class="line"></div><div class="line">[manager.operationQueue cancelAllOperations];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇主要介绍AFNetworking3.0 如何取消网络请求，直接上代码：&lt;/p&gt;
&lt;figure class=&quot;highlight obj
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/AFNetworking/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/AFNetworking/"/>
    
      <category term="取消网络请求" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8F%96%E6%B6%88%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>[转]掌握iOS多线程攻略</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/03/05/17.3.5_%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%BB%E7%95%A5/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/03/05/17.3.5_全面掌握iOS多线程攻略/</id>
    <published>2017-03-05T02:44:10.000Z</published>
    <updated>2017-09-11T15:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://mobile.51cto.com/iphone-403490.htm" target="_blank" rel="external">http://mobile.51cto.com/iphone-403490.htm</a></p>
<p><img src="http://s9.51cto.com/wyfs01/M00/10/64/wKioOVHm1uDBoy8BAAE-0JFe7qA823.jpg" alt="专题：全面掌握iOS多线程攻略"></p>
<div class="lead"><br><br>###<br><br>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。<br><br>### 头条推荐<br><br>#### <a href="http://mobile.51cto.com/iphone-386596.htm" target="_blank" rel="external">iOS中多线程原理与runloop介绍</a><br><br>iPhone中的线程应用并不是无节制的，官方给出的资料显示iPhone OS下的主线程的堆栈大小是1M，第二个线程开始都是512KB。并且该值不能通过编译器开关或线程API函数来更改。只有主线程有直接修改UI的能力。……<a href="http://mobile.51cto.com/iphone-386596.htm" target="_blank" rel="external">&gt;&gt;详细</a><br><br>#### <a href="http://developer.51cto.com/art/201305/393568.htm" target="_blank" rel="external">Go语言1.1版发布</a><br><br>“很高兴宣布 Go 语言 1.1 版的发布。在去年3月，我们发布了 1.0 版。此后我们发布了3个小版本更新，这些都只是修复了严重问题，所以各位到现在用的都是 Go 1.0.3 版。<br><br>和 1.0 版相比，Go 1.1 包含了许多改进。最显著的改进是和性能相关。我们优化了编译器和链接器、垃圾回收器、goroutine 调度、映射实现和部分标准库。在 Go 1.1 之下，你的Go代码应该会明显快多了。还有Go语言本身一些细微变化，其中两点这里要摘出来说说：① return 的变化将带来更为简洁和正确的程序，② 引入了方法值（method values）。并行编程在这更为安全……<a href="http://developer.51cto.com/art/201305/393568.htm" target="_blank" rel="external">&gt;&gt;详细</a><br><a href="http://mobile.51cto.com/iphone-401939.htm" target="_blank" rel="external"><img src="http://s7.51cto.com/wyfs01/M00/10/64/wKioOVHm4ofA5rrWAAEnv_KhxSQ852.jpg" alt=""></a><div class="imgrt"><a href="http://mobile.51cto.com/iphone-401939.htm" target="_blank" rel="external"><span>兄弟专题：iOS人机交互指南之UI设计基础</span></a></div></div>

<h3 id="1-nbsp-iOS多线程编程知多少"><a href="#1-nbsp-iOS多线程编程知多少" class="headerlink" title="1&nbsp;iOS多线程编程知多少"></a><span>1&nbsp;<a href="http://mobile.51cto.com/iphone-402967.htm" target="_blank" rel="external">iOS多线程编程知多少</a></span></h3><p>在iOS的世界里有两种实现多线程的方式：</p>
<p><a href="http://s5.51cto.com/wyfs01/M01/10/64/wKioOVHm5i-SLYRSAAb_0wIZIoE958.jpg" target="_blank" rel="external"><img src="http://s5.51cto.com/wyfs01/M01/10/64/wKioOVHm5i-SLYRSAAb_0wIZIoE958.jpg" alt=""></a></p>
<p>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。</p>
<p><strong>第一种：GCD</strong></p>
<p><a href="http://mobile.51cto.com/iphone-402967.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="2-nbsp-GCD使用攻略"><a href="#2-nbsp-GCD使用攻略" class="headerlink" title="2&nbsp;GCD使用攻略"></a><span>2&nbsp;<a href="http://mobile.51cto.com/iphone-402964.htm" target="_blank" rel="external">GCD使用攻略</a></span></h3><p><a href="http://s9.51cto.com/wyfs01/M00/10/64/wKioOVHm5s_yHEMTAAdxHWQ_1sk269.jpg" target="_blank" rel="external"><img src="http://s9.51cto.com/wyfs01/M00/10/64/wKioOVHm5s_yHEMTAAdxHWQ_1sk269.jpg" alt=""></a></p>
<h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X  10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue,  NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</p>
<p>&nbsp;</p>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>让我们来看一个编程场景。我们要在iphone上做一个下载网页的功能，该功能非常简单，就是在iphone上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。</p>
<p><a href="http://mobile.51cto.com/iphone-402964.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="3-nbsp-GCD介绍-一-基本概念和Dispatch-Queue"><a href="#3-nbsp-GCD介绍-一-基本概念和Dispatch-Queue" class="headerlink" title="3&nbsp;GCD介绍(一):基本概念和Dispatch Queue"></a><span>3&nbsp;<a href="http://mobile.51cto.com/iphone-402981.htm" target="_blank" rel="external">GCD介绍(一):基本概念和Dispatch Queue</a></span></h3><p><a href="http://s5.51cto.com/wyfs01/M01/10/63/wKioJlHm58ngXF3oAAas23HcB6s926.png" target="_blank" rel="external"><img src="http://s5.51cto.com/wyfs01/M01/10/63/wKioJlHm58ngXF3oAAas23HcB6s926.png" alt=""></a></p>
<p><strong>什么是GCD？</strong></p>
<p>Grand Central  Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>
<p>除了代码的平行执行能力，GCD还提供高度集成的事件控制系统。可以设置句柄来响应文件描述符、mach ports（Mach port&nbsp;用于  OS X上的进程间通讯）、进程、计时器、信号、用户生成事件。这些句柄通过GCD来并发执行。</p>
<p><a href="http://mobile.51cto.com/iphone-402981.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="4-nbsp-GCD介绍-二-多核心的性能"><a href="#4-nbsp-GCD介绍-二-多核心的性能" class="headerlink" title="4&nbsp;GCD介绍(二):多核心的性能"></a><span>4&nbsp;<a href="http://mobile.51cto.com/iphone-402991.htm" target="_blank" rel="external">GCD介绍(二):多核心的性能</a></span></h3><p><a href="http://s1.51cto.com/wyfs01/M01/10/63/wKioJlHm6BDTgZDTAAa5o4UiX6k728.jpg" target="_blank" rel="external"><img src="http://s1.51cto.com/wyfs01/M01/10/63/wKioJlHm6BDTgZDTAAa5o4UiX6k728.jpg" alt=""></a></p>
<p><strong>概念</strong></p>
<p>为了在单一进程中充分发挥多核的优势，我们有必要使用多线程技术（我们没必要去提多进程，这玩意儿和GCD没关系）。在低层，GCD全局dispatch  queue仅仅是工作线程池的抽象。这些队列中的Block一旦可用，就会被dispatch到工作线程中。提交至用户队列的Block最终也会通过全局队列进入相同的工作线程池（除非你的用户队列的目标是主线程，但是为了提高运行速度，我们绝不会这么干）。</p>
<p>有两种途径来通过GCD&ldquo;榨取&rdquo;多核心系统的性能：将单一任务或者一组相关任务并发至全局队列中运算；将多个不相关的任务或者关联不紧密的任务并发至用户队列中运算；</p>
<p><a href="http://mobile.51cto.com/iphone-402991.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="5-nbsp-GCD介绍-三-Dispatch-Sources"><a href="#5-nbsp-GCD介绍-三-Dispatch-Sources" class="headerlink" title="5&nbsp;GCD介绍(三):Dispatch Sources"></a><span>5&nbsp;<a href="http://mobile.51cto.com/iphone-403003.htm" target="_blank" rel="external">GCD介绍(三):Dispatch Sources</a></span></h3><p><a href="http://s1.51cto.com/wyfs01/M00/10/64/wKioOVHm6RLA7lNgAAYTkpqIhHI443.png" target="_blank" rel="external"><img src="http://s1.51cto.com/wyfs01/M00/10/64/wKioOVHm6RLA7lNgAAYTkpqIhHI443.png" alt=""></a></p>
<p><strong>何为Dispatch Sources</strong></p>
<p>简单来说，dispatch source是一个监视某些类型事件的对象。当这些事件发生时，它自动将一个block放入一个dispatch  queue的执行例程中。</p>
<p>说的貌似有点不清不楚。我们到底讨论哪些事件类型？</p>
<p><a href="http://mobile.51cto.com/iphone-403003.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="6-nbsp-GCD介绍-四-完结"><a href="#6-nbsp-GCD介绍-四-完结" class="headerlink" title="6&nbsp;GCD介绍(四):完结"></a><span>6&nbsp;<a href="http://mobile.51cto.com/hot-403005.htm" target="_blank" rel="external">GCD介绍(四):完结</a></span></h3><p><a href="http://s9.51cto.com/wyfs01/M01/10/65/wKioOVHm6WHyfZpwAAUW85FL2rw592.jpg" target="_blank" rel="external"><img src="http://s9.51cto.com/wyfs01/M01/10/65/wKioOVHm6WHyfZpwAAUW85FL2rw592.jpg" alt=""></a></p>
<p><strong>Dispatch Queue挂起</strong></p>
<p>dispatch queue可以被挂起和恢复。使用&nbsp;<code>dispatch_suspend</code>函数来挂起，使用  &nbsp;<code>dispatch_resume</code>&nbsp;函数来恢复。这两个函数的行为是如你所愿的。另外，这两个函数也可以用于dispatch  source。</p>
<p>一个要注意的地方是，dispatch  queue的挂起是block粒度的。换句话说，挂起一个queue并不会将当前正在执行的block挂起。它会允许当前执行的block执行完毕，然后后续的block不再会被执行，直至queue被恢复。</p>
<p><a href="http://mobile.51cto.com/hot-403005.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="7-nbsp-GCD实战一-使用串行队列实现简单的预加载"><a href="#7-nbsp-GCD实战一-使用串行队列实现简单的预加载" class="headerlink" title="7&nbsp;GCD实战一:使用串行队列实现简单的预加载"></a><span>7&nbsp;<a href="http://mobile.51cto.com/hot-403008.htm" target="_blank" rel="external">GCD实战一:使用串行队列实现简单的预加载</a></span></h3><p><a href="http://s6.51cto.com/wyfs01/M01/10/63/wKioJlHm6ZiQcNvyAAZZhSPdwzs163.jpg" target="_blank" rel="external"><img src="http://s6.51cto.com/wyfs01/M01/10/63/wKioJlHm6ZiQcNvyAAZZhSPdwzs163.jpg" alt=""></a></p>
<p>本文为大家介绍了如何使用串行队列实现简单的预加载，思路是使用gcd创建串行队列，然后在此队列中先后执行两个任务：1.预加载一个viewController 2.将这个viewController推入。文章最后提供了源码下载，希望对各位有所帮助。</p>
<p>其主要思路是使用gcd创建串行队列，然后在此队列中先后执行两个任务：1.预加载一个viewController 2.将这个viewController推入</p>
<p>代码如下：</p>
<p><a href="http://mobile.51cto.com/hot-403008.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="8-nbsp-GCD实战二-资源竞争"><a href="#8-nbsp-GCD实战二-资源竞争" class="headerlink" title="8&nbsp;GCD实战二:资源竞争"></a><span>8&nbsp;<a href="http://mobile.51cto.com/hot-403011.htm" target="_blank" rel="external">GCD实战二:资源竞争</a></span></h3><p><a href="http://s8.51cto.com/wyfs01/M00/10/63/wKioJlHm6dryWbz9AAbiZzr2fkA513.jpg" target="_blank" rel="external"><img src="http://s8.51cto.com/wyfs01/M00/10/63/wKioJlHm6dryWbz9AAbiZzr2fkA513.jpg" alt=""></a></p>
<p><strong>概述</strong></p>
<p>我将分四步来带大家研究研究程序的并发计算。第一步是基本的串行程序，然后使用GCD把它并行计算化。如果你想顺着步骤来尝试这些程序的话，可以下载源码。注意，别运行imagegcd2.m，这是个反面教材。</p>
<p><strong>源码下载：</strong><a href="http://down.51cto.com/data/872222" target="_blank" rel="external"><strong>http://down.51cto.com/data/872222</strong></a></p>
<p><a href="http://mobile.51cto.com/hot-403011.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="9-nbsp-iOS多线程初体验"><a href="#9-nbsp-iOS多线程初体验" class="headerlink" title="9&nbsp;iOS多线程初体验"></a><span>9&nbsp;<a href="http://mobile.51cto.com/iphone-280299.htm" target="_blank" rel="external">iOS多线程初体验</a></span></h3><p><strong>iOS多线程</strong>初体验是本文要介绍的内容，<a href="http://mobile.51cto.com/iphone/" target="_blank" rel="external">iPhone</a>中的<strong>线程</strong>应用并不是无节制的，官方给出的资料显示<a href="http://mobile.51cto.com/iphone/" target="_blank" rel="external">iPhone </a>OS下的主<strong>线程</strong>的堆栈大小是1M，第二个<strong>线程</strong>开始都是512KB。并且该值不能通过编译器开关或<strong>线程</strong>API函数来更改。只有主<strong>线程</strong>有直接修改UI的能力。</p>
<p><strong>一、 NSOperation和NSOperationQueue</strong></p>
<p>1、一个继承自&nbsp; NSOperation的操作类，该类的实现中必须有 - (void)main方法的。</p>
<p>2、使用NSOperation的最简单方法就是将其放入NSOperationQueue中。</p>
<p><a href="http://mobile.51cto.com/iphone-280299.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="10-nbsp-iPhone多线程编程初体验"><a href="#10-nbsp-iPhone多线程编程初体验" class="headerlink" title="10&nbsp;iPhone多线程编程初体验"></a><span>10&nbsp;<a href="http://mobile.51cto.com/iphone-267455.htm" target="_blank" rel="external">iPhone多线程编程初体验</a></span></h3><p>找了很长时间<strong>IPhone</strong>下多线程的编程的内容, 用到的类是UIKit的中NSThread.。</p>
<p>在google过程中,发现很多文都惊喜地标题着类似&lt; 多线程的OS4来了&gt;, 这些想正向引导一下, 0S4的亮点在于多任务,一个任务为一个进程,也叫多进程, 而多线程在早期的IPHONEOS上都是有的.</p>
<p>IPHONE OS中任务的概念是一个应用, 在一个时间你只能做一件事情, 即不能同时玩游戏,同时上QQ. 而多任务的时候是可以这么做的.</p>
<p>流程大概如下:</p>
<p><a href="http://mobile.51cto.com/iphone-267455.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="11-nbsp-剖析iPhone多线程"><a href="#11-nbsp-剖析iPhone多线程" class="headerlink" title="11&nbsp;剖析iPhone多线程"></a><span>11&nbsp;<a href="http://mobile.51cto.com/iphone-277631.htm" target="_blank" rel="external">剖析iPhone多线程</a></span></h3><p><strong>iPhone多线程</strong>是本文要介绍的内容，<strong>多线程</strong>在各种编程语言中都是难点，很多语言中实现起来很麻烦，objective-c虽然源于c,但其<strong>多线程</strong>编程却相当简单，可以与java相媲美。这篇文章主要从<strong>线程</strong>创建与启动、<strong>线程</strong>的同步与锁、<strong>线程</strong>的交互、<strong>线程</strong>池等等四个方面简单的讲解一下<strong>iphone</strong>中的<strong>多线程</strong>编程。</p>
<p><strong>一、线程创建与启动</strong></p>
<p>线程创建主要有二种方式：</p>
<pre>

1.  <span><span>-&nbsp;(id)init;&nbsp;//&nbsp;designated&nbsp;initializer &nbsp;</span></span>
2.  <span>-&nbsp;(id)initWithTarget:(id)target&nbsp;selector:(SEL)selector&nbsp;object:(id)argument;&nbsp;</span></pre>

<p>当然，还有一种比较特殊，就是使用所谓的convenient method，这个方法可以直接生成一个线程并启动它，而且无需为线程的清理负责。这个方法的接口是：</p>
<p><a href="http://mobile.51cto.com/iphone-277631.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="12-nbsp-iPhone开发多线程使用与注意事项"><a href="#12-nbsp-iPhone开发多线程使用与注意事项" class="headerlink" title="12&nbsp;iPhone开发多线程使用与注意事项"></a><span>12&nbsp;<a href="http://mobile.51cto.com/iphone-279986.htm" target="_blank" rel="external">iPhone开发多线程使用与注意事项</a></span></h3><p><strong>iPhone</strong>开发<strong>多线程</strong>使用与注意事项是本文要介绍的内容，主要介绍一下<a href="http://mobile.51cto.com/iphone/" target="_blank" rel="external">iPhone </a>SDK中多线程的使用方法以及注意事项。虽然现在大部分PC应用程序都支持<strong>多线程</strong>/多任务的开发方式，但是在<strong>iPhone</strong>上，Apple并不推荐使用<strong>多线程</strong>的编程方式。</p>
<p>但是<strong>多线程</strong>编程毕竟是发展的趋势，而且据说即将推出的<strong>iPhone </strong>OS4将全面支持<strong>多线程</strong>的处理方式。所以说掌握<strong>多线程</strong>的编程方式，在某些场合一定能挖掘出<strong>iPhone</strong>的更大潜力。</p>
<p>从例子入手</p>
<p>先从一个例程入手，具体的代码参考了这里。还有例程可以下载。</p>
<p><a href="http://mobile.51cto.com/iphone-279986.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="13-nbsp-iPhone-SDK-多线程使用方法以及注意事项"><a href="#13-nbsp-iPhone-SDK-多线程使用方法以及注意事项" class="headerlink" title="13&nbsp;iPhone SDK 多线程使用方法以及注意事项"></a><span>13&nbsp;<a href="http://mobile.51cto.com/iphone-277753.htm" target="_blank" rel="external">iPhone SDK 多线程使用方法以及注意事项</a></span></h3><p><strong>iPhone SDK 多线程</strong>使用方法以及注意事项是本文要介绍的内容，不多说，直接进入话题。虽然现在大部分PC应用程序都支持<strong>多线程</strong>/多任务的开发方式，但是在<strong>iPhone</strong>上，Apple并不推荐使用<strong>多线程</strong>的编程方式。但是<strong>多线程</strong>编程毕竟是发展的趋势，而且据说即将推出的<strong>iPhone </strong>OS4将全 </p>
<p>&nbsp; </p>
<p>虽然现在大部分PC应用程序都支持<strong>多线程</strong>/多任务的开发方式，但是在<strong>iPhone</strong>上，Apple并不推荐使用<strong>多线程</strong>的编程方式。但是<strong>多线程</strong>编程毕竟是发展的趋势，而且据说即将推出的<strong>iPhone </strong>OS4将全面支持<strong>多线程</strong>的处理方式。所以说掌握<strong>多线程</strong>的编程方式，在某些场合一定能挖掘出<strong>iPhone</strong>的更大潜力</p>
<p>从例子入手</p>
<p>先从一个例程入手，具体的代码参考了这里。还有例程可以下载。多线程程序的控制模型可以参考这里，一般情况下都是使用 管理者/工人模型, 这里，我们使用iPhone SDK中的 NSThread 来实现它。</p>
<p>首先创建一个新的 View-based application 工程，名字为 &quot;TutorialProject&quot; 。界面如下图所示，使用UILabel实现两部分的Part(Thread Part和Test Part)，Thread Part中包含一个UIProgressView和一个UIButton；而Test Part包含一个值和一个UISlider。如图：</p>
<p><a href="http://mobile.51cto.com/iphone-277753.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="14-nbsp-SQLite在多线程环境下的应用"><a href="#14-nbsp-SQLite在多线程环境下的应用" class="headerlink" title="14&nbsp;SQLite在多线程环境下的应用"></a><span>14&nbsp;<a href="http://mobile.51cto.com/iphone-299765.htm" target="_blank" rel="external">SQLite在多线程环境下的应用</a></span></h3><p>先说下初衷吧，实际上我经常看到有人抱怨SQLite不支持多线程。而在iOS开发时，为了不阻塞主线程，数据库访问必须移到子线程中。为了解决这个矛盾，很有必要对此一探究竟。</p>
<p>关于这个问题，最权威的解答当然是SQLite官网上的&ldquo;Is SQLite threadsafe?&rdquo;这个问答。</p>
<p>简单来说，从3.3.1版本开始，它就是线程安全的了。而iOS的SQLite版本没有低于这个版本的：</p>
<p>3.4.0 - iPhone OS 2.2.1</p>
<p><a href="http://mobile.51cto.com/iphone-299765.htm" target="_blank" rel="external">阅读全文</a> </p>
<h3 id="15-nbsp-关于iPhone多线程编程的教程"><a href="#15-nbsp-关于iPhone多线程编程的教程" class="headerlink" title="15&nbsp;关于iPhone多线程编程的教程"></a><span>15&nbsp;<a href="http://mobile.51cto.com/iphone-281869.htm" target="_blank" rel="external">关于iPhone多线程编程的教程</a></span></h3><p><strong>iPhone多线程</strong>编程的教程是本文要介绍的内容，相信大家也都接触过<strong>多线程</strong>的使用，那么本文也可以作为一个参考来进行学习。不多说，我们来看内容中详细讲解<strong>多线程</strong>编程。</p>
<p><strong>iphone中多线程编程：线程的创建</strong></p>
<p><strong>多线程</strong>在各种编程语言中都是难点，很多语言中实现起来很麻烦，objective-c虽然源于c,但其多线程编程却相当简单，可以与java相媲美。</p>
<p>一、线程创建与启动</p>
<p><a href="http://mobile.51cto.com/iphone-281869.htm" target="_blank" rel="external">阅读全文</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://mobile.51cto.com/iphone-403490.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mobile.51cto.com/iphone-403490.htm&lt;/a&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="多线程" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="多线程" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="GCD" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/GCD/"/>
    
      <category term="NSOperationQueue" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/NSOperationQueue/"/>
    
      <category term="NSThread" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/NSThread/"/>
    
  </entry>
  
  <entry>
    <title>[转]禅与 Objective-C 编程艺术</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/02/16/17.2.16_%E7%A6%85%E4%B8%8E%20Objective-C%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/02/16/17.2.16_禅与 Objective-C编程艺术/</id>
    <published>2017-02-16T01:44:11.000Z</published>
    <updated>2017-09-11T14:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://github.com/oa414/objc-zen-book-cn">https://github.com/oa414/objc-zen-book-cn</a></p>
<h1 id="禅与-Objective-C-编程艺术-（Zen-and-the-Art-of-the-Objective-C-Craftsmanship-中文翻译）"><a href="#禅与-Objective-C-编程艺术-（Zen-and-the-Art-of-the-Objective-C-Craftsmanship-中文翻译）" class="headerlink" title="禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）"></a>禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</h1><ul>
<li>原文 <a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></li>
<li>Gitbook 链接(包含 PDF, mobi, epub 格式): <a href="http://yourtion.gitbooks.io/objc-zen-book-cn/" target="_blank" rel="external">http://yourtion.gitbooks.io/objc-zen-book-cn/</a> (感谢 <a href="https://github.com/yourtion">yourtion</a> 整理 )</li>
</ul>
<p><img src="./images/zen-logo-thumb.png" alt=""></p>
<ul>
<li><a href="#前言">前言</a><ul>
<li><a href="#swift">Swift</a></li>
<li><a href="#贡献给社区">贡献给社区</a></li>
<li><a href="#作者">作者</a></li>
<li><a href="#关于中文翻译">关于中文翻译</a></li>
</ul>
</li>
<li><a href="#条件语句">条件语句</a><ul>
<li><a href="#尤达表达式">尤达表达式</a></li>
<li><a href="#nil-和-bool-检查">nil 和 BOOL 检查</a></li>
<li><a href="#黄金大道">黄金大道</a></li>
<li><a href="#复杂的表达式">复杂的表达式</a></li>
<li><a href="#三元运算符">三元运算符</a></li>
<li><a href="#错误处理">错误处理</a></li>
</ul>
</li>
<li><a href="#case语句">Case语句</a><ul>
<li><a href="#枚举类型">枚举类型</a></li>
</ul>
</li>
<li><a href="#命名">命名</a><ul>
<li><a href="#通用的约定">通用的约定</a></li>
<li><a href="#常量">常量</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#字面值">字面值</a></li>
</ul>
</li>
<li><a href="#类">类</a><ul>
<li><a href="#类名">类名</a></li>
<li><a href="#initializer-和-dealloc">Initializer 和 dealloc</a><ul>
<li><a href="#designated-和-secondary初始化方法">Designated 和 Secondary 初始化方法</a><ul>
<li><a href="#designated-initializer">Designated Initializer</a></li>
<li><a href="#secondary-initializer">Secondary Initializer</a><ul>
<li><a href="#参考">参考</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#instancetype">instancetype</a><ul>
<li><a href="#参考">参考</a></li>
</ul>
</li>
<li><a href="#初始化模式">初始化模式</a><ul>
<li><a href="#类簇-（class-cluster）">类簇 （class cluster)</a></li>
<li><a href="#单例">单例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#属性">属性</a><ul>
<li><a href="#init-和-dealloc">Init 和 Dealloc</a></li>
<li><a href="#点符号">点符号</a><ul>
<li><a href="#属性定义">属性定义</a></li>
</ul>
</li>
<li><a href="#私有属性">私有属性</a><ul>
<li><a href="#可变对象">可变对象</a></li>
<li><a href="#懒加-（lazy-loading）">懒加载 (Lazy Loading)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#方法">方法</a><ul>
<li><a href="#参数断言">参数断言</a></li>
<li><a href="#私有方法">私有方法</a></li>
</ul>
</li>
<li><a href="#相等性">相等性</a></li>
</ul>
</li>
<li><a href="#categories">Categories</a></li>
<li><a href="#protocols">Protocols</a></li>
<li><a href="#nsnotification">NSNotification</a></li>
<li><a href="#美化代码">美化代码</a><ul>
<li><a href="#空格">空格</a></li>
<li><a href="#换行">换行</a></li>
<li><a href="#括号">括号</a></li>
</ul>
</li>
<li><a href="#代码组织">代码组织</a><ul>
<li><a href="#利用代码块">利用代码块</a></li>
<li><a href="#pragma">Pragma</a><ul>
<li><a href="#pragma-mark">Pragma Mark</a></li>
<li><a href="#忽略没用使用变量的编译警告">忽略没用使用变量的编译警告</a></li>
</ul>
</li>
<li><a href="#明确编译器警告和错误">明确编译器警告和错误</a></li>
<li><a href="#字符串文档">字符串文档</a></li>
<li><a href="#注释">注释</a><ul>
<li><a href="#头文档">头文档</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#对象间的通讯">对象间的通讯</a><ul>
<li><a href="#blocks">Block</a><ul>
<li><a href="#深入-block">深入 Block</a></li>
<li><a href="#self-的循环引用">self 的循环引用</a></li>
</ul>
</li>
<li><a href="#委托和数据源">委托和数据源</a><ul>
<li><a href="#继承">继承</a></li>
<li><a href="#多重委托">多重委托</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#面向切面编程">面向切面编程</a></li>
<li><a href="#参考资料">参考资料</a><ul>
<li><a href="#其他的-objective-c-风格指南">其他的 Objective-C 风格指南</a></li>
</ul>
</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在 2013 年 11 月份开始写这本书，最初的目标是提供一份如何编写干净漂亮的 Objective-C 代码的指南：现在虽然有很多指南，但是它们都是有一些问题的。我们不想介绍一些死板的规定，我们想提供一个在开发者们之间写更一致的代码的途径。随时间的推移，这本书开始转向介绍如何设计和构建优秀的代码。</p>
<p>这本书的观点是代码不仅是可以编译的，同时应该是 “有效” 的。好的代码有一些特性：简明，自我解释，优秀的组织，良好的文档，良好的命名，优秀的设计以及可以被久经考验。</p>
<p>本书的一个理念是是代码的清晰性优先于性能，同时阐述为什么应该这么做。</p>
<p>虽然所有的代码都是 Objective-C 写的，但是一些主题是通用的，并且独立于编程语言。</p>
<h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>在 2014 年 6 月 6 日，苹果发布了面向 iOS 和 Mac 开发的新语言： Swift。<br>这个新语言与 Objective-C 截然不同。所以，我们改变了写这本书的计划。我们决定发布这本书当前的状态，而不是继续书写我们原来计划写下去的主题。</p>
<p>Objective-C 没有消失，但是现在用一个慢慢失去关注的语言来继续写这本书并不是一个明智的选择。</p>
<h2 id="贡献给社区"><a href="#贡献给社区" class="headerlink" title="贡献给社区"></a>贡献给社区</h2><p>我们将这本书免费发布并且贡献给社区，因为我们希望提供给读者一些有价值的内容。如果你能学到至少一条最佳实践，我们的目的就达到了。</p>
<p>我们已经非常用心地打磨了这些文字，但是仍然可能有一些拼写或者其他错误。我们非常希望读者给我们一个反馈或者建议，以来改善本书。所以如果有什么问题的话，请联系我们。我们非常欢迎各种 pull-request。</p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p><strong>Luca Bernardi</strong></p>
<ul>
<li><a href="http://lucabernardi.com" target="_blank" rel="external">http://lucabernardi.com</a></li>
<li>@luka_bernardi</li>
<li><a href="https://github.com/lukabernardi">https://github.com/lukabernardi</a></li>
</ul>
<p><strong>Alberto De Bortoli</strong></p>
<ul>
<li><a href="http://albertodebortoli.com" target="_blank" rel="external">http://albertodebortoli.com</a></li>
<li>@albertodebo</li>
<li><a href="http://github.com/albertodebortoli">http://github.com/albertodebortoli</a></li>
</ul>
<h2 id="关于中文翻译"><a href="#关于中文翻译" class="headerlink" title="关于中文翻译"></a>关于中文翻译</h2><p>译者</p>
<p><strong>林翔宇</strong></p>
<ul>
<li><a href="http://www.linxiangyu.org/" target="_blank" rel="external">http://www.linxiangyu.org/</a></li>
<li>linxiangyu@nupter.org</li>
<li><a href="https://github.com/oa414">https://github.com/oa414</a></li>
</ul>
<p><strong>庞博</strong></p>
<ul>
<li>bopang@sohu-inc.com</li>
<li><a href="https://github.com/heistings">https://github.com/heistings</a></li>
</ul>
<p><strong>Kevin.Xiao</strong></p>
<ul>
<li>kevinxiao1919@gmail.com</li>
<li><a href="https://github.com/KevinHM">https://github.com/KevinHM</a></li>
</ul>
<p>翻译已得到原作者许可，并且会在更加完善后申请合并到原文仓库。</p>
<p><strong>部分译文表达可能存在不妥之处，非常欢迎各种修订建议和校对。 请直接 fork 本仓库，在 README.md 文件中修改，并申请 pull request 到 <a href="https://github.com/oa414/objc-zen-book-cn/">https://github.com/oa414/objc-zen-book-cn/</a>。</strong></p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>条件语句体应该总是被大括号包围。尽管有时候你可以不使用大括号（比如，条件语句体只有一行内容），但是这样做会带来问题隐患。比如，增加一行代码时，你可能会误以为它是 if 语句体里面的。此外，更危险的是，如果把 if 后面的那行代码注释掉，之后的一行代码会成为 if 语句里的代码。</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!error) &#123;</div><div class="line">    return success;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!error)</div><div class="line">    return success;</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!error) return success;</div></pre></td></tr></table></figure>
<p>在 2014年2月 苹果的 SSL/TLS 实现里面发现了知名的 <a href="https://gotofail.com/" target="_blank" rel="external">goto fail</a> 错误。</p>
<p>代码在这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static OSStatus</div><div class="line">SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,</div><div class="line">                                 uint8_t *signature, UInt16 signatureLen)</div><div class="line">&#123;</div><div class="line">  OSStatus        err;</div><div class="line">  ...</div><div class="line"></div><div class="line">  if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)</div><div class="line">    goto fail;</div><div class="line">  if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)</div><div class="line">    goto fail;</div><div class="line">    goto fail;</div><div class="line">  if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)</div><div class="line">    goto fail;</div><div class="line">  ...</div><div class="line"></div><div class="line">fail:</div><div class="line">  SSLFreeBuffer(&amp;signedHashes);</div><div class="line">  SSLFreeBuffer(&amp;hashCtx);</div><div class="line">  return err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显而易见，这里有没有括号包围的2行连续的 <code>goto fail;</code> 。我们当然不希望写出上面的代码导致错误。</p>
<p>此外，在其他条件语句里面也应该按照这种风格统一，这样更便于检查。</p>
<h2 id="尤达表达式"><a href="#尤达表达式" class="headerlink" title="尤达表达式"></a>尤达表达式</h2><p>不要使用尤达表达式。尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是  “天空是不是蓝的” 或者 “这个男人是不是高个子的”</p>
<p><img src="./images/yoda.png" alt="Yoda"></p>
<p>（译者注：名字起源于星球大战中尤达大师的讲话方式，总是用倒装的语序）</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([myValue isEqual:@42]) &#123; ...</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([@42 isEqual:myValue]) &#123; ...</div></pre></td></tr></table></figure></p>
<h2 id="nil-和-BOOL-检查"><a href="#nil-和-BOOL-检查" class="headerlink" title="nil 和 BOOL 检查"></a>nil 和 BOOL 检查</h2><p>类似于 Yoda 表达式，nil 检查的方式也是存在争议的。一些 notous 库像这样检查对象是否为 nil：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (nil == myValue) &#123; ...</div></pre></td></tr></table></figure>
<p>或许有人会提出这是错的，因为在 nil 作为一个常量的情况下，这样做就像 Yoda 表达式了。 但是一些程序员这么做的原因是为了避免调试的困难，看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (myValue == nil) &#123; ...</div></pre></td></tr></table></figure>
<p>如果程序员敲错成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (myValue = nil) &#123; ...</div></pre></td></tr></table></figure>
<p>这是合法的语句，但是即使你是一个丰富经验的程序员，即使盯着眼睛瞧上好多遍也很难调试出错误。但是如果把 nil 放在左边，因为它不能被赋值，所以就不会发生这样的错误。 如果程序员这样做，他/她就可以轻松检查出可能的原因，比一遍遍检查敲下的代码要好很多。</p>
<p>为了避免这些奇怪的问题，可以用感叹号来作为运算符。因为 nil 是 解释到 NO，所以没必要在条件语句里面把它和其他值比较。同时，不要直接把它和 <code>YES</code> 比较，因为 <code>YES</code> 的定义是 1， 而 <code>BOOL</code> 是 8 bit的，实际上是 char 类型。</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someObject) &#123; ...</div><div class="line">if (![someObject boolValue]) &#123; ...</div><div class="line">if (!someObject) &#123; ...</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someObject == YES) &#123; ... // Wrong</div><div class="line">if (myRawValue == YES) &#123; ... // Never do this.</div><div class="line">if ([someObject boolValue] == NO) &#123; ...</div></pre></td></tr></table></figure></p>
<p>同时这样也能提高一致性，以及提升可读性。</p>
<h2 id="黄金大道"><a href="#黄金大道" class="headerlink" title="黄金大道"></a>黄金大道</h2><p>在使用条件语句编程时，代码的左边距应该是一条“黄金”或者“快乐”的大道。 也就是说，不要嵌套 <code>if</code> 语句。使用多个 return 可以避免增加循环的复杂度，并提高代码的可读性。因为方法的重要部分没有嵌套在分支里面，并且你可以很清楚地找到相关的代码。</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //Do something important</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if ([someOther boolValue]) &#123;</div><div class="line">    //Do something important</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复杂的表达式"><a href="#复杂的表达式" class="headerlink" title="复杂的表达式"></a>复杂的表达式</h2><p>当你有一个复杂的 if 子句的时候，你应该把它们提取出来赋给一个 BOOL 变量，这样可以让逻辑更清楚，而且让每个子句的意义体现出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL nameContainsSwift  = [sessionName containsString:@&quot;Swift&quot;];</div><div class="line">BOOL isCurrentYear      = [sessionDateCompontents year] == 2014;</div><div class="line">BOOL isSwiftSession     = nameContainsSwift &amp;&amp; isCurrentYear;</div><div class="line"></div><div class="line">if (isSwiftSession) &#123;</div><div class="line">    // Do something very cool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符 ? 应该只用在它能让代码更加清楚的地方。 一个条件语句的所有的变量应该是已经被求值了的。类似 if 语句，计算多个条件子句通常会让语句更加难以理解。或者可以把它们重构到实例变量里面。</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = a &gt; b ? x : y;</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</div></pre></td></tr></table></figure></p>
<p>当三元运算符的第二个参数（if 分支）返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧：</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = object ? : [self createObject];</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = object ? object : [self createObject];</div></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>有些方法通过参数返回 error 的引用，使用这样的方法时应当检查方法的返回值，而非 error 的引用。</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">if (![self trySomethingWithError:&amp;error]) &#123;</div><div class="line">    // Handle Error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，一些苹果的 API 在成功的情况下会对 error 参数（如果它非 NULL）写入垃圾值（garbage values），所以如果检查 error 的值可能导致错误 （甚至崩溃）。</p>
<h1 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h1><p>除非编译器强制要求，括号在 case 语句里面是不必要的。但是当一个 case 包含了多行语句的时候，需要加上括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch (condition) &#123;</div><div class="line">    case 1:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">    case 2: &#123;</div><div class="line">        // ...</div><div class="line">        // Multi-line example using braces</div><div class="line">        break;</div><div class="line">       &#125;</div><div class="line">    case 3:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候可以使用 fall-through 在不同的 case 里面执行同一段代码。一个 fall-through  是指移除 case 语句的 “break” 然后让下面的 case 继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">switch (condition) &#123;</div><div class="line">    case 1:</div><div class="line">    case 2:</div><div class="line">        // code executed for values 1 and 2</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当在 switch 语句里面使用一个可枚举的变量的时候，<code>default</code> 是不必要的。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (menuType) &#123;</div><div class="line">    case ZOCEnumNone:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">    case ZOCEnumValue1:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">    case ZOCEnumValue2:</div><div class="line">        // ...</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，为了避免使用默认的 case，如果新的值加入到 enum，程序员会马上收到一个 warning 通知</p>
<p><code>Enumeration value &#39;ZOCEnumValue3&#39; not handled in switch.（枚举类型 &#39;ZOCEnumValue3&#39; 没有被 switch 处理）</code></p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>当使用 <code>enum</code> 的时候，建议使用新的固定的基础类型定义，因为它有更强大的类型检查和代码补全。 SDK 现在有一个 宏来鼓励和促进使用固定类型定义 - <code>NS_ENUM()</code></p>
<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, ZOCMachineState) &#123;</div><div class="line">    ZOCMachineStateNone,</div><div class="line">    ZOCMachineStateIdle,</div><div class="line">    ZOCMachineStateRunning,</div><div class="line">    ZOCMachineStatePaused</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><h2 id="通用的约定"><a href="#通用的约定" class="headerlink" title="通用的约定"></a>通用的约定</h2><p>尽可能遵守 Apple 的命名约定，尤其是和 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" target="_blank" rel="external">内存管理规则</a> (<a href="http://stackoverflow.com/a/2865194/340508" target="_blank" rel="external">NARC</a>) 相关的地方。</p>
<p>推荐使用长的、描述性的方法和变量名。</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIButton *settingsButton;</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIButton *setBut;</div></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量应该以驼峰法命名，并以相关类名作为前缀。</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4;</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval fadeOutTime = 0.4;</div></pre></td></tr></table></figure></p>
<p>推荐使用常量来代替字符串字面值和数字，这样能够方便复用，而且可以快速修改而不需要查找和替换。常量应该用 <code>static</code> 声明为静态常量，而不要用 <code>#define</code>，除非它明确的作为一个宏来使用。</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;</div><div class="line">static const CGFloat ZOCImageThumbnailHeight = 50.0f;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define CompanyName @&quot;Apple Inc.&quot;</div><div class="line">#define magicNumber 42</div></pre></td></tr></table></figure>
<p>常量应该在头文件中以这样的形式暴露给外部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern NSString *const ZOCCacheControllerDidClearCacheNotification;</div></pre></td></tr></table></figure>
<p>并在实现文件中为它赋值。</p>
<p>只有公有的常量才需要添加命名空间作为前缀。尽管实现文件中私有常量的命名可以遵循另外一种模式，你仍旧可以遵循这个规则。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法名与方法类型 (<code>-</code>/<code>+</code> 符号)之间应该以空格间隔。方法段之间也应该以空格间隔（以符合 Apple 风格）。参数前应该总是有一个描述性的关键词。</p>
<p>尽可能少用 “and” 这个词。它不应该用来阐明有多个参数，比如下面的 <code>initWithWidth:height:</code> 这个例子：</p>
<p><strong>推荐:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image;</div><div class="line">- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</div><div class="line">- (id)viewWithTag:(NSInteger)tag;</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure></p>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setT:(NSString *)text i:(UIImage *)image;</div><div class="line">- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</div><div class="line">- (id)taggedView:(NSInteger)tag;</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;</div><div class="line">- (instancetype)initWith:(int)width and:(int)height;  // Never do this.</div></pre></td></tr></table></figure>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p>使用字面值来创建不可变的 <code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code> 对象。注意不要将 <code>nil</code> 传进 <code>NSArray</code> 和 <code>NSDictionary</code> 里，因为这样会导致崩溃。</p>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;;</div><div class="line">NSNumber *shouldUseLiterals = @YES;</div><div class="line">NSNumber *buildingZIPCode = @10018;</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</div><div class="line">NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];</div><div class="line">NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];</div><div class="line">NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];</div></pre></td></tr></table></figure>
<p>如果要用到这些类的可变副本，我们推荐使用 <code>NSMutableArray</code>, <code>NSMutableString</code> 这样的类。</p>
<p><strong>应该避免</strong>下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *aMutableArray = [@[] mutableCopy];</div></pre></td></tr></table></figure>
<p>上面这种书写方式的效率和可读性的都存在问题。</p>
<p>效率方面，一个不必要的不可变对象被创建后立马被废弃了；虽然这并不会让你的 App 变慢（除非这个方法被频繁调用），但是确实没必要为了少打几个字而这样做。</p>
<p>可读性方面，存在两个问题：第一个问题是当你浏览代码并看见 <code>@[]</code> 的时候，你首先联想到的是 <code>NSArray</code> 实例，但是在这种情形下你需要停下来深思熟虑的检查；另一个问题是，一些新手以他的水平看到你的代码后可能会对这是一个可变对象还是一个不可变对象产生分歧。他/她可能不熟悉可变拷贝构造的含义（这并不是说这个知识不重要）。当然，不存在绝对的错误，我们只是讨论代码的可用性（包括可读性)。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名应该以<strong>三</strong>个大写字母作为前缀（双字母前缀为 Apple 的类预留）。尽管这个规范看起来有些古怪，但是这样做可以减少 Objective-C 没有命名空间所带来的问题。</p>
<p>一些开发者在定义模型对象时并不遵循这个规范（对于 Core Data 对象，我们更应该遵循这个规范）。我们建议在定义 Core Data 对象时严格遵循这个约定，因为最终你可能需要把你的 Managed Object Model（托管对象模型）与其他（第三方库）的 MOMs（Managed Object Model）合并。</p>
<p>你可能注意到了，这本书里类的前缀（不仅仅是类，也包括公开的常量、Protocol 等的前缀）是<code>ZOC</code>。</p>
<p>另一个好的类的命名规范：当你创建一个子类的时候，你应该把说明性的部分放在前缀和父类名的在中间。</p>
<p>举个例子：如果你有一个 <code>ZOCNetworkClient</code> 类，子类的名字会是<code>ZOCTwitterNetworkClient</code> (注意 “Twitter” 在 “ZOC” 和 “NetworkClient” 之间); 按照这个约定， 一个<code>UIViewController</code> 的子类会是 <code>ZOCTimelineViewController</code>.</p>
<h2 id="Initializer-和-dealloc"><a href="#Initializer-和-dealloc" class="headerlink" title="Initializer 和 dealloc"></a>Initializer 和 dealloc</h2><p>推荐的代码组织方式是将 <code>dealloc</code> 方法放在实现文件的最前面（直接在  <code>@synthesize</code> 以及 <code>@dynamic</code> 之后），<code>init</code> 应该跟在 <code>dealloc</code> 方法后面。</p>
<p>如果有多个初始化方法， 指定初始化方法 (designated initializer) 应该放在最前面，间接初始化方法 (secondary initializer) 跟在后面，这样更有逻辑性。如今有了 ARC，dealloc 方法几乎不需要实现，不过把 init 和 dealloc 放在一起可以从视觉上强调它们是一对的。通常，在 init 方法中做的事情需要在 dealloc 方法中撤销。</p>
<p><code>init</code> 方法应该是这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init]; // call the designated initializer</div><div class="line">    if (self) &#123;</div><div class="line">        // Custom initialization</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么设置 <code>self</code> 为 <code>[super init]</code> 的返回值，以及中间发生了什么呢？这是一个十分有趣的话题。</p>
<p>我们退一步讲：我们常常写 <code>[[NSObject alloc] init]</code> 这样的代码，从而淡化了 <code>alloc</code> 和 <code>init</code> 的区别。Objective-C 的这个特性叫做 <em>两步创建</em> 。</p>
<p>这意味着申请分配内存和初始化被分离成两步，<code>alloc</code> 和 <code>init</code>。</p>
<ul>
<li><code>alloc</code> 负责创建对象，这个过程包括分配足够的内存来保存对象，写入 <code>isa</code> 指针，初始化引用计数，以及重置所有实例变量。</li>
<li><code>init</code> 负责初始化对象，这意味着使对象处于可用状态。这通常意味着为对象的实例变量赋予合理有用的值。</li>
</ul>
<p><code>alloc</code> 方法将返回一个有效的未初始化的对象实例。每一个对这个实例发送的消息会被转换成一次 <code>objc_msgSend()</code> 函数的调用，形参 <code>self</code> 的实参是 <code>alloc</code> 返回的指针；这样 <code>self</code> 在所有方法的作用域内都能够被访问。</p>
<p>按照惯例，为了完成两步创建，新创建的实例第一个被调用的方法将是 <code>init</code> 方法。注意，<code>NSObject</code> 在实现 <code>init</code> 时，只是简单的返回了 <code>self</code>。</p>
<p>关于 <code>init</code> 的约定还有一个重要部分：这个方法可以（并且应该）通过返回 <code>nil</code> 来告诉调用者，初始化失败了；初始化可能会因为各种原因失败，比如一个输入的格式错误了，或者另一个需要的对象初始化失败了。<br>这样我们就能理解为什么总是需要调用 <code>self = [super init]</code>。如果你的父类说初始化自己的时候失败了，那么你必须假定你正处于一个不稳定的状态，因此在你的实现里不要继续你自己的初始化并且也返回 <code>nil</code>。如果不这样做，你可能会操作一个不可用的对象，它的行为是不可预测的，最终可能会导致你的程序崩溃。</p>
<p><code>init</code> 方法在被调用的时候可以通过重新给 <code>self</code> 重新赋值来返回另一个实例，而非调用的那个实例。例如<a href="#类簇">类簇</a>，还有一些 Cocoa 类为相等的（不可变的）对象返回同一个实例。</p>
<h3 id="Designated-和-Secondary-初始化方法"><a href="#Designated-和-Secondary-初始化方法" class="headerlink" title="Designated 和 Secondary 初始化方法"></a>Designated 和 Secondary 初始化方法</h3><p>Objective-C 有指定初始化方法(designated initializer)和间接(secondary initializer)初始化方法的观念。<br>designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化的初始化方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCEvent</div><div class="line"></div><div class="line">- (instancetype)initWithTitle:(NSString *)title</div><div class="line">                         date:(NSDate *)date</div><div class="line">                     location:(CLLocation *)location</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _title    = title;</div><div class="line">        _date     = date;</div><div class="line">        _location = location;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithTitle:(NSString *)title</div><div class="line">                         date:(NSDate *)date</div><div class="line">&#123;</div><div class="line">    return [self initWithTitle:title date:date location:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithTitle:(NSString *)title</div><div class="line">&#123;</div><div class="line">    return [self initWithTitle:title date:[NSDate date] location:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>initWithTitle:date:location:</code> 就是 designated 初始化方法，另外的两个是 secondary 初始化方法。因为它们仅仅是调用类实现的 designated 初始化方法</p>
<h4 id="Designated-Initializer"><a href="#Designated-Initializer" class="headerlink" title="Designated Initializer"></a>Designated Initializer</h4><p>一个类应该有且只有一个 designated 初始化方法，其他的初始化方法应该调用这个 designated 的初始化方法（虽然这个情况有一个例外）</p>
<p>这个分歧没有要求那个初始化函数需要被调用。</p>
<p>在类继承中调用任何 designated 初始化方法都是合法的，而且应该保证 <em>所有的</em> designated initializer 在类继承中是从祖先（通常是  <code>NSObject</code>）到你的类向下调用的。</p>
<p>实际上这意味着第一个执行的初始化代码是最远的祖先，然后从顶向下的类继承，所有类都有机会执行他们特定初始化代码。这样，你在做特定初始化工作前，所有从超类继承的东西都是不可用的状态。 虽然这没有明确的规定，但是所有 Apple 的框架都保证遵守这个约定，你的类也应该这样做。</p>
<p>当定义一个新类的时候有三个不同的方式：</p>
<ol>
<li>不需要重载任何初始化函数</li>
<li>重载 designated initializer</li>
<li>定义一个新的 designated initializer</li>
</ol>
<p>第一个方案是最简单的：你不需要增加类的任何初始化逻辑，只需要依照父类的designated initializer。</p>
<p>当你希望提供额外的初始化逻辑的时候，你可以重载 designated initializer。你只需要重载直接超类的 designated initializer 并且确认你的实现调用了超类的方法。</p>
<p>一个典型的例子是你创造<code>UIViewController</code>子类的时候重载<code>initWithNibName:bundle:</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCViewController</div><div class="line"></div><div class="line">- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</div><div class="line">&#123;</div><div class="line">    // call to the superclass designated initializer</div><div class="line">    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</div><div class="line">    if (self) &#123;</div><div class="line">        // Custom initialization （自定义的初始化过程）</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 <code>UIViewController</code>  子类的例子里面如果重载  <code>init</code> 会是一个错误，这个情况下调用者会尝试调用 <code>initWithNib:bundle</code> 初始化你的类，你的类实现不会被调用。这同样违背了它应该是合法调用任何 designated initializer 的规则。</p>
<p>在你希望提供你自己的初始化函数的时候，你应该遵守这三个步骤来保证获得正确的行为：</p>
<ol>
<li>定义你的 designated initializer，确保调用了直接超类的 designated initializer。</li>
<li>重载直接超类的 designated initializer。调用你的新的  designated initializer。</li>
<li>为新的 designated initializer 写文档。</li>
</ol>
<p>很多开发者忽略了后两步，这不仅仅是一个粗心的问题，而且这样违反了框架的规则，可能导致不确定的行为和bug。<br>让我们看看正确的实现的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCNewsViewController</div><div class="line"></div><div class="line">- (id)initWithNews:(ZOCNews *)news</div><div class="line">&#123;</div><div class="line">    // call to the immediate superclass&apos;s designated initializer （调用直接超类的 designated initializer）</div><div class="line">    self = [super initWithNibName:nil bundle:nil];</div><div class="line">    if (self) &#123;</div><div class="line">        _news = news;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Override the immediate superclass&apos;s designated initializer （重载直接父类的  designated initializer）</div><div class="line">- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</div><div class="line">&#123;</div><div class="line">    // call the new designated initializer</div><div class="line">    return [self initWithNews:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你没重载 <code>initWithNibName:bundle:</code> ，而且调用者决定用这个方法初始化你的类(这是完全合法的)。 <code>initWithNews:</code> 永远不会被调用，所以导致了不正确的初始化流程，你的类的特定初始化逻辑没有被执行。</p>
<p>即使可以推断那个方法是 designated initializer，也最好清晰地明确它（未来的你或者其他开发者在改代码的时候会感谢你的）。</p>
<p>你应该考虑来用这两个策略（不是互斥的）：第一个是你在文档中明确哪一个初始化方法是 designated 的，你可以用编译器的指令 <code>__attribute__((objc_designated_initializer))</code>  来标记你的意图。</p>
<p>用这个编译指令的时候，编译器会来帮你。如果你的新的 designated initializer 没有调用超类的 designated initializer，那么编译器会发出警告。</p>
<p>然而，当没有调用类的  designated initializer 的时候（并且依次提供必要的参数），并且调用其他父类中的 designated initialize 的时候，会变成一个不可用的状态。参考之前的例子，当实例化一个 <code>ZOCNewsViewController</code>  展示一个新闻而那条新闻没有展示的话，就会毫无意义。这个情况下你应该只需要让其他的 designated initializer 失效，来强制调用一个非常特别的 designated initializer。通过使用另外一个编译器指令  <code>__attribute__((unavailable(&quot;Invoke the designated initializer&quot;)))</code> 来修饰一个方法，通过这个属性，会让你在试图调用这个方法的时候产生一个编译错误。</p>
<p>这是之前的例子相关的实现的头文件(这里使用宏来让代码没有那么啰嗦)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ZOCNewsViewController : UIViewController</div><div class="line"></div><div class="line">- (instancetype)initWithNews:(ZOCNews *)news ZOC_DESIGNATED_INITIALIZER;</div><div class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil ZOC_UNAVAILABLE_INSTEAD(initWithNews:);</div><div class="line">- (instancetype)init ZOC_UNAVAILABLE_INSTEAD(initWithNews:);</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上述的一个推论是：你应该永远不从 designated initializer 里面调用一个 secondary initializer （如果secondary initializer 遵守约定，它会调用 designated initializer）。如果这样，调用很可能会调用一个子类重写的 init 方法并且陷入无限递归之中。</p>
<p>不过一个例外是一个对象是否遵守 <code>NSCoding</code> 协议，并且它通过方法 <code>initWithCoder:</code> 初始化。<br>我们应该看超类是否符合 <code>NSCoding</code> 协议来区别对待。<br>符合的时候，如果你只是调用 <code>[super initWithCoder:]</code> ，你可能需要在 designated initializer 里面写一些通用的初始化代码，处理这种情况的一个好方法是把这些代码放在私有方法里面(比如  <code>p_commonInit</code> )。<br>当你的超类不符合 <code>NSCoding</code> 协议的时候，推荐把 <code>initWithCoder:</code> 作为 secondary initializer 来对待，并且调用 <code>self</code> 的 designated initializer。 注意这违反了 Apple 写在 <a href="https://developer.apple.com/library/mac/documentation/cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-BCIHBJDE" target="_blank" rel="external">Archives and Serializations Programming Guide</a>  上面的规定：</p>
<blockquote>
<p>the object should first invoke its superclass’s designated initializer to initialize inherited state（对象总是应该首先调用超类的 designated initializer 来初始化继承的状态）</p>
</blockquote>
<p>如果你的类不是  <code>NSObject</code> 的直接子类，这样做的话，会导致不可预测的行为。</p>
<h4 id="Secondary-Initializer"><a href="#Secondary-Initializer" class="headerlink" title="Secondary Initializer"></a>Secondary Initializer</h4><p>正如之前的描述，secondary initializer 是一种提供默认值、行为到 designated initializer的方法。也就是说，在这样的方法里面你不应该有初始化实例变量的操作，并且你应该一直假设这个方法不会得到调用。我们保证的是唯一被调用的方法是 designated initializer。<br>这意味着你的 secondary initializer 总是应该调用 Designated initializer  或者你自定义(上面的第三种情况：自定义Designated initializer)的 <code>self</code>的 designated initializer。有时候，因为错误，可能打成了  <code>super</code>，这样会导致不符合上面提及的初始化顺序（在这个特别的例子里面，是跳过当前类的初始化）</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html" target="_blank" rel="external">https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Initialization/Initialization.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Initialization/Initialization.html</a></li>
<li><a href="https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/MultipleInitializers.html" target="_blank" rel="external">https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/MultipleInitializers.html</a></li>
<li><a href="https://blog.twitter.com/2014/how-to-objective-c-initializer-patterns" target="_blank" rel="external">https://blog.twitter.com/2014/how-to-objective-c-initializer-patterns</a></li>
</ul>
<h3 id="instancetype"><a href="#instancetype" class="headerlink" title="instancetype"></a>instancetype</h3><p>我们经常忽略 Cocoa 充满了约定，并且这些约定可以帮助编译器变得更加聪明。无论编译器是否遭遇 <code>alloc</code> 或者 <code>init</code> 方法，他会知道，即使返回类型都是 <code>id</code> ，这些方法总是返回接受到的类类型的实例。因此，它允许编译器进行类型检查。（比如，检查方法返回的类型是否合法）。Clang的这个好处来自于 <a href="http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types" target="_blank" rel="external">related result type</a>， 意味着：</p>
<blockquote>
<p>messages sent to one of alloc and init methods will have the same static type as the instance of the receiver class （发送到 alloc 或者 init 方法的消息会有同样的静态类型检查是否为接受类的实例。）</p>
</blockquote>
<p>更多的关于这个自动定义相关返回类型的约定请查看 Clang Language Extensions guide 的<a href="(http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types">appropriate section</a>)</p>
<p>一个相关的返回类型可以明确地规定用 <code>instancetype</code> 关键字作为返回类型，并且它可以在一些工厂方法或者构造器方法的场景下很有用。它可以提示编译器正确地检查类型，并且更加重要的是，这同时适用于它的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZOCPerson</div><div class="line">+ (instancetype)personWithName:(NSString *)name;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>虽然如此，根据 clang 的定义，<code>id</code> 可以被编译器提升到 <code>instancetype</code> 。在 <code>alloc</code> 或者 <code>init</code> 中，我们强烈建议对所有返回类的实例的类方法和实例方法使用 <code>instancetype</code> 类型。</p>
<p>在你的 API 中要构成习惯以及保持始终如一的，此外，通过对你代码的小调整你可以提高可读性：在简单的浏览的时候你可以区分哪些方法是返回你类的实例的。你以后会感谢这些注意过的小细节的。</p>
<h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><ul>
<li><a href="http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/" target="_blank" rel="external">http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/</a></li>
<li><a href="http://tewha.net/2013/01/when-is-id-promoted-to-instancetype/" target="_blank" rel="external">http://tewha.net/2013/01/when-is-id-promoted-to-instancetype/</a></li>
<li><a href="http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types" target="_blank" rel="external">http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types</a></li>
<li><a href="http://nshipster.com/instancetype/" target="_blank" rel="external">http://nshipster.com/instancetype/</a></li>
</ul>
<hr>
<h3 id="初始化模式"><a href="#初始化模式" class="headerlink" title="初始化模式"></a>初始化模式</h3><h4 id="类簇-（class-cluster"><a href="#类簇-（class-cluster" class="headerlink" title="类簇 （class cluster)"></a>类簇 （class cluster)</h4><p>类簇在Apple的文档中这样描述：</p>
<blockquote>
<p>an architecture that groups a number of private, concrete subclasses under a public, abstract superclass. （一个在共有的抽象超类下设置一组私有子类的架构）</p>
</blockquote>
<p>如果这个描述听起来很熟悉，说明你的直觉是对的。 Class cluster 是 Apple 对<a href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" target="_blank" rel="external">抽象工厂</a>设计模式的称呼。</p>
<p>class cluster 的想法很简单: 使用信息进行(类的)初始化处理期间，会使用一个抽象类（通常作为初始化方法的参数或者判定环境的可用性参数）来完成特定的逻辑或者实例化一个具体的子类。而这个”Public Facing（面向公众的）”类，必须非常清楚他的私有子类，以便在面对具体任务的时候有能力返回一个恰当的私有子类实例。对调用者来说只需知道对象的各种API的作用即可。这个模式隐藏了他背后复杂的初始化逻辑，调用者也不需要关心背后的实现。</p>
<p>Class clusters 在 Apple 的Framework 中广泛使用：一些明显的例子比如  <code>NSNumber</code> 可以返回不同类型给你的子类，取决于 数字类型如何提供  (Integer, Float, etc…) 或者 <code>NSArray</code> 返回不同的最优存储策略的子类。</p>
<p>这个模式的精妙的地方在于，调用者可以完全不管子类，事实上，这可以用在设计一个库，可以用来交换实际的返回的类，而不用去管相关的细节，因为它们都遵从抽象超类的方法。</p>
<p>我们的经验是使用类簇可以帮助移除很多条件语句。</p>
<p>一个经典的例子是如果你有为 iPad 和 iPhone 写的一样的 UIViewController 子类，但是在不同的设备上有不同的行为。</p>
<p>比较基础的实现是用条件语句检查设备，然后执行不同的逻辑。虽然刚开始可能不错，但是随着代码的增长，运行逻辑也会趋于复杂。<br>一个更好的实现的设计是创建一个抽象而且宽泛的 view controller 来包含所有的共享逻辑，并且对于不同设备有两个特别的子例。</p>
<p>通用的 view controller  会检查当前设备并且返回适当的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCKintsugiPhotoViewController</div><div class="line"></div><div class="line">- (id)initWithPhotos:(NSArray *)photos</div><div class="line">&#123;</div><div class="line">    if ([self isMemberOfClass:ZOCKintsugiPhotoViewController.class]) &#123;</div><div class="line">        self = nil;</div><div class="line"></div><div class="line">        if ([UIDevice isPad]) &#123;</div><div class="line">            self = [[ZOCKintsugiPhotoViewController_iPad alloc] initWithPhotos:photos];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    return [super initWithNibName:nil bundle:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个子例程展示了如何创建一个类簇。</p>
<ol>
<li><p>使用<code>[self isMemberOfClass:ZOCKintsugiPhotoViewController.class]</code>防止子类中重载初始化方法，避免无限递归。当<code>[[ZOCKintsugiPhotoViewController alloc] initWithPhotos:photos]</code>被调用时，上面条件表达式的结果将会是True。</p>
</li>
<li><p><code>self = nil</code>的目的是移除<code>ZOCKintsugiPhotoViewController</code>实例上的所有引用，实例(抽象类的实例)本身将会解除分配（ 当然ARC也好MRC也好dealloc都会发生在Main Runloop这一次的结束时）。</p>
</li>
<li><p>接下来的逻辑就是判断哪一个私有子类将被初始化。我们假设在iPhone上运行这段代码并且<code>ZOCKintsugiPhotoViewController_iPhone</code>没有重载<code>initWithPhotos:</code>方法。这种情况下，当执行<code>self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];</code>,<code>ZOCKintsugiPhotoViewController</code>将会被调用，第一次检查将会在这里发生，鉴于<code>ZOCKintsugiPhotoViewController_iPhone</code>不完全是<code>ZOCKintsugiPhotoViewController</code>，表达式<code>[self isMemberOfClass:ZOCKintsugiPhotoViewController.class]</code>将会是False,于是就会调用<code>[super initWithNibName:nil bundle:nil]</code>，于是就会进入<code>ZOCKintsugiPhotoViewController</code>的初始化过程，这时候因为调用者就是<code>ZOCKintsugiPhotoViewController</code>本身，这一次的检查必定为True,接下来就会进行正确的初始化过程。(NOTE：这里必须是完全遵循Designated initializer 以及Secondary initializer的设计规范的前提下才会其效果的!不明白这个规范的可以后退一步熟悉这种规范在回头来看这个说明)</p>
</li>
</ol>
<blockquote>
<p>NOTE: 这里的意思是，代码是在iPhone上调试的，程序员使用了<code>self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];</code>来初始化某个view controller的对象，当代码运行在iPad上时，这个初始化过程也是正确的，因为无论程序员的代码中使用<code>self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];</code>来初始化viewController(iPhone上编写运行在iPad上)，还是使用<code>self = [[ZOCKintsugiPhotoViewController_iPad alloc] initWithPhotos:photos];</code>来初始化viewController(iPad上编写，运行在iPhone上)，都会因为ZOCKintsugiPhotoViewController的<code>initWithPhotos:</code>方法的存在而变得通用起来。</p>
</blockquote>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>如果可能，请尽量避免使用单例而是依赖注入。<br>然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 <code>dispatch_once()</code> 函数就可以咯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance</div><div class="line">&#123;</div><div class="line">   static id sharedInstance = nil;</div><div class="line">   static dispatch_once_t onceToken = 0;</div><div class="line">   dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      sharedInstance = [[self alloc] init];</div><div class="line">   &#125;);</div><div class="line">   return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance</div><div class="line">&#123;</div><div class="line">    static id sharedInstance;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (sharedInstance == nil) &#123;</div><div class="line">            sharedInstance = [[MyClass alloc] init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>dispatch_once()</code>  的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。 这样同时可以避免 <a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="external">possible and sometimes prolific crashes</a>.</p>
<p>经典的单例对象是：一个设备的GPS以及它的加速度传感器(也称动作感应器)。<br>虽然单例对象可以子类化，但这种方式能够有用的情况非常少见。<br>必须有证据表明，给定类的接口趋向于作为单例来使用。<br>所以，单例通常公开一个<code>sharedInstance</code>的类方法就已经足够了，没有任何的可写属性需要被暴露出来。</p>
<p>尝试着把单例作为一个对象的容器，在代码或者应用层面上共享，是一个糟糕和丑陋的设计。</p>
<blockquote>
<p>NOTE：单例模式应该运用于类及类的接口趋向于作为单例来使用的情况 （译者注）</p>
</blockquote>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性应该尽可能描述性地命名，避免缩写，并且是小写字母开头的驼峰命名。我们的工具可以很方便地帮我们自动补全所有东西（嗯。。几乎所有的，Xcode 的Derived Data 会索引这些命名）。所以没理由少打几个字符了，并且最好尽可能在你源码里表达更多东西。</p>
<p><strong>例子 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *text;</div></pre></td></tr></table></figure></p>
<p><strong>不要这样 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString* text;</div><div class="line">NSString * text;</div></pre></td></tr></table></figure></p>
<p>（注意：这个习惯和常量不同，这是主要从常用和可读性考虑。 C++ 的开发者偏好从变量名中分离类型，作为类型它应该是<br><code>NSString*</code> （对于从堆中分配的对象，对于C++是能从栈上分配的）格式。）</p>
<p>使用属性的自动同步 (synthesize) 而不是手动的  <code>@synthesize</code> 语句，除非你的属性是 protocol 的一部分而不是一个完整的类。如果 Xcode 可以自动同步这些变量，就让它来做吧。否则只会让你抛开 Xcode 的优点，维护更冗长的代码。</p>
<p>你应该总是使用 setter 和 getter 方法访问属性，除了 <code>init</code> 和 <code>dealloc</code> 方法。通常，使用属性让你增加了在当前作用域之外的代码块的可能所以可能带来更多副作用。</p>
<p>你总应该用 getter 和 setter ，因为：</p>
<ul>
<li>使用  setter 会遵守定义的内存管理语义(<code>strong</code>, <code>weak</code>, <code>copy</code> etc…) ，这个在 ARC 之前就是相关的内容。举个例子，<code>copy</code> 属性定义了每个时候你用 setter 并且传送数据的时候，它会复制数据而不用额外的操作。</li>
<li>KVO 通知(<code>willChangeValueForKey</code>, <code>didChangeValueForKey</code>) 会被自动执行。</li>
<li>更容易debug：你可以设置一个断点在属性声明上并且断点会在每次 getter / setter 方法调用的时候执行，或者你可以在自己的自定义 setter/getter 设置断点。</li>
<li>允许在一个单独的地方为设置值添加额外的逻辑。</li>
</ul>
<p>你应该倾向于用 getter：</p>
<ul>
<li>它是对未来的变化有扩展能力的（比如，属性是自动生成的）。</li>
<li>它允许子类化。</li>
<li>更简单的debug（比如，允许拿出一个断点在 getter 方法里面，并且看谁访问了特别的 getter</li>
<li>它让意图更加清晰和明确：通过访问 ivar <code>_anIvar</code> 你可以明确的访问 <code>self-&gt;_anIvar</code>.这可能导致问题。在 block 里面访问 ivar （你捕捉并且 retain 了 self，即使你没有明确的看到 self 关键词）。</li>
<li>它自动产生KVO 通知。</li>
<li>在消息发送的时候增加的开销是微不足道的。更多关于性能问题的介绍你可以看 <a href="https://www.bignerdranch.com/blog/should-i-use-a-property-or-an-instance-variable/" target="_blank" rel="external">Should I Use a Property or an Instance Variable?</a>。</li>
</ul>
<h4 id="Init-和-Dealloc"><a href="#Init-和-Dealloc" class="headerlink" title="Init 和 Dealloc"></a>Init 和 Dealloc</h4><p>有一个例外：永远不要在 init 方法（以及其他初始化方法）里面用 getter 和 setter 方法，你应当直接访问实例变量。这样做是为了防止有子类时，出现这样的情况：它的子类最终重载了其 setter 或者 getter 方法，因此导致该子类去调用其他的方法、访问那些处于不稳定状态，或者称为没有初始化完成的属性或者 ivar 。记住一个对象仅仅在 init 返回的时候，才会被认为是达到了初始化完成的状态。</p>
<p>同样在 dealloc 方法中（在 dealloc 方法中，一个对象可以在一个 不确定的状态中）这是同样需要被注意的。</p>
<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6" target="_blank" rel="external">Advanced Memory Management Programming Guide</a> under the self-explanatory section “Don’t Use Accessor Methods in Initializer Methods and dealloc”;</li>
<li><a href="http://adcdownload.apple.com//wwdc_2012/wwdc_2012_session_pdfs/session_413__migrating_to_modern_objectivec.pdf" target="_blank" rel="external">Migrating to Modern Objective-C</a> at WWDC 2012 at slide 27;</li>
<li>in a <a href="https://github.com/NYTimes/objective-c-style-guide/issues/6">pull request</a> form Dave DeLong’s.</li>
</ul>
<p>此外，在 init 中使用 setter 不会很好执行  <code>UIAppearence</code>  代理（参见  <a href="http://petersteinberger.com/blog/2013/uiappearance-for-custom-views/" target="_blank" rel="external">UIAppearance for Custom Views</a> 看更多相关信息)。</p>
<h4 id="点符号"><a href="#点符号" class="headerlink" title="点符号"></a>点符号</h4><p>当使用 setter getter 方法的时候尽量使用点符号。应该总是用点符号来访问以及设置属性。</p>
<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [UIColor orangeColor];</div><div class="line">[UIApplication sharedApplication].delegate;</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[UIColor orangeColor]];</div><div class="line">UIApplication.sharedApplication.delegate;</div></pre></td></tr></table></figure>
<p>使用点符号会让表达更加清晰并且帮助区分属性访问和方法调用</p>
<h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p>推荐按照下面的格式来定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite, copy) NSString *name;</div></pre></td></tr></table></figure>
<p>属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。(译者注：习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作)</p>
<p>你必须使用 <code>nonatomic</code>，除非特别需要的情况。在iOS中，<code>atomic</code>带来的锁特别影响性能。</p>
<p>属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 <code>copy</code> （block 最早在栈里面创建，使用 <code>copy</code>让 block 拷贝到堆里面去）</p>
<p>为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 <code>readonly</code>  并且在类扩展中重新定义通用的属性为 <code>readwrite</code> 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//.h文件中</div><div class="line">@interface MyClass : NSObject</div><div class="line">@property (nonatomic, readonly, strong) NSObject *object;</div><div class="line">@end</div><div class="line">//.m文件中</div><div class="line">@interface MyClass ()</div><div class="line">@property (nonatomic, readwrite, strong) NSObject *object;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyClass</div><div class="line">//Do Something cool</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>描述<code>BOOL</code>属性的词如果是形容词，那么setter不应该带<code>is</code>前缀，但它对应的 getter 访问器应该带上这个前缀，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (assign, getter=isEditable) BOOL editable;</div></pre></td></tr></table></figure>
<p>文字和例子引用自 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="external">Cocoa Naming Guidelines</a>。</p>
<p>在实现文件中应避免使用<code>@synthesize</code>,因为Xcode已经自动为你添加了。</p>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 <code>ZOCPrivate</code>）中定义私有属性，除非你扩展其他类。</p>
<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZOCViewController ()</div><div class="line">@property (nonatomic, strong) UIView *bannerView;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>任何可以用一个可变的对象设置的（(比如 <code>NSString</code>,<code>NSArray</code>,<code>NSURLRequest</code>)）属性的内存管理类型必须是 <code>copy</code> 的。</p>
<p>这是为了确保防止在不明确的情况下修改被封装好的对象的值(译者注：比如执行 array(定义为 copy 的 NSArray 实例) = mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错)。</p>
<p>你应该同时避免暴露在公开的接口中可变的对象，因为这允许你的类的使用者改变类自己的内部表示并且破坏类的封装。你可以提供可以只读的属性来返回你对象的不可变的副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* .h */</div><div class="line">@property (nonatomic, readonly) NSArray *elements</div><div class="line"></div><div class="line">/* .m */</div><div class="line">- (NSArray *)elements &#123;</div><div class="line">  return [self.mutableElements copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="懒加载（Lazy-Loading）"><a href="#懒加载（Lazy-Loading）" class="headerlink" title="懒加载（Lazy Loading）"></a>懒加载（Lazy Loading）</h3><p>当实例化一个对象需要耗费很多资源，或者配置一次就要调用很多配置相关的方法而你又不想弄乱这些方法时，我们需要重写 getter 方法以延迟实例化，而不是在 init 方法里给对象分配内存。通常这种操作使用下面这样的模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (NSDateFormatter *)dateFormatter &#123;</div><div class="line">  if (!_dateFormatter) &#123;</div><div class="line">    _dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];</div><div class="line">        [_dateFormatter setLocale:enUSPOSIXLocale];</div><div class="line">        [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;];//毫秒是SSS，而非SSSSS</div><div class="line">  &#125;</div><div class="line">  return _dateFormatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使这样做在某些情况下很不错，但是在实际这样做之前应当深思熟虑。事实上，这样的做法是可以避免的。下面是使用延迟实例化的争议。</p>
<ul>
<li>getter 方法应该避免副作用。看到 getter 方法的时候，你不会想到会因此创建一个对象或导致副作用，实际上如果调用 getter 方法而不使用其返回值编译器会报警告 “Getter 不应该仅因它产生的副作用而被调用”。</li>
</ul>
<blockquote>
<p>副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。（译者注）</p>
</blockquote>
<ul>
<li>你在第一次访问的时候改变了初始化的消耗，产生了副作用，这会让优化性能变得困难（以及测试）</li>
<li>这个初始化可能是不确定的：比如你期望属性第一次被一个方法访问，但是你改变了类的实现，访问器在你预期之前就得到了调用，这样可以导致问题，特别是初始化逻辑可能依赖于类的其他不同状态的时候。总的来说最好明确依赖关系。</li>
<li>这个行为不是 KVO 友好的。如果 getter 改变了引用，他应该通过一个  KVO 通知来通知改变。当访问 getter 的时候收到一个改变的通知很奇怪。</li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="参数断言"><a href="#参数断言" class="headerlink" title="参数断言"></a>参数断言</h3><p>你的方法可能要求一些参数来满足特定的条件（比如不能为nil），在这种情况下最好使用 <code>NSParameterAssert()</code> 来断言条件是否成立或是抛出一个异常。</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>永远不要在你的私有方法前加上 <code>_</code> 前缀。这个前缀是 Apple 保留的。不要冒重载苹果的私有方法的险。</p>
<h2 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h2><p>当你要实现相等性的时候记住这个约定：你需要同时实现<code>isEqual</code> 和 <code>hash</code>方法。如果两个对象是被<code>isEqual</code>认为相等的，它们的 <code>hash</code> 方法需要返回一样的值。但是如果  <code>hash</code> 返回一样的值，并不能确保他们相等。</p>
<p>这个约定当对象被存储在集合中（如 <code>NSDictionary</code> 和 <code>NSSet</code> 在底层使用 hash 表数据的数据结构）的时候，用来查找这些对象的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCPerson</div><div class="line"></div><div class="line">- (BOOL)isEqual:(id)object &#123;</div><div class="line">    if (self == object) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (![object isKindOfClass:[ZOCPerson class]]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // check objects properties (name and birthday) for equality （检查对象属性（名字和生日）的相等性</div><div class="line">    ...</div><div class="line">    return propertiesMatch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSUInteger)hash &#123;</div><div class="line">    return [self.name hash] ^ [self.birthday hash];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一定要注意 hash 方法不能返回一个常量。这是一个典型的错误并且会导致严重的问题，因为实际上<code>hash</code>方法的返回值会作为对象在 hash 散列表中的 key,这会导致 hash 表 100% 的碰撞。</p>
<p>你总是应该用 <code>isEqualTo&lt;#class-name-without-prefix#&gt;:</code> 这样的格式实现一个相等性检查方法。如果你这样做，会优先调用这个方法来避免上面的类型检查。</p>
<p>一个完整的 isEqual 方法应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (BOOL)isEqual:(id)object &#123;</div><div class="line">    if (self == object) &#123;</div><div class="line">      return YES;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (![object isKindOfClass:[ZOCPerson class]]) &#123;</div><div class="line">      return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [self isEqualToPerson:(ZOCPerson *)object];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isEqualToPerson:(Person *)person &#123;</div><div class="line">    if (!person) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BOOL namesMatch = (!self.name &amp;&amp; !person.name) ||</div><div class="line">                       [self.name isEqualToString:person.name];</div><div class="line">    BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) ||</div><div class="line">                           [self.birthday isEqualToDate:person.birthday];</div><div class="line"></div><div class="line">  return haveEqualNames &amp;&amp; haveEqualBirthdays;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>译者注：<br>一般而言我们会直接调用自定义的<code>isEqualTo__ClassName__:</code>方法，对类的实例判等。</p>
<p>像相等性的开篇已经提到的那样，这里应该复写<code>isEqual:</code>方法，因为NSObject的<code>isEqual:</code>方法显然不会考虑我们自定义类的类型判断及属性的相等性。当我们自定义的类的对象处在无序集合中被查找时，会自动调用<code>isEqual:</code>。同样的该类的<code>hash</code>方法，也会在集合查找对象的时候被使用，我们也可以通过复写<code>hash</code>方法以达到用自己的标准来判定对象是否<code>hash</code>等同。</p>
<p>我们实现的<code>hash</code>方法应该建立在系统提供的各种对象的<code>hash</code>方法之上（像开篇的例程那样）。不推荐自己去实现某种<code>hash</code>算法来替代系统提供的<code>hash</code>算法，这一般而言会大大影响性能或者准确性，系统提供的<code>hash</code>算法已经经过无数次修缮，足以满足你的要求。</p>
</blockquote>
<p>一个对象实例的 <code>hash</code> 计算结果应该是确定的。当它被加入到一个容器对象（比如 <code>NSArray</code>, <code>NSSet</code>, 或者 <code>NSDictionary</code>）的时候这是很重要的，否则行为会无法预测（所有的容器对象使用对象的 hash 来查找或者实施特别的行为，如确定唯一性）这也就是说，应该用不可变的属性来计算 hash 值，或者，最好保证对象是不可变的。</p>
<h1 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h1><p>虽然我们知道这样写很丑, 但是我们应该要在我们的 category 方法前加上自己的小写前缀以及下划线，比如<code>- (id)zoc_myCategoryMethod</code>。 这种实践同样<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW4" target="_blank" rel="external">被苹果推荐</a>。</p>
<p>这是非常必要的。因为如果在扩展的 category 或者其他 category 里面已经使用了同样的方法名，会导致不可预计的后果。实际上，实际被调用的是最后被加载的那个 category 中方法的实现(译者注：如果导入的多个 category 中有一些同名的方法导入到类里时，最终调用哪个是由编译时的加载顺序来决定的，最后一个加载进来的方法会覆盖之前的方法)。</p>
<p>如果想要确认你的分类方法没有覆盖其他实现的话，可以把环境变量 OBJC_PRINT_REPLACED_METHODS 设置为 YES，这样那些被取代的方法名字会打印到 Console 中。现在 LLVM 5.1  不会为此发出任何警告和错误提示，所以自己小心不要在分类中重载方法。</p>
<p>一个好的实践是在 category 名中使用前缀。</p>
<p><strong> 例子 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSDate (ZOCTimeExtensions)</div><div class="line">- (NSString *)zoc_timeAgoShort;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong> 不要这样 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSDate (ZOCTimeExtensions)</div><div class="line">- (NSString *)timeAgoShort;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>分类可以用来在头文件中定义一组功能相似的方法。这是在 Apple的 Framework 也很常见的一个实践（下面例子的取自<code>NSDate</code> 头文件）。我们也强烈建议在自己的代码中这样使用。</p>
<p>我们的经验是，创建一组分类对以后的重构十分有帮助。一个类的接口增加的时候，可能意味着你的类做了太多事情，违背了类的单一功能原则。</p>
<p>之前创造的方法分组可以用来更好地进行不同功能的表示，并且把类打破在更多自我包含的组成部分里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface NSDate : NSObject &lt;NSCopying, NSSecureCoding&gt;</div><div class="line"></div><div class="line">@property (readonly) NSTimeInterval timeIntervalSinceReferenceDate;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSDate (NSDateCreation)</div><div class="line"></div><div class="line">+ (instancetype)date;</div><div class="line">+ (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;</div><div class="line">+ (instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;</div><div class="line">+ (instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;</div><div class="line">+ (instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</div><div class="line">// ...</div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h1><p>在 Objective-C 的世界里面经常错过的一个东西是抽象接口。接口（interface）这个词通常指一个类的 <code>.h</code> 文件，但是它在 Java 程序员眼里有另外的含义： 一系列不依赖具体实现的方法的定义。(译者注：在OC中，类的接口对应在.m文件中都会有具体的实现，但Java中接口更接近于OC中的抽象接口或者说协议(protocol))</p>
<p>在 Objective-C 里是通过 protocol 来实现抽象接口的。因为历史原因，protocol （使用方法类似java的接口）并没有大量地在Objective-C的代码中使用也没有在社区中普及(指的是那种像Java程序员使用接口那样来使用protocol的方式)。一个主要原因是大多数的 Apple 开发的代码没有采用这种的方式，而几乎所有的开发者都是遵从 Apple 的模式以及指南。Apple 几乎只是在委托模式下使用 protocol。</p>
<p>但是抽象接口的概念很强大，在计算机科学的历史中颇有渊源，没有理由不在 Objective-C 中使用。</p>
<p>这里通过一个具体的例子来解释 protocol 的强大力量（用作抽象接口）：把非常糟糕的设计的架构改造为一个良好的可复用的代码。</p>
<p>这个例子是在实现一个 RSS 阅读器（它可是经常在技术面试中作为一个测试题呢）。</p>
<p>要求很简单：在TableView中展示一个远程的RSS订阅。</p>
<p>一个幼稚的方法是创建一个 <code>UITableViewController</code> 的子类，并且把所有的检索订阅数据，解析以及展示的逻辑放在一起，或者说是一个 MVC (Massive View Controller)。这可以跑起来，但是它的设计非常糟糕，不过它足够过一些要求不高的面试了。</p>
<p>最小的步骤是遵从单一功能原则，创建至少两个组成部分来完成这个任务：</p>
<ul>
<li>一个 feed 解析器来解析搜集到的结果</li>
<li>一个 feed 阅读器来显示结果</li>
</ul>
<p>这些类的接口可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ZOCFeedParser : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;</div><div class="line">@property (nonatomic, strong) NSURL *url;</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL *)url;</div><div class="line"></div><div class="line">- (BOOL)start;</div><div class="line">- (void)stop;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ZOCTableViewController : UITableViewController</div><div class="line"></div><div class="line">- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>ZOCFeedParser</code> 用 <code>NSURL</code> 进行初始化，来获取 RSS 订阅（在这之下可能会使用 NSXMLParser 和 NSXMLParserDelegate 创建有意义的数据），<code>ZOCTableViewController</code> 会用这个 parser 来进行初始化。 我们希望它显示 parser 接受到的值并且我们用下面的 protocol 实现委托：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@protocol ZOCFeedParserDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)feedParserDidStart:(ZOCFeedParser *)parser;</div><div class="line">- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;</div><div class="line">- (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item;</div><div class="line">- (void)feedParserDidFinish:(ZOCFeedParser *)parser;</div><div class="line">- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我要说，这是一个处理RSS业务的完全合理而恰当的protocol。这个ViewController在Public接口中将遵循这个protocol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;</div></pre></td></tr></table></figure>
<p>最后创建的代码是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSURL *feedURL = [NSURL URLWithString:@&quot;http://www.bbc.co.uk/feed.rss&quot;];</div><div class="line"></div><div class="line">ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];</div><div class="line"></div><div class="line">ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];</div><div class="line">feedParser.delegate = tableViewController;</div></pre></td></tr></table></figure>
<p>到目前你可能觉得你的代码还是不错的，但是有多少代码是可以有效复用的呢？view controller 只能处理 <code>ZOCFeedParser</code> 类型的对象： 从这点来看我们只是把代码分离成了两个组成部分，而没有做任何其他有价值的事情。</p>
<p>view controller 的职责应该是“显示某些东西提供的内容”，但是如果我们只允许传递<code>ZOCFeedParser</code>的话，就不是这样的了。这就体现了需要传递给 view controller 一个更泛型的对象的需求。</p>
<p>我们使用  <code>ZOCFeedParserProtocol</code> 这个 protocol (在 ZOCFeedParserProtocol.h 文件里面，同时文件里也有 <code>ZOCFeedParserDelegate</code> )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@protocol ZOCFeedParserProtocol &lt;NSObject&gt;</div><div class="line"></div><div class="line">@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;</div><div class="line">@property (nonatomic, strong) NSURL *url;</div><div class="line"></div><div class="line">- (BOOL)start;</div><div class="line">- (void)stop;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ZOCFeedParserDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item;</div><div class="line">- (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意这个代理 protocol 现在处理响应我们新的 protocol， 而且 ZOCFeedParser 的接口文件更加精炼了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt;</div><div class="line"></div><div class="line">- (id)initWithURL:(NSURL *)url;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>因为 <code>ZOCFeedParser</code> 实现了 <code>ZOCFeedParserProtocol</code>，它需要实现所有的<code>required</code>方法。<br>从这点来看 viewController能接受任何遵循该协议的对象，只要确保所有的对象都会响应<code>start</code>和<code>stop</code>方法并通过<code>delegate</code>属性提供信息(译者注：因为protocol默认情况下所有的方法定义都是<code>required</code>的)。对指定的对象而言，这就是viewController所要知道的一切,且不需要知道其实现的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码片段的改变看起来不多，但是有了一个巨大的提升。view controller 将基于协议而不是具体的实现来工作。这带来了以下的优点：</p>
<ul>
<li>view controller 现在可以接收通过<code>delegate</code>属性提供信息的任意对象：可以是  RSS 远程解析器，或者本地解析器，或是一个读取其他远程或者本地数据的服务</li>
<li><code>ZOCFeedParser</code> 和 <code>ZOCFeedParserDelegate</code> 可以被其他组成部分复用</li>
<li><code>ZOCViewController</code> （UI逻辑部分）可以被复用</li>
<li>测试更简单了，因为可以用 mock 对象来达到 protocol 预期的效果</li>
</ul>
<p>当实现一个 protocol 你总应该坚持 <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="external">里氏替换原则</a>。这个原则是：你应该可以取代任意接口（也就是Objective-C里的”protocol”）实现，而不用改变客户端或者相关实现。</p>
<p>此外，这也意味着<code>protocol</code>不该关心类的实现细节；设计protocol的抽象表述时应非常用心，并且要牢记它和它背后的实现是不相干的，真正重要的是协议（这个暴露给使用者的抽象表述）。</p>
<p>任何在未来可复用的设计，无形当中可以提高代码质量，这也应该一直是程序员的追求。是否这样设计代码，就是大师和菜鸟的区别。</p>
<p>最后的代码可以在<a href="https://github.com/KevinHM/ADBFeedReader">这里</a> 找到。</p>
<h1 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h1><p>当你定义你自己的 <code>NSNotification</code> 的时候你应该把你的通知的名字定义为一个字符串常量，就像你暴露给其他类的其他字符串常量一样。你应该在公开的接口文件中将其声明为 <code>extern</code> 的， 并且在对应的实现文件里面定义。</p>
<p>因为你在头文件中暴露了符号，所以你应该按照统一的命名空间前缀法则，用类名前缀作为这个通知名字的前缀。</p>
<p>同时，用一个 Did/Will 这样的动词以及用 “Notifications” 后缀来命名这个通知也是一个好的实践。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Foo.h</div><div class="line">extern NSString * const ZOCFooDidBecomeBarNotification</div><div class="line"></div><div class="line">// Foo.m</div><div class="line">NSString * const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;;</div></pre></td></tr></table></figure>
<h1 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h1><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li>缩进使用 4 个空格。 永远不要使用  tab, 确保你在 Xcode 的设置里面是这样设置的。</li>
<li>方法的大括号和其他的大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等) 总是在同一行开始，在新起一行结束。</li>
</ul>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (user.isHappy) &#123;</div><div class="line">    //Do something</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    //Do something else</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (user.isHappy)</div><div class="line">&#123;</div><div class="line">  //Do something</div><div class="line">&#125; else &#123;</div><div class="line">  //Do something else</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空格应该用来分离功能，但是通常不同的功能应该用新的方法来定义。</li>
<li>优先使用 auto-synthesis。但是如果必要的话， <code>@synthesize</code> and <code>@dynamic</code></li>
<li>在实现文件中的声明应该新起一行。</li>
<li>应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。</li>
</ul>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1.0</div><div class="line">                 animations:^&#123;</div><div class="line">                     // something</div><div class="line">                 &#125;</div><div class="line">                 completion:^(BOOL finished) &#123;</div><div class="line">                     // something</div><div class="line">                 &#125;];</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">    // something</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    // something</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果自动对齐让可读性变得糟糕，那么应该在之前把 block 定义为变量，或者重新考虑你的代码签名设计。</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>本指南关注代码显示效果以及在线浏览的可读性，所以换行是一个重要的主题。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];</div></pre></td></tr></table></figure>
<p>一个像上面的长行的代码在第二行以一个间隔（2个空格）延续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.productsRequest = [[SKProductsRequest alloc]</div><div class="line">  initWithProductIdentifiers:productIdentifiers];</div></pre></td></tr></table></figure>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>在以下的地方使用 <a href="https://en.wikipedia.org/wiki/Indent_style#K.26R_style" target="_blank" rel="external">Egyptian风格 括号</a> （译者注：又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格。关于为什么叫做 Egyptian Brackets，可以参考 <a href="http://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="external">http://blog.codinghorror.com/new-programming-jargon/</a> )</p>
<ul>
<li>控制语句 (if-else, for, switch)</li>
</ul>
<p>非 Egyptian 括号可以用在：</p>
<ul>
<li>类的实现（如果存在)</li>
<li>方法的实现</li>
</ul>
<h1 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h1><p><a href="http://nshipster.com/pragma/" target="_blank" rel="external">来自</a> Mattt Thompson</p>
<blockquote>
<p>code organization is a matter of hygiene  (代码组织是卫生问题)</p>
</blockquote>
<p>我们十分赞成这句话。清晰地组织代码和规范地进行定义, 是你对自己以及其他阅读代码的人的尊重。</p>
<h2 id="利用代码块"><a href="#利用代码块" class="headerlink" title="利用代码块"></a>利用代码块</h2><p>一个 GCC 非常模糊的特性，以及 Clang 也有的特性是，代码块如果在闭合的圆括号内的话，会返回最后语句的值</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSURL *url = (&#123;</div><div class="line">    NSString *urlString = [NSString stringWithFormat:@&quot;%@/%@&quot;, baseURLString, endpoint];</div><div class="line">    [NSURL URLWithString:urlString];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><h3 id="Pragma-Mark"><a href="#Pragma-Mark" class="headerlink" title="Pragma Mark"></a>Pragma Mark</h3><p><code>#pragma mark -</code>  是一个在类内部组织代码并且帮助你分组方法实现的好办法。 我们建议使用  <code>#pragma mark -</code> 来分离:</p>
<ul>
<li>不同功能组的方法</li>
<li>protocols 的实现</li>
<li>对父类方法的重写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)dealloc &#123; /* ... */ &#125;</div><div class="line">- (instancetype)init &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - View Lifecycle （View 的生命周期）</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123; /* ... */ &#125;</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123; /* ... */ &#125;</div><div class="line">- (void)didReceiveMemoryWarning &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Custom Accessors （自定义访问器）</div><div class="line"></div><div class="line">- (void)setCustomProperty:(id)value &#123; /* ... */ &#125;</div><div class="line">- (id)customProperty &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - IBActions  </div><div class="line"></div><div class="line">- (IBAction)submitData:(id)sender &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Public</div><div class="line"></div><div class="line">- (void)publicMethod &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Private</div><div class="line"></div><div class="line">- (void)zoc_privateMethod &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - ZOCSuperclass</div><div class="line"></div><div class="line">// ... 重载来自 ZOCSuperclass 的方法</div><div class="line"></div><div class="line">#pragma mark - NSObject</div><div class="line"></div><div class="line">- (NSString *)description &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>
<p>上面的标记能明显分离和组织代码。你还可以用  cmd+Click 来快速跳转到符号定义地方。<br>但是小心，即使 paragma mark 是一门手艺，但是它不是让你类里面方法数量增加的一个理由：类里面有太多方法说明类做了太多事情，需要考虑重构了。</p>
<h3 id="关于-pragma"><a href="#关于-pragma" class="headerlink" title="关于 pragma"></a>关于 pragma</h3><p>在 <a href="http://raptureinvenice.com/pragmas-arent-just-for-marks/" target="_blank" rel="external">http://raptureinvenice.com/pragmas-arent-just-for-marks/</a> 有很好的关于 pragma 的讨论了，在这边我们再做部分说明。</p>
<p>大多数 iOS 开发者平时并没有和很多编译器选项打交道。一些选项是对控制严格检查（或者不检查）你的代码或者错误的。有时候，你想要用 pragma 直接产生一个异常，临时打断编译器的行为。</p>
<p>当你使用ARC的时候，编译器帮你插入了内存管理相关的调用。但是这样可能产生一些烦人的事情。比如你使用  <code>NSSelectorFromString</code>  来动态地产生一个 selector 调用的时候，ARC不知道这个方法是哪个并且不知道应该用那种内存管理方法，你会被提示 <code>performSelector may cause a leak because its selector is unknown（执行 selector 可能导致泄漏，因为这个 selector 是未知的）</code>.</p>
<p>如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line"></div><div class="line">[myObj performSelector:mySelector withObject:name];</div><div class="line"></div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>
<p>注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。</p>
<p>全部的选项可以在 <a href="http://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="external">The Clang User’s Manual</a>  找到并且学习。</p>
<h3 id="忽略没用使用变量的编译警告"><a href="#忽略没用使用变量的编译警告" class="headerlink" title="忽略没用使用变量的编译警告"></a>忽略没用使用变量的编译警告</h3><p>告诉你申明的变量它将不会被使用，这种做法很有用。大多数情况下，你希望移除这些引用来（稍微地）提高性能，但是有时候你希望保留它们。为什么？或许它们以后有用，或者有些特性只是暂时移除。无论如何，一个消除这些警告的好方法是用相关语句进行注解，使用 <code>#pragma unused()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)giveMeFive</div><div class="line">&#123;</div><div class="line">    NSString *foo;</div><div class="line">    #pragma unused (foo)</div><div class="line"></div><div class="line">    return 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你的代码不用任何编译警告了。注意你的 pragma 需要标记到问题代码之下。</p>
<h2 id="明确编译器警告和错误"><a href="#明确编译器警告和错误" class="headerlink" title="明确编译器警告和错误"></a>明确编译器警告和错误</h2><p>编译器是一个机器人，它会标记你代码中被 Clang 规则定义为错误的地方。但是，你总是比 Clang 更聪明。通常，你会发现一些讨厌的代码会导致这个问题，但是暂时却解决不了。你可以这样明确一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor</div><div class="line">&#123;</div><div class="line">    #error Whoa, buddy, you need to check for zero here!</div><div class="line">    return (dividend / divisor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似的，你可以这样标明一个警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (float)divide:(float)dividend by:(float)divisor</div><div class="line">&#123;</div><div class="line">    #warning Dude, don&apos;t compare floating point numbers like this!</div><div class="line">    if (divisor != 0.0) &#123;</div><div class="line">        return (dividend / divisor);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return NAN;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串文档"><a href="#字符串文档" class="headerlink" title="字符串文档"></a>字符串文档</h2><p>所有重要的方法，接口，分类以及协议定义应该有伴随的注释来解释它们的用途以及如何使用。更多的例子可以看 Google 代码风格指南中的 <a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml#File_Comments" target="_blank" rel="external">File and Declaration Comments</a>。</p>
<p>简而言之：有长的和短的两种字符串文档。</p>
<p>短文档适用于单行的文件，包括注释斜杠。它适合简短的函数，特别是（但不仅仅是）非 public 的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// Return a user-readable form of a Frobnozz, html-escaped.</div></pre></td></tr></table></figure>
<p>文本应该用一个动词 (“return”)  而不是 “returns” 这样的描述。</p>
<p>如果描述超过一行，应改用长字符串文档：</p>
<ul>
<li>以<code>/**</code>开始</li>
<li>换行写一句总结的话，以<code>?或者!或者.</code>结尾。</li>
<li>空一行</li>
<li>在与第一行对齐的位置开始写剩下的注释</li>
<li>最后用<code>*/</code>结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> This comment serves to demonstrate the format of a docstring.</div><div class="line"></div><div class="line"> Note that the summary line is always at most one line long, and</div><div class="line"> after the opening block comment, and each line of text is preceded</div><div class="line"> by a single space.</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>一个函数必须有一个字符串文档，除非它符合下面的所有条件：</p>
<ul>
<li>非公开</li>
<li>很短</li>
<li>显而易见</li>
</ul>
<p>字符串文档应该描述函数的调用符号和语义，而不是它如何实现。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当它需要的时候，注释应该用来解释特定的代码做了什么。所有的注释必须被持续维护或者干脆就删掉。</p>
<p>块注释应该被避免，代码本身应该尽可能就像文档一样表示意图，只需要很少的打断注释。  <em>例外： 这不能适用于用来产生文档的注释</em></p>
<h3 id="头文档"><a href="#头文档" class="headerlink" title="头文档"></a>头文档</h3><p>一个类的文档应该只在 .h 文件里用 Doxygen/AppleDoc 的语法书写。 方法和属性都应该提供文档。</p>
<p><strong>例子: </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  Designated initializer.</div><div class="line"> *</div><div class="line"> *  @param  store  The store for CRUD operations.</div><div class="line"> *  @param  searchService The search service used to query the store.</div><div class="line"> *</div><div class="line"> *  @return A ZOCCRUDOperationsStore object.</div><div class="line"> */</div><div class="line">- (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store</div><div class="line">                          searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService;</div></pre></td></tr></table></figure>
<h1 id="对象间的通讯"><a href="#对象间的通讯" class="headerlink" title="对象间的通讯"></a>对象间的通讯</h1><p>对象之间需要通信，这也是所有软件的基础。再非凡的软件也需要通过对象通信来完成复杂的目标。本章将深入讨论一些设计概念，以及如何依据这些概念来设计出良好的架构。</p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>Block 是 Objective-C 版本的 lambda 或者 closure（闭包）。</p>
<p>使用 block 定义异步接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)downloadObjectsAtPath:(NSString *)path</div><div class="line">                   completion:(void(^)(NSArray *objects, NSError *error))completion;</div></pre></td></tr></table></figure>
<p>当你定义一个类似上面的接口的时候，尽量使用一个单独的 block 作为接口的最后一个参数。把需要提供的数据和错误信息整合到一个单独 block 中，比分别提供成功和失败的 block 要好。</p>
<p>以下是你应该这样做的原因：</p>
<ul>
<li>通常这成功处理和失败处理会共享一些代码（比如让一个进度条或者提示消失）；</li>
<li>Apple 也是这样做的，与平台一致能够带来一些潜在的好处；</li>
<li>block 通常会有多行代码，如果不作为最后一个参数放在后面的话，会打破调用点；</li>
<li>使用多个 block 作为参数可能会让调用看起来显得很笨拙，并且增加了复杂性。</li>
</ul>
<p>看上面的方法，完成处理的 block 的参数很常见：第一个参数是调用者希望获取的数据，第二个是错误相关的信息。这里需要遵循以下两点：</p>
<ul>
<li>若 <code>objects</code> 不为 nil，则 <code>error</code> 必须为 nil</li>
<li>若 <code>objects</code> 为 nil，则 <code>error</code> 必须不为 nil</li>
</ul>
<p>因为调用者更关心的是实际的数据，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)downloadObjectsAtPath:(NSString *)path</div><div class="line">                   completion:(void(^)(NSArray *objects, NSError *error))completion &#123;</div><div class="line">    if (objects) &#123;</div><div class="line">        // do something with the data</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // some error occurred, &apos;error&apos; variable should not be nil by contract</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，Apple 提供的一些同步接口在成功状态下向 error 参数（如果非 NULL) 写入了垃圾值，所以检查 error 的值可能出现问题。</p>
<h3 id="深入-Block"><a href="#深入-Block" class="headerlink" title="深入 Block"></a>深入 Block</h3><p>一些关键点：</p>
<ul>
<li>block 是在栈上创建的</li>
<li>block 可以复制到堆上</li>
<li>Block会捕获栈上的变量(或指针)，将其复制为自己私有的const(变量)。</li>
<li>(如果在Block中修改Block块外的)栈上的变量和指针，那么这些变量和指针必须用<code>__block</code>关键字申明(译者注：否则就会跟上面的情况一样只是捕获他们的瞬时值)。</li>
</ul>
<p>如果 block 没有在其他地方被保持，那么它会随着栈生存并且当栈帧（stack frame）返回的时候消失。仅存在于栈上时，block对对象访问的内存管理和生命周期没有任何影响。</p>
<p>如果 block 需要在栈帧返回的时候存在，它们需要明确地被复制到堆上，这样，block 会像其他 Cocoa 对象一样增加引用计数。当它们被复制的时候，它会带着它们的捕获作用域一起，retain 他们所有引用的对象。</p>
<p>如果一个 block引用了一个栈变量或指针，那么这个block初始化的时候会拥有这个变量或指针的const副本，所以(被捕获之后再在栈中改变这个变量或指针的值)是不起作用的。(译者注：所以这时候我们在block中对这种变量进行赋值会编译报错:<code>Variable is not assignable(missing __block type specifier)</code>，因为他们是副本而且是const的.具体见下面的例程)。</p>
<p>当一个 block 被复制后，<code>__block</code> 声明的栈变量的引用被复制到了堆里，复制完成之后，无论是栈上的block还是刚刚产生在堆上的block(栈上block的副本)都会引用该变量在堆上的副本。</p>
<p>(下面代码是译者加的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">CGFloat blockInt = 10;</div><div class="line">void (^playblock)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;blockInt = %zd&quot;, blockInt);</div><div class="line">&#125;;</div><div class="line">blockInt ++;</div><div class="line">playblock();</div><div class="line">...</div><div class="line"></div><div class="line">//结果为:blockInt = 10</div></pre></td></tr></table></figure>
<p>用 LLDB 来展示 block 是这样子的：</p>
<p><img src="./images/blocks_debugger.png" alt=""></p>
<p>最重要的事情是 <code>__block</code> 声明的变量和指针在 block 里面是作为显示操作真实值/对象的结构来对待的。</p>
<p>block 在 Objective-C 的 runtime(运行时) 里面被当作一等公民对待：他们有一个 <code>isa</code> 指针，一个类也是用 <code>isa</code> 指针在Objective-C 运行时来访问方法和存储数据的。在非 ARC 环境肯定会把它搞得很糟糕，并且悬挂指针会导致 crash。<code>__block</code> 仅仅对 block 内的变量起作用，它只是简单地告诉 block：</p>
<blockquote>
<p>嗨，这个指针或者原始的类型依赖它们在的栈。请用一个栈上的新变量来引用它。我是说，请对它进行双重解引用，不要 retain 它。<br>谢谢，哥们。</p>
</blockquote>
<p>如果在定义之后但是 block 没有被调用前，对象被释放了，那么 block 的执行会导致 crash。 <code>__block</code>  变量不会在 block 中被持有，最后… 指针、引用、解引用以及引用计数变得一团糟。</p>
<h3 id="self-的循环引用"><a href="#self-的循环引用" class="headerlink" title="self 的循环引用"></a>self 的循环引用</h3><p>当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 <code>weak</code> 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify <a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h">这里有更为详细的说明</a>） 此外，把持有 block 的属性设置为 nil (比如 <code>self.completionBlock = nil</code>) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。</p>
<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self) weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [self doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>多个语句的例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    __strong __typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">        [strongSelf doSomethingWithData:data];</div><div class="line">        [strongSelf doSomethingWithData:data];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">__strong __typeof(weakSelf)strongSelf = weakSelf;</div></pre></td></tr></table></figure>
<p>这里我们来讨论下 block 里面的 self 的 <code>__weak</code> 和 <code>__strong</code>  限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。</p>
<ol>
<li>直接在 block 里面使用关键词 self</li>
<li>在 block 外定义一个 <code>__weak</code> 的 引用到 self，并且在 block 里面使用这个弱引用</li>
<li>在 block 外定义一个 <code>__weak</code> 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 <code>__strong</code>  的引用。</li>
</ol>
<p><strong>方案 1. 直接在 block 里面使用关键词 <code>self</code></strong></p>
<p>如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW4" target="_blank" rel="external">copied</a>  但是为了简单我们可以忽略这个）。一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t completionBlock = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:completionHandler];</div></pre></td></tr></table></figure>
<p>没啥大不了。但是如果通过一个属性中的 <code>self</code> 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.completionHandler = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:self.completionHandler];</div></pre></td></tr></table></figure>
<p>这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用）</div></pre></td></tr></table></figure>
<p>所以 <code>__weak</code> 就有用武之地了。</p>
<p><strong>方案 2. 在 block 外定义一个 <code>__weak</code> 的 引用到 self，并且在 block 里面使用这个弱引用</strong></p>
<p>这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">self.completionHandler = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, weakSelf);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:self.completionHandler];</div></pre></td></tr></table></figure>
<p>这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。</p>
<p>考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。</p>
<p>下面的更有意思。</p>
<p><strong>方案 3. 在 block 外定义一个 <code>__weak</code> 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 <code>__strong</code>  的引用</strong></p>
<p>你可能会想，首先，这是避免 retain cycle  警告的一个技巧。</p>
<p>这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain.</p>
<p><a href="https://developer.apple.com/library/mac/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple 文档</a> 中表示 “为了 non-trivial cycles ，你应该这样” ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">// ...</div><div class="line">MyViewController * __weak weakMyController = myController;</div><div class="line">myController.completionHandler =  ^(NSInteger result) &#123;</div><div class="line">    MyViewController *strongMyController = weakMyController;</div><div class="line">    if (strongMyController) &#123;</div><div class="line">        // ...</div><div class="line">        [strongMyController dismissViewControllerAnimated:YES completion:nil];</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // Probably nothing...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为  <code>assign</code> 或者 <code>unsafe_unretained</code> 的，来允许对象在 block 被传递之后被销毁。</p>
<p>我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 <code>__weak</code>/<code>__strong</code></p>
<p>总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。</p>
<p>还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。</p>
<p>虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 <a href="https://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/" target="_blank" rel="external">一</a> <a href="http://blog.random-ideas.net/?p=160" target="_blank" rel="external">些</a> <a href="http://stackoverflow.com/questions/7904568/disappearing-reference-to-self-in-a-block-under-arc" target="_blank" rel="external">的</a> <a href="http://stackoverflow.com/questions/12218767/objective-c-blocks-and-memory-management" target="_blank" rel="external">在线</a> <a href="https://github.com/AFNetworking/AFNetworking/issues/807">参考</a>,  <a href="https://twitter.com/mattjgalloway" target="_blank" rel="external">Matt Galloway</a> 的 (<a href="http://www.effectiveobjectivec.com/" target="_blank" rel="external">Effective Objective-C 2.0</a> 和 <a href="http://www.amazon.it/Pro-Multithreading-Memory-Management-Ios/dp/1430241160" target="_blank" rel="external">Pro Multithreading and Memory Management for iOS and OS X</a> ，大多数开发者始终没有弄清楚概念。</p>
<p>在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子：</p>
<p><strong>方案 1. 直接在 block 里面使用关键词 <code>self</code></strong></p>
<p>如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain</p>
<p><strong>方案 2. 在 block 外定义一个 <code>__weak</code> 的 引用到 self，并且在 block 里面使用这个弱引用</strong></p>
<p>不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。</p>
<p>block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成nil)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">dispatch_block_t block =  ^&#123;</div><div class="line">    [weakSelf doSomething]; // weakSelf != nil</div><div class="line">    // preemption, weakSelf turned nil</div><div class="line">    [weakSelf doSomethingElse]; // weakSelf == nil</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>方案 3. 在 block 外定义一个 <code>__weak</code> 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 <code>__strong</code>  的引用。</strong></p>
<p>不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">myObj.myBlock =  ^&#123;</div><div class="line">    __strong typeof(self) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">      [strongSelf doSomething]; // strongSelf != nil</div><div class="line">      // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的)</div><div class="line">      [strongSelf doSomethingElse]; // strongSelf != nil</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // Probably nothing...</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在ARC条件中，如果尝试用 <code>-&gt;</code> 符号访问一个实例变量，编译器会给出非常清晰的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 __weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性)</div></pre></td></tr></table></figure>
<p>可以用下面的代码展示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">myObj.myBlock =  ^&#123;</div><div class="line">    id localVal = weakSelf-&gt;someIVar;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在最后</p>
<ul>
<li><p><strong>方案 1</strong>: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。</p>
</li>
<li><p><strong>方案 2</strong>:  当 block 被声明为一个 property 的时候使用。</p>
</li>
<li><p><strong>方案 3</strong>: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。</p>
</li>
</ul>
<h2 id="委托和数据源"><a href="#委托和数据源" class="headerlink" title="委托和数据源"></a>委托和数据源</h2><p><a href="https://www.wikiwand.com/zh/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">委托模式</a> 是 Apple 的框架里面使用广泛的模式，同时它是四人帮的书“设计模式”中的重要模式之一。委托代理模式是单向的，消息的发送方（委托方）需要知道接收方（代理方）是谁，反过来就没有必要了。对象之间耦合较松，发送方仅需知道它的代理方是否遵守相关 protocol 即可。</p>
<p>本质上，委托代理模式仅需要代理方提供一些回调方法，即代理方需要实现一系列空返回值的方法。</p>
<p>不幸的是 Apple 的 API 并没有遵守这个原则，开发者也效仿 Apple 进入了一个误区。典型的例子就是 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UITableViewDelegate_Protocol/Reference/Reference.html" target="_blank" rel="external">UITableViewDelegate</a> 协议。</p>
<p>它的一些方法返回 void 类型，就像我们所说的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;</div></pre></td></tr></table></figure>
<p>但是其他的就不是那么回事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;</div></pre></td></tr></table></figure>
<p>当委托者询问代理者一些信息的时候，这就暗示着信息是从代理者流向委托者而非相反的过程。 这(译者注：委托者 ==Data==&gt; 代理者)是概念性的不同，须用另一个新的名字来描述这种模式：数据源模式。</p>
<p>可能有人会说 Apple 有一个 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UITableViewDataSource_Protocol/Reference/Reference.html" target="_blank" rel="external">UITableViewDataSouce</a>  protocol 来做这个（虽然使用委托模式的名字），但是实际上它的方法是用来提供真实的数据应该如何被展示的信息的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;</div></pre></td></tr></table></figure>
<p>此外，以上两个方法 Apple 混合了展示层和数据层，这显的非常糟糕，但是很少的开发者感到糟糕。而且我们在这里把空返回值和非空返回值的方法都天真地叫做委托方法。</p>
<p>为了分离概念，我们应该这样做：</p>
<ul>
<li>委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。</li>
<li>数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。</li>
</ul>
<p>这个是实际的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@class ZOCSignUpViewController;</div><div class="line"></div><div class="line">@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;</div><div class="line">- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;</div><div class="line">- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface ZOCSignUpViewController : UIViewController</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDelegate&gt; delegate;</div><div class="line">@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDataSource&gt; dataSource;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>代理方法必须以调用者(即委托者)作为第一个参数，就像上面的例子一样。否则代理者无法区分不同的委托者实例。换句话说，调用者(委托者)没有被传递给代理，那就没有方法让代理处理两个不同的委托者，所以下面这种写法人神共怒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)calculatorDidCalculateValue:(CGFloat)value;</div></pre></td></tr></table></figure>
<p>默认情况下，代理者需要实现 protocol 的方法。可以用<code>@required</code> 和  <code>@optional</code> 关键字来标记方法是否是必要的还是可选的(默认是 <code>@required</code>: 必需的)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;</div><div class="line">@required</div><div class="line">- (void)signUpViewController:(ZOCSignUpViewController *)controller didProvideSignUpInfo:(NSDictionary *)dict;</div><div class="line">@optional</div><div class="line">- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>对于可选的方法，委托者必须在发送消息前检查代理是否确实实现了特定的方法（否则会 crash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123;</div><div class="line">    [self.delegate signUpViewControllerDidPressSignUpButton:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>有时候你可能需要重载代理方法。考虑有两个 UIViewController 子类的情况：UIViewControllerA 和 UIViewControllerB，有下面的类继承关系。</p>
<p><code>UIViewControllerB &lt; UIViewControllerA &lt; UIViewController</code></p>
<p><code>UIViewControllerA</code> 遵从 <code>UITableViewDelegate</code> 并且实现了 <code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</code>.</p>
<p>你可能会想要在 <code>UIViewControllerB</code> 中提供一个不同的实现，这个实现可能是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    CGFloat retVal = 0;</div><div class="line">    if ([super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123;</div><div class="line">        retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath];</div><div class="line">    &#125;</div><div class="line">    return retVal + 10.0f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果超类(<code>UIViewControllerA</code>)没有实现这个方法呢？此时调用<code>[super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]</code>方法，将使用 NSObject 的实现，在 <code>self</code> 上下文深入查找并且明确 <code>self</code> 实现了这个方法（因为 <code>UITableViewControllerA</code> 遵从 <code>UITableViewDelegate</code>），但是应用将在下一行发生崩溃，并提示如下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[UIViewControllerB tableView:heightForRowAtIndexPath:]: unrecognized selector sent to instance 0x8d82820&apos;</div><div class="line"></div><div class="line">*** 由于未捕获异常 `NSInvalidArgumentException(无效的参数异常)`导致应用终止，理由是：向实例 ox8d82820 发送了无法识别的 selector `- [UIViewControllerB tableView:heightForRowAtIndexPath:]`</div></pre></td></tr></table></figure>
<p>这种情况下我们需要来询问特定的类实例是否可以响应对应的 selector。下面的代码提供了一个小技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    CGFloat retVal = 0;</div><div class="line">    if ([[UIViewControllerA class] instancesRespondToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123;</div><div class="line">        retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath];</div><div class="line">    &#125;</div><div class="line">    return retVal + 10.0f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就像上面丑陋的代码，通常它会是更好的设计架构的方式，因为这种方式代理方法不需要被重写。</p>
<h3 id="多重委托"><a href="#多重委托" class="headerlink" title="多重委托"></a>多重委托</h3><p>多重委托是一个非常基础的概念，但是，大多数开发者对此非常不熟悉而使用 NSNotifications。就像你可能注意到的，委托和数据源是对象之间的通讯模式，但是只涉及两个对象：委托者和委托。</p>
<p>数据源模式强制一对一的关系，当发送者请求信息时有且只能有一个对象来响应。对于代理模式而言这会有些不同，我们有足够的理由要去实现很多代理者等待(唯一委托者的)回调的场景。</p>
<p>一些情况下至少有两个对象对特定委托者的回调感兴趣，而后者(即委托者)需要知道他的所有代理。这种方法在分布式系统下更为适用并且广泛使用于大型软件的复杂信息流程中。</p>
<p>多重委托可以用很多方式实现，但读者更在乎找到适合自己的个人实现。Luca Bernardi 在他的 <a href="https://github.com/lukabernardi/LBDelegateMatrioska">LBDelegateMatrioska</a>中提供了上述范式的一个非常简洁的实现。</p>
<p>这里给出一个基本的实现,方便你更好地理解这个概念。即使在Cocoa中也有一些在数据结构中保存 weak 引用来避免 引用循环的方法， 这里我们使用一个类来保留代理对象的 weak 引用(就像单一代理那样):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface ZOCWeakObject : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, readonly, weak) id object;</div><div class="line">//译者注：这里原文并没有很好地实践自己在本书之前章节所讨论的关于property属性修饰符的</div><div class="line">//人体工程学法则: 从左到右： 原子性 ===》 读写权限 (别名) ===》 内存管理权限符</div><div class="line"></div><div class="line">+ (instancetype)weakObjectWithObject:(id)object;</div><div class="line">- (instancetype)initWithObject:(id)object;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ZOCWeakObject ()</div><div class="line">@property (nonatomic, weak) id object;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZOCWeakObject</div><div class="line"></div><div class="line">+ (instancetype)weakObjectWithObject:(id)object &#123;</div><div class="line">    return [[[self class] alloc] initWithObject:object];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithObject:(id)object &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _object = object;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isEqual:(id)object &#123;</div><div class="line">    if (self == object) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (![object isKindOfClass:[object class]]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [self isEqualToWeakObject:(ZOCWeakObject *)object];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isEqualToWeakObject:(ZOCWeakObject *)object &#123;</div><div class="line">    if (!object) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BOOL objectsMatch = [self.object isEqual:object.object];</div><div class="line">    return objectsMatch;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSUInteger)hash &#123;</div><div class="line">    return [self.object hash];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用 weak 对象来实现多重代理的简单组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@protocol ZOCServiceDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface ZOCGeneralService : NSObject</div><div class="line">- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;</div><div class="line">- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface ZOCGeneralService ()</div><div class="line">@property (nonatomic, strong) NSMutableSet *delegates;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation ZOCGeneralService</div><div class="line">- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123;</div><div class="line">    if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123;</div><div class="line">        [self.delegates addObject:[[ZOCWeakObject alloc] initWithObject:delegate]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123;</div><div class="line">    if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123;</div><div class="line">        [self.delegates removeObject:[[ZOCWeakObject alloc] initWithObject:delegate]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)_notifyDelegates &#123;</div><div class="line">    ...</div><div class="line">    for (ZOCWeakObject *object in self.delegates) &#123;</div><div class="line">        if (object.object) &#123;</div><div class="line">            if ([object.object respondsToSelector:@selector(generalService:didRetrieveEntries:)]) &#123;</div><div class="line">                [object.object generalService:self didRetrieveEntries:entries];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在 <code>registerDelegate:</code> 和 <code>deregisterDelegate:</code> 方法的帮助下，连接/解除组件之间的联系很简单：在某些时间点上，如果代理不需要接收委托者的回调，仅仅需要’unsubscribe’.</p>
<p>当不同的 view 等待同一个回调来更新界面展示的时候，这很有用：如果 view 只是暂时隐藏（但是仍然存在），它仅仅需要取消对回调的订阅。</p>
<h1 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h1><p>Aspect Oriented Programming (AOP，面向切面编程) 在 Objective-C 社区内没有那么有名，但是 AOP 在运行时可以有巨大威力。 但是因为没有事实上的标准，Apple 也没有开箱即用的提供，也显得不重要，开发者都不怎么考虑它。</p>
<p>引用 <a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">Aspect Oriented Programming</a> 维基页面:</p>
<blockquote>
<p>An aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). (一个切面可以通过在多个 join points 中附加的行为来改变基础代码的行为(程序的非切面的部分) )</p>
</blockquote>
<p>在 Objective-C 的世界里，这意味着使用运行时的特性来为指定的方法追加 <em>切面</em> 。切面所附加的行为可以是这样的：</p>
<ul>
<li>在类的特定方法调用前运行特定的代码</li>
<li>在类的特定方法调用后运行特定的代码</li>
<li>增加代码来替代原来的类的方法的实现</li>
</ul>
<p>有很多方法可以达成这些目的，但是我们没有深入挖掘，不过它们主要都是利用了运行时。 <a href="https://twitter.com/steipete" target="_blank" rel="external">Peter Steinberger</a> 写了一个库，<a href="https://github.com/steipete/Aspects">Aspects</a> 完美地适配了 AOP 的思路。我们发现它值得信赖以及设计得非常优秀，所以我们就在这边作为一个简单的例子。</p>
<p>对于所有的 AOP库，这个库用运行时做了一些非常酷的魔法，可以替换或者增加一些方法（比 method swizzling 技术更有技巧性）</p>
<p>Aspect 的 API 有趣并且非常强大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(id)block</div><div class="line">                            error:(NSError **)error;</div><div class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(id)block</div><div class="line">                            error:(NSError **)error;</div></pre></td></tr></table></figure>
<p>比如，下面的代码会对于执行 <code>MyClass</code> 类的 <code>myMethod:</code>  (实例或者类的方法) 执行块参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[MyClass aspect_hookSelector:@selector(myMethod:)</div><div class="line">                 withOptions:AspectPositionAfter</div><div class="line">                  usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">                       error:nil];</div></pre></td></tr></table></figure>
<p>换一句话说：任意的 <code>MyClass</code> 类型的对象(或者是类型本身当这个 @selector 方法为类方法时)的 <code>@selector</code> 方法执行完后，就会执行这个代码中块参数所提供的代码。</p>
<p>我们为 <code>MyClass</code> 类的 <code>myMethod:</code> 方法增加了切面。</p>
<p>通常 AOP 被用来实现横向切面。统计与日志就是一个完美的例子。</p>
<p>下面的例子里面，我们会用AOP用来进行统计。统计是iOS项目里面一个热门的特性，有很多选择比如 Google Analytics, Flurry, MixPanel, 等等.</p>
<p>大部分统计框架都有教程来指导如何追踪特定的界面和事件，包括在每一个类里写几行代码。</p>
<p>在 Ray Wenderlich 的博客里有 <a href="https://www.raywenderlich.com/53459/google-analytics-ios" target="_blank" rel="external">文章</a> 和一些示例代码，通过在你的 view controller 里面加入 <a href="https://developers.google.com/analytics/devguides/collection/ios/" target="_blank" rel="external">Google Analytics</a>  进行统计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)logButtonPress:(UIButton *)button &#123;</div><div class="line">    id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker];</div><div class="line">    [tracker send:[[GAIDictionaryBuilder createEventWithCategory:@&quot;UX&quot;</div><div class="line">                                                          action:@&quot;touch&quot;</div><div class="line">                                                           label:[button.titleLabel text]</div><div class="line">                                                           value:nil] build]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码在按钮点击的时候发送了特定的上下文事件。但是当你想追踪屏幕的时候会变得很糟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidAppear:(BOOL)animated &#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line"></div><div class="line">    id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker];</div><div class="line">    [tracker set:kGAIScreenName value:@&quot;Stopwatch&quot;];</div><div class="line">    [tracker send:[[GAIDictionaryBuilder createAppView] build]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于大部分有经验的iOS工程师，这看起来不是很好的代码。我们让 view controller 变得更糟糕了。因为我们加入了统计事件的代码，但是它不是 view controller 的职能。你可以反驳，因为你通常有特定的对象来负责统计追踪，并且你将代码注入了 view controller ，但是无论你隐藏逻辑，问题仍然存在 ：你最后还是在<code>viewDidAppear:</code> 后插入了代码。</p>
<p>我们可以在类的 <code>viewDidAppear:</code> 方法上使用 AOP 来追踪屏幕，并且我们可以使用同样的方法在其他我们感兴趣的方法上添加事件追踪。比如当用户点击某个按钮时(比如:一般调用对应的 IBAction).</p>
<p>方法很简洁且不具侵入性：</p>
<ul>
<li>view controller 不会被不属于它的代码污染</li>
<li>为所有加入到我们代码的切面指定一个 SPOC 文件 (single point of customization)提供了可能</li>
<li>SPOC 应该在 App 刚开始启动的时候用来添加切面</li>
<li>如果SPOC文件异常,至少有一个 selector 或者 类 识别不出来，应用将会在启动时崩溃(对我们来说这很酷).</li>
<li>公司负责统计的团队通常会提供统计文档，罗列出需要追踪的事件。这个文档可以很容易映射到一个 SPOC 文件。</li>
<li>追踪逻辑抽象化之后，扩展到很多其他统计框架会很方便</li>
<li>对于屏幕视图，对于需要定义 selector 的方法，只需要在 SPOC 文件修改相关的类（相关的切面会加入到 <code>viewDidAppear:</code> 方法）。如果要同时发送屏幕视图和事件，需要（依靠统计提供方）提供一个追踪的标示或者可能还需要提供其他的元信息。</li>
</ul>
<p>我们可能希望一个 SPOC 文件类似下面的（同样的一个 .plist 文件会适配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSDictionary *analyticsConfiguration()</div><div class="line">&#123;</div><div class="line">    return @&#123;</div><div class="line">        @&quot;trackedScreens&quot; : @[</div><div class="line">            @&#123;</div><div class="line">                @&quot;class&quot; : @&quot;ZOCMainViewController&quot;,</div><div class="line">                @&quot;label&quot; : @&quot;Main screen&quot;</div><div class="line">                &#125;</div><div class="line">             ],</div><div class="line">        @&quot;trackedEvents&quot; : @[</div><div class="line">            @&#123;</div><div class="line">                @&quot;class&quot; : @&quot;ZOCMainViewController&quot;,</div><div class="line">                @&quot;selector&quot; : @&quot;loginViewFetchedUserInfo:user:&quot;,</div><div class="line">                @&quot;label&quot; : @&quot;Login with Facebook&quot;</div><div class="line">                &#125;,</div><div class="line">            @&#123;</div><div class="line">                @&quot;class&quot; : @&quot;ZOCMainViewController&quot;,</div><div class="line">                @&quot;selector&quot; : @&quot;loginViewShowingLoggedOutUser:&quot;,</div><div class="line">                @&quot;label&quot; : @&quot;Logout with Facebook&quot;</div><div class="line">                &#125;,</div><div class="line">            @&#123;</div><div class="line">                @&quot;class&quot; : @&quot;ZOCMainViewController&quot;,</div><div class="line">                @&quot;selector&quot; : @&quot;loginView:handleError:&quot;,</div><div class="line">                @&quot;label&quot; : @&quot;Login error with Facebook&quot;</div><div class="line">                &#125;,</div><div class="line">            @&#123;</div><div class="line">                @&quot;class&quot; : @&quot;ZOCMainViewController&quot;,</div><div class="line">                @&quot;selector&quot; : @&quot;shareButtonPressed:&quot;,</div><div class="line">                @&quot;label&quot; : @&quot;Share button&quot;</div><div class="line">                &#125;</div><div class="line">             ]</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提及的架构托管 在 Github 的<a href="https://github.com/ef-ctx/JohnnyEnglish/blob/master/CTXUserActivityTrackingManager.m">EF Education First</a> 中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)setupWithConfiguration:(NSDictionary *)configuration</div><div class="line">&#123;</div><div class="line">    // screen views tracking</div><div class="line">    for (NSDictionary *trackedScreen in configuration[@&quot;trackedScreens&quot;]) &#123;</div><div class="line">        Class clazz = NSClassFromString(trackedScreen[@&quot;class&quot;]);</div><div class="line"></div><div class="line">        [clazz aspect_hookSelector:@selector(viewDidAppear:)</div><div class="line">                       withOptions:AspectPositionAfter</div><div class="line">                        usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class="line">               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),</div><div class="line">                          ^&#123;</div><div class="line">                          NSString *viewName = trackedScreen[@&quot;label&quot;];</div><div class="line">                        [tracker trackScreenHitWithName:viewName];</div><div class="line">                      &#125;);</div><div class="line">                  &#125;</div><div class="line">                            error:nil];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // events tracking</div><div class="line">    for (NSDictionary *trackedEvents in configuration[@&quot;trackedEvents&quot;]) &#123;</div><div class="line">        Class clazz = NSClassFromString(trackedEvents[@&quot;class&quot;]);</div><div class="line">        SEL selektor = NSSelectorFromString(trackedEvents[@&quot;selector&quot;]);</div><div class="line"></div><div class="line">        [clazz aspect_hookSelector:selektor</div><div class="line">                       withOptions:AspectPositionAfter</div><div class="line">                        usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class="line">               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),</div><div class="line">                      ^&#123;</div><div class="line">                            UserActivityButtonPressedEvent *buttonPressEvent = \</div><div class="line">                                [UserActivityButtonPressedEvent \</div><div class="line">                                    eventWithLabel:trackedEvents[@&quot;label&quot;]];</div><div class="line">                            [tracker trackEvent:buttonPressEvent];</div><div class="line">                      &#125;);</div><div class="line">                &#125;</div><div class="line">                       error:nil];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>这里有一些和风格指南有关的苹果的文档：</p>
<ul>
<li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" target="_blank" rel="external">The Objective-C Programming Language</a></li>
<li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html" target="_blank" rel="external">Cocoa Fundamentals Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Coding Guidelines for Cocoa</a></li>
<li><a href="https://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html" target="_blank" rel="external">iOS App Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html" target="_blank" rel="external">Apple Objective-C conventions</a>: 来自苹果的代码约定</li>
</ul>
<p>其他：</p>
<ul>
<li><a href="http://objclean.com" target="_blank" rel="external">Objective-Clean</a>: an attempt to write a standard for writing Objective-C code with Xcode integration;</li>
<li><a href="http://uncrustify.sourceforge.net/" target="_blank" rel="external">Uncrustify</a>: source code beautifier.</li>
</ul>
<h3 id="其他的-Objective-C-风格指南"><a href="#其他的-Objective-C-风格指南" class="headerlink" title="其他的 Objective-C 风格指南"></a>其他的 Objective-C 风格指南</h3><p>这里有一些和风格指南有关的苹果的文档。如果有一些本书没有涉猎的地方，你或许能在这些之中找到详细说明。</p>
<p>来自 Apple 的：</p>
<ul>
<li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" target="_blank" rel="external">The Objective-C Programming Language</a></li>
<li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html" target="_blank" rel="external">Cocoa Fundamentals Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Coding Guidelines for Cocoa</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html" target="_blank" rel="external">iOS App Programming Guide</a></li>
</ul>
<p>来自社区的：</p>
<ul>
<li><a href="https://github.com/NYTimes/objective-c-style-guide">NYTimes Objective-C Style Guide</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml" target="_blank" rel="external">Google</a></li>
<li><a href="https://github.com/github/objective-c-style-guide">GitHub</a></li>
<li><a href="https://trac.adium.im/wiki/CodingStyle" target="_blank" rel="external">Adium</a></li>
<li><a href="https://gist.github.com/soffes/812796" target="_blank" rel="external">Sam Soffes</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php" target="_blank" rel="external">CocoaDevCentral</a></li>
<li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html" target="_blank" rel="external">Luke Redpath</a></li>
<li><a href="http://www.cimgf.com/zds-code-style-guide/" target="_blank" rel="external">Marcus Zarra</a></li>
<li><a href="https://github.com/raywenderlich/objective-c-style-guide">Ray Wenderlich</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://github.com/oa414/objc-zen-book-cn&quot;&gt;https://github.com/oa414/objc-zen-book-cn&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;禅与-Objective-C-编程艺术-（Zen
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/Objective-C/"/>
    
      <category term="编程规范" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS 升级HTTPS通过ATS你所要知道的</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2017/01/14/17.1.14%20iOS%E5%8D%87%E7%BA%A7HTTPS%E9%80%9A%E8%BF%87ATS%E4%BD%A0%E6%89%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2017/01/14/17.1.14 iOS升级HTTPS通过ATS你所要知道的/</id>
    <published>2017-01-14T08:44:53.000Z</published>
    <updated>2017-09-11T14:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.jianshu.com/p/2d72ef8dbf5a" target="_blank" rel="external">http://www.jianshu.com/p/2d72ef8dbf5a</a></p>
<h1 id="iOS-升级HTTPS通过ATS你所要知道的"><a href="#iOS-升级HTTPS通过ATS你所要知道的" class="headerlink" title="iOS 升级HTTPS通过ATS你所要知道的"></a>iOS 升级HTTPS通过ATS你所要知道的</h1><p>苹果强制升级的HTTPS不仅仅是在接口HTTP上加个S那么简单:<br>它所有满足的是iOS9中新增App Transport Security（简称ATS）特性:<br>那满足ATS我们需要做什么呢<br>1.必须是苹果信任的CA证书机构颁发的证书<br>2.后台传输协议必须满足: TLS1.2   (这很重要, 后面的自制证书满足这个条件是前提)<br>3.签字算法只能是下面的一种: </p>
<p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384<br>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA<br>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA<br>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256<br>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`</p>
<p>4.证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥。</p>
<p>目前有两种升级到HTTPS得方法:<br>1.第三方认证的颁发CA证书(推荐)<br>2.自己制作证书(这种不知道能不能满足苹果的审核)</p>
<blockquote>
<p>一: 第三方认证的颁发CA证书</p>
</blockquote>
<p>证书到底长什么样子呢? 取个栗子:<br>大家请打开<a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a><br>然后看到</p>
<div class="image-package"><br><img src="http://chuantu.biz/t5/43/1480644859x3074328177.png" alt=""><br><div class="image-caption">百度的证书分析</div><br></div>

<p>那些证书机构颁发的证书能用:<a href="https://support.apple.com/zh-cn/HT205205" target="_blank" rel="external">苹果官方信任证书</a></p>
<p><code>收费SSL证书:</code> 网上百度一大把, 收费还挺贵的,自己可以多找几个对比一下<br><code>免费SSL证书:</code> 除了收费的CA证书机构, 你还可以去<a href="https://www.qcloud.com/product/ssl" target="_blank" rel="external">腾讯云</a>申请免费的SSL证书,  教程<a href="http://www.jianshu.com/p/08f64ff9ed6b/comments/4374507" target="_blank" rel="external">免费在腾讯云申请SSL证书的方法</a><br>沃通(WoSign)免费的SSL证书最近被苹果封杀了, 能不能用大家可以看一下苹果的公告: 您的苹果手机轻点“设置”&gt;“通用”&gt;“关于本机”&gt;”证书信任设置”&gt;”进一步了解被信任的证书”去了解</p>
<blockquote>
<p>检测你的接口是否满足苹果的ATS要求, 有以下两种方法:</p>
</blockquote>
<p>1.<a href="https://www.qcloud.com/product/ssl" target="_blank" rel="external">腾讯云</a>提供的检测页面检测</p>
<div class="image-package"><br><img src="http://chuantu.biz/t5/43/1480644925x3074328177.png" alt=""><br><div class="image-caption">腾讯云的检测页面</div><br></div>

<p>2 终端输入 <code>nsurl --ats-diagnostics --verbose 你的接口地址</code><br>大家可以参考这篇文章,里面的说的很明白:<br><a href="https://my.oschina.net/vimfung/blog/494687?_t_t_t=0.1896578531749944" target="_blank" rel="external">关于iOS9中的App Transport Security相关说明及适配(更新于2016.7.1)</a><br>里面会详细说明你的证书哪点不符合ATS要求<br>当然下面自己制作证书去实现HTTPS的,检测不通过的,所以我觉得审核会被拒<br>这种方法配置好了, 在手机端就什么都不用配置就可以请求了</p>
<blockquote>
<p>二:  自己制作证书</p>
</blockquote>
<p><a href="https://support.apple.com/zh-cn/HT205205" target="_blank" rel="external">苹果官方信任证书</a>里说到有三种证书:</p>
<pre>`1 可信的根证书用于建立信任链，以验证由可信的根签署的其他证书，例如，与 Web 服务器建立安全连接。当 IT 管理员创建 iPhone、iPad 或 iPod touch 的配置描述文件时，无需提供这些可信的根证书。
2 始终询问的证书不受信任，但不受阻止。使用其中一个证书时，系统将提示您选择是否信任该证书。
3 已阻止的证书视为被盗用，将不再受信任。`</pre>

<p>自制证书我觉得应该就是属于第二种情况, 所以这种方法我也不知道能不能通过苹果的审核, 只是提供一个方法给大家参考, 看到网上有人说可以,有人说不可以, 不到1月1号,自己没试过都不敢说大话<br>这种方式拿到后台的接口用谷歌浏览器打开跟百度的证书是有区别的</p>
<div class="image-package"><br><img src="http://chuantu.biz/t5/43/1480644913x3074328177.png" alt=""><br><div class="image-caption">自己制作证书</div><br></div>

<p>很明显没有绿锁, 当打开的时候会询问是否连接这个不受信任的连接才会进一步打开, 下面就来一步步的实现(包括怎么制作证书)<br><a href="http://www.jianshu.com/p/e6a26ecd84aa" target="_blank" rel="external">iOS使用自签名证书实现HTTPS请求</a><br><a href="http://www.jianshu.com/p/ec61e5ab6fbb" target="_blank" rel="external">iOS Https协议 自签证书访问数据</a>参考这个例子的时候,博主自带的Demo  AFN框架请求不了数据, 我用了最新AFN版本的成功返回数据<br>还可以参考一下<br><a href="http://www.jianshu.com/p/36ddc5b009a7" target="_blank" rel="external">iOS 10 适配 ATS app支持https通过App Store审核</a></p>
<p>我在利用原生的代码测试时遇到的问题</p>
<p><pre>`@interface ViewController () &lt;NSURLSessionDelegate&gt;</pre></p>
<p>@end</p>
<p>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad {</li>
</ul>
<p>}</p>
<ul>
<li>(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event<br>{<br>NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</li>
</ul>
<p>NSURLSessionDataTask <em>task =  [session dataTaskWithURL:[NSURL URLWithString:@”<a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a>“] completionHandler:^(NSData </em>data, NSURLResponse <em>response, NSError </em>error) {<br>NSLog(@”%@”, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);<br>}];<br>[task resume];<br>}</p>
<ul>
<li><p>(void)URLSession:(NSURLSession <em>)session dataTask:(NSURLSessionDataTask </em>)dataTask<br>didReceiveResponse:(NSURLResponse <em>)response<br>completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler {<br>NSLog(@”接收到服务器响应”);<br>//注意：这里需要使用completionHandler回调告诉系统应该如何处理服务器返回的数据<br>//默认是取消<br>/**<br>NSURLSessionResponseCancel = 0,            默认的处理方式，取消<br>NSURLSessionResponseAllow = 1,             接收服务器返回的数据<br>NSURLSessionResponseBecomeDownload = 2,    变成一个下载请求<br>NSURLSessionResponseBecomeStream           变成一个流
</em>/<br>completionHandler(NSURLSessionResponseAllow);<br>}</p>
</li>
<li><p>(void)URLSession:(NSURLSession <em>)session dataTask:(NSURLSessionDataTask </em>)dataTask<br>didReceiveData:(NSData *)data {<br>NSLog(@”获取到服务段数据”);<br>NSLog(@”%@”,[self jsonToDictionary:data]);<br>}</p>
</li>
<li><p>(void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task<br>didCompleteWithError:(nullable NSError *)error {<br>NSLog(@”请求完成%@”, error);<br>}</p>
</li>
<li><p>(void)URLSession:(NSURLSession <em>)session didReceiveChallenge:(NSURLAuthenticationChallenge </em>)challenge<br>completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential <em> _Nullable credential))completionHandler {<br>NSLog(@”证书认证”);<br>if ([[[challenge protectionSpace] authenticationMethod] isEqualToString: NSURLAuthenticationMethodServerTrust]) {<br>do<br>{<br>SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];<br>NSCAssert(serverTrust != nil, @”serverTrust is nil”);<br>if(nil == serverTrust)<br>break; /</em> failed <em>/<br>/*</em></p>
</li>
</ul>
<ul>
<li>导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称<br><em>/<br>NSString </em>cerPath = [[NSBundle mainBundle] pathForResource:@”ca” ofType:@”cer”];//自签名证书<br>NSData* caCert = [NSData dataWithContentsOfFile:cerPath];</li>
</ul>
<p>NSCAssert(caCert != nil, @”caCert is nil”);<br>if(nil == caCert)<br>break; /<em> failed </em>/</p>
<p>SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);<br>NSCAssert(caRef != nil, @”caRef is nil”);<br>if(nil == caRef)<br>break; /<em> failed </em>/</p>
<p>//可以添加多张证书<br>NSArray *caArray = @[(__bridge id)(caRef)];</p>
<p>NSCAssert(caArray != nil, @”caArray is nil”);<br>if(nil == caArray)<br>break; /<em> failed </em>/</p>
<p>//将读取的证书设置为服务端帧数的根证书<br>OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);<br>NSCAssert(errSecSuccess == status, @”SecTrustSetAnchorCertificates failed”);<br>if(!(errSecSuccess == status))<br>break; /<em> failed </em>/</p>
<p>SecTrustResultType result = -1;<br>//通过本地导入的证书来验证服务器的证书是否可信<br>status = SecTrustEvaluate(serverTrust, &amp;result);<br>if(!(errSecSuccess == status))<br>break; /<em> failed </em>/<br>NSLog(@”stutas:%d”,(int)status);<br>NSLog(@”Result: %d”, result);</p>
<p>BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed);<br>if (allowConnect) {<br>NSLog(@”success”);<br>}else {<br>NSLog(@”error”);<br>}</p>
<p>/<em> kSecTrustResultUnspecified and kSecTrustResultProceed are success </em>/<br>if(! allowConnect)<br>{<br>break; /<em> failed </em>/<br>}</p>
<p>#if 0<br>/<em> Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success </em>/<br>/<em>   since the user will likely tap-through to see the dancing bunnies </em>/<br>if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError)<br>break; /<em> failed to trust cert (good in this case) </em>/</p>
<p>#endif</p>
<p>// The only good exit point<br>NSLog(@”信任该证书”);</p>
<p>NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];<br>completionHandler(NSURLSessionAuthChallengeUseCredential,credential);<br>return [[challenge sender] useCredential: credential<br>forAuthenticationChallenge: challenge];</p>
<p>}<br>while(0);<br>}</p>
<p>// Bad dog<br>NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];<br>completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge,credential);<br>return [[challenge sender] cancelAuthenticationChallenge: challenge];<br>}</p>
<ul>
<li>(NSDictionary <em>)jsonToDictionary:(NSData </em>)jsonData {<br>NSError <em>jsonError;<br>NSDictionary </em>resultDic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableLeaves error:&amp;jsonError];<br>return resultDic;<br>}</li>
</ul>
<p>@end</p>
<p>下面说说我在配置自己制作证书过程中遇到的问题:<br>1.转换证书: 把后台给你的<code>.crt</code>证书转化为<code>.cer</code>后缀<br>终端命令行<code>openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der</code></p>
<p>2.利用系统的方法来不到<code>- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler {
NSLog(@&quot;证书认证&quot;);
}</code>这个方法的时候, 是因为后台的传输协议还没升级到TLS1.2, 叫后台升级后就可以来到验证证书的这个方法了.</p>
<p>3.拖入证书读取不出证书数据<br>参考: <a href="http://blog.csdn.net/jia12216/article/details/49204797" target="_blank" rel="external">https的证书错误，错误码-1012问题及解决方案</a></p>
<p>SDWebImage: 项目中大家用到AFN请求网络数据, 升级验证SSL证书的方案相信你看完上面的参考文章已经没问题了, 我给出的代码, 自定义网络请求也没问题了, 还有就是SDWebImage框架的请求HTTPS的图片时,大家可以绕过证书验证去加载图片<code>[imageView sd_setImageWithURL:[NSURL URLWithString:urlString] placeholderImage:self.placeholder options:SDWebImageAllowInvalidSSLCertificates];</code></p>
<p>恩, 这就是这几天升级HTTPS觉得有帮助的参考和总结.希望帮到你</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.jianshu.com/p/2d72ef8dbf5a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/2d72ef8dbf5a&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;i
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="HTTPS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/HTTPS/"/>
    
      <category term="ATS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/HTTPS/ATS/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="HTTPS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/HTTPS/"/>
    
      <category term="ATS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/ATS/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/12/10/16.12.10%20_iOS%20%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F--%E8%A7%A3%E5%AF%86%20MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E4%BB%A5%E5%8F%8AVIPER%E6%9E%B6%E6%9E%84/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/12/10/16.12.10 _iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构/</id>
    <published>2016-12-10T08:44:53.000Z</published>
    <updated>2017-09-11T13:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.cocoachina.com/ios/20160108/14916.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160108/14916.html</a></p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452151424659945.png" alt="302.png" title="1452151424659945.png"></p>
<ul>
<li><p>本文由<a href="http://www.cocoachina.com/ios/20160107/14916.html" target="_blank" rel="external">CocoaChina</a>译者lynulzy（<a href="http://www.cocoachina.com/bbs/u.php?action=show&amp;uid=308292" target="_blank" rel="external">社区ID</a>）翻译</p>
</li>
<li><p>作者：<a href="https://twitter.com/bohdan_orlov" target="_blank" rel="external">Bohdan Orlov</a></p>
</li>
<li><p>原文：<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.vm64nm3ro" target="_blank" rel="external">iOS Architecture Patterns</a></p>
</li>
</ul>
<hr>
<p>在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？</p>
<p>相信你会找到以上问题的答案，如果没找到请在评论中指出。</p>
<p>你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。</p>
<p>掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题：</p>
<p>谁应该来负责网络请求？Model 还是 Controller ？</p>
<p>应该怎样向一个新的页面的 ViewModel 传入一个 Model ?</p>
<p>谁来创建一个 VIPER 模块，是 Router 还是 Presenter ?</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452151474278586.png" alt="10.png" title="1452151474278586.png"></p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>为什么要关注架构设计？</strong></span></p>
<p>因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样：</p>
<ul>
<li><p>这个类是一个UIViewController的子类</p>
</li>
<li><p>数据直接在UIViewController中存储</p>
</li>
<li><p>UIView类几乎不做任何事情</p>
</li>
<li><p>Model 仅仅是一个数据结构</p>
</li>
<li><p>单元测试覆盖不了任何用例</p>
</li>
</ul>
<p>以上这些情况仍旧会出现，即使是你遵循了Apple的指导原则并且实现了其 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">MVC</a>(模式，所以，大可不必惊慌。Apple所提出的 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">MVC</a> 模式存在一些问题，我们之后会详述。</p>
<p>在此，我们可以定义一个好的架构应该具备的特点：</p>
<ol>
<li><p>任务均衡分摊给具有清晰角色的实体</p>
</li>
<li><p>可测试性通常都来自与上一条（对于一个合适的架构是非常容易）</p>
</li>
<li><p>易用性和低成本维护</p>
</li>
</ol>
<p><span style="font-size: 14px;"><strong>为什么采用分布式?</strong></span></p>
<p>采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">单一功能原则</a> 的前提下，将功能划分给不同的实体。</p>
<p><span style="font-size: 14px;"><strong>为什么需要易测性？</strong></span></p>
<p>其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少<a href="http://appreviewtimes.com" target="_blank" rel="external">一周</a>的时间才能再次分发给用户。</p>
<p><span style="font-size: 14px;"><strong>为什么需要易用性？</strong></span></p>
<p>这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。</p>
<p><span style="color: rgb(0, 176, 80); font-size: 18px;"><strong>MV(X）系列概要</strong></span></p>
<p>当今我们已经有很架构设计模式方面的选择:</p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="external">MVC</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter" target="_blank" rel="external">MVP</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank" rel="external">MVVM</a></p>
</li>
<li><p><a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">VIPER</a></p>
</li>
</ul>
<p>前三种设计模式都把一个应用中的实体分为以下三类：</p>
<ul>
<li><p><strong>Models</strong>–负责主要的数据或者操作数据的<a href="https://en.wikipedia.org/wiki/Data_access_layer" target="_blank" rel="external">数据访问层</a>，可以想象 Perspn 和 PersonDataProvider 类。</p>
</li>
<li><p><strong>Views</strong>–负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。</p>
</li>
<li><p><strong>Controller/Presenter/ViewModel</strong>–负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，同时将更改的信息返回到View上。</p>
</li>
</ul>
<p>将实体进行划分给我们带来了以下好处：</p>
<ul>
<li><p>更好的理解它们之间的关系</p>
</li>
<li><p>复用（尤其是对于View和Model）</p>
</li>
<li><p>独立的测试</p>
</li>
</ul>
<p>让我们开始了解MV(X)系列，之后再返回到VIPER模式。</p>
<p><span style="color: rgb(0, 176, 80); font-size: 18px;"><strong>MVC的</strong></span><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>过去</strong></span></p>
<p>在我们探讨Apple的MVC模式之前，我们来看下<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="external">传统的MVC模式</a>。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152223816977.png" alt="1-E9A5fOrSr0yVmc7Kly5C6A.png" title="1452152223816977.png"></p>
<p>传统的MVC</p>
<p>在这里，View并没有任何界限，仅仅是简单的在Controller中呈现出Model的变化。想象一下，就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。尽管在iOS平台上实现这这种MVC模式是没有任何难度的，但是它并不会为我们解决架构问题带来任何裨益。因为它本身也是，三个实体间相互都有通信，而且是紧密耦合的。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。</p>
<p><span style="color: rgb(127, 127, 127); font-size: 16px;"><strong>“传统的MVC架构不适用于当下的iOS开发”</strong></span></p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>苹果推荐的MVC–</strong></span><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>愿景</strong></span></p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152304301101.png" alt="02.png" title="1452152304301101.png"></p>
<p>Cocoa MVC</p>
<p>由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。</p>
<p>理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，<a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="external">为View controller减负</a>也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？</p>
<p><span style="color: rgb(0, 176, 80); font-size: 18px;"><strong>苹果推荐的MVC–</strong></span><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>事实</strong></span></p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152425723031.png" alt="1-PkWjDU0jqGJOB972cMsrnA.png" title="1452152425723031.png"></p>
<p>Realistic Cocoa MVC</p>
<p>Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们经常被混杂到View的生命周期中，因此很难说View和ViewController是分离的。尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，View的最大的任务就是向Controller传递用户动作事件。ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。</p>
<p>你可能会看见过很多次这样的代码：</p>
<pre class="brush:js;toolbar:false">var&nbsp;userCell&nbsp;=&nbsp;tableView.dequeueReusableCellWithIdentifier("identifier")&nbsp;as&nbsp;UserCell
userCell.configureWithUser(user)</pre>

<p>这个cell,正是由View直接来调用Model，所以事实上MVC的原则已经违背了，但是这种情况是一直发生的甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，不向View传递一个Model对象，这样就会大大增加Controller的体积。</p>
<p><span style="color: rgb(127, 127, 127); font-size: 16px;"><strong>“Cocoa 的MVC被写成Massive View Controller 是不无道理的。”</strong></span></p>
<p>直到进行<a href="http://nshipster.com/unit-testing/" target="_blank" rel="external">单元测试</a>的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难–你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。</p>
<p>我们看下一些简单的例子:</p>
<pre class="brush:js;toolbar:false">import&nbsp;UIKit

struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String
}

class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{&nbsp;//&nbsp;View&nbsp;+&nbsp;Controller
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;person:&nbsp;Person!
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton()
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here
}
//&nbsp;Assembling&nbsp;of&nbsp;MVC
let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")
let&nbsp;view&nbsp;=&nbsp;GreetingViewController()
view.person&nbsp;=&nbsp;model;</pre>

<p><span style="font-size: 16px;"><strong><span style="color: rgb(127, 127, 127);">“MVC可以在一个正在显示的ViewController中实现”</span></strong></span></p>
<p>这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。</p>
<p>事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作，因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。</p>
<p><span style="color: rgb(127, 127, 127); font-size: 16px;"><strong>“View和Controller的接口**</strong><a href="http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/" target="_blank" rel="external">并不适合单元测试</a>。”**</span></p>
<p>以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征:</p>
<ul>
<li><p><strong>任务均摊</strong>–View和Model确实是分开的，但是View和Controller却是紧密耦合的</p>
</li>
<li><p><strong>可测试性</strong>–由于糟糕的分散性，只能对Model进行测试</p>
</li>
<li><p><strong>易用性</strong>–与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。</p>
</li>
</ul>
<p>如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。</p>
<p><span style="color: rgb(127, 127, 127);"><strong><span style="font-size: 16px;">“就开发速度而言，Cocoa MVC是最好的架构选择方案。”</span></strong></span></p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>MVP&nbsp;<span style="font-size: 18px; line-height: 1.8;">实现了Cocoa的MVC的愿景</span></strong></span></p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152673569726.png" alt="021.png" title="1452152673569726.png"></p>
<p>Passive View variant of MVP</p>
<p>这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字叫做MVC，但是，这就是说苹果的MVC实际上就是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter" target="_blank" rel="external">MVP</a>了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152798105670.png" alt="QQ截图20160107154558.png" title="1452152798105670.png"></p>
<p><strong><span style="font-size: 18px; color: rgb(127, 127, 127);">“假如告诉你UIViewController就是View呢？”</span></strong></p>
<p>就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出：</p>
<pre class="brush:js;toolbar:false">import&nbsp;UIKit

struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String
}

protocol&nbsp;GreetingView:&nbsp;class&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)
}

protocol&nbsp;GreetingViewPresenter&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person)
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()
}

class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingViewPresenter&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;unowned&nbsp;let&nbsp;view:&nbsp;GreetingView
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person
&nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view&nbsp;=&nbsp;view
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;presenter:&nbsp;GreetingViewPresenter!
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton()
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.presenter.showGreeting()
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here
}
//&nbsp;Assembling&nbsp;of&nbsp;MVP
let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")
let&nbsp;view&nbsp;=&nbsp;GreetingViewController()
let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter(view:&nbsp;view,&nbsp;person:&nbsp;model)
view.presenter&nbsp;=&nbsp;presenter</pre>

<p><strong>关于整合问题的重要说明</strong></p>
<p>MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View涉及到Model，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下集中方案中。</p>
<p>我们来看下MVP模式下的三个特性的分析：</p>
<ul>
<li><p>任务均摊–我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。</p>
</li>
<li><p>可测试性–非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单</p>
</li>
<li><p>易用性–在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰</p>
</li>
</ul>
<p><span style="font-size: 18px; color: rgb(127, 127, 127);"><strong>“iOS 中的MVP意味着可测试性强、代码量大。”</strong></span></p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>MVP–<span style="font-size: 18px; line-height: 1.8;">绑定和信号</span></strong></span></p>
<p>还有一些其他形态的MVP–监控控制器的MVP。</p>
<p>这个变体包含了View和Model之间的直接绑定，但是Presenter仍然来管理来自View的动作事件，同时也能胜任对View的更新。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452152939657296.png" alt="022.png" title="1452152939657296.png"></p>
<p>Supervising Presenter variant of the MVP</p>
<p>但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。</p>
<p>和传统的MVC一样，写这样的例子没有什么价值，故不再给出。</p>
<p><span style="color: rgb(0, 176, 80); font-size: 18px;"><strong>MVVM–<span style="color: rgb(0, 176, 80); line-height: 1.8;">最新且是最伟大的MV(X)系列的一员</span></strong></span></p>
<p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank" rel="external">MVVM</a>架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。</p>
<p>从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452153249521047.png" alt="023.png" title="1452153249521047.png"></p>
<p>MVVM</p>
<p>它和MVP模式看起来非常像:</p>
<ul>
<li><p>MVVM将ViewController视作View</p>
</li>
<li><p>在View和Model之间没有紧密的联系</p>
</li>
</ul>
<p>此外，它还有像监管版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间而是在View和ViewModel之间。</p>
<p>那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。</p>
<p><strong>绑定</strong></p>
<p>我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。</p>
<p><span style="line-height: 1.8;">如果我们自己不想自己实现，那么我们有两种选择:</span></p>
<ul>
<li><p>基于KVO的绑定库如 <a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a> 和 <a href="https://github.com/SwiftBond/Bond">SwiftBond</a></p>
</li>
<li><p>完全的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6" target="_blank" rel="external">函数响应式编程</a>，比如像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a><span style="line-height: 1.8;">、<a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>或者 <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></span></p>
</li>
</ul>
<p><span style="line-height: 1.8;">事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。</span></p>
<p>但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下函数调用栈：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452153404430638.png" alt="1-WGIs3XQL1MtKiyApr-m9bg.png" title="1452153404430638.png"></p>
<p>Reactive Debugging</p>
<p>在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。</p>
<pre class="brush:js;toolbar:false">import&nbsp;UIKit

struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String
}

protocol&nbsp;GreetingViewModelProtocol:&nbsp;class&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{&nbsp;get&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())?&nbsp;{&nbsp;get&nbsp;set&nbsp;}&nbsp;//&nbsp;function&nbsp;to&nbsp;call&nbsp;when&nbsp;greeting&nbsp;did&nbsp;change
&nbsp;&nbsp;&nbsp;&nbsp;init(person:&nbsp;Person)
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()
}

class&nbsp;GreetingViewModel&nbsp;:&nbsp;GreetingViewModelProtocol&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingDidChange?(self)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())?
&nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(person:&nbsp;Person)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName
&nbsp;&nbsp;&nbsp;&nbsp;}
}

class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;viewModel:&nbsp;GreetingViewModelProtocol!&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.viewModel.greetingDidChange&nbsp;=&nbsp;{&nbsp;[unowned&nbsp;self]&nbsp;viewModel&nbsp;in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;viewModel.greeting
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton()
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel()
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self.viewModel,&nbsp;action:&nbsp;"showGreeting",&nbsp;forControlEvents:&nbsp;.TouchUpInside)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here
}
//&nbsp;Assembling&nbsp;of&nbsp;MVVM
let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")
let&nbsp;viewModel&nbsp;=&nbsp;GreetingViewModel(person:&nbsp;model)
let&nbsp;view&nbsp;=&nbsp;GreetingViewController()
view.viewModel&nbsp;=&nbsp;viewModel</pre>

<p>让我们再来看看关于三个特性的评估：</p>
<ul>
<li><p>任务均摊 – 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</p>
</li>
<li><p>可测试性 – ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</p>
</li>
<li><p>易用性 – 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。</p>
</li>
</ul>
<p><span style="font-size: 16px; color: rgb(127, 127, 127);"><strong>“MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。”</strong></span></p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong>VIPER–<span style="font-size: 18px; line-height: 1.8;">把LEGO建筑经验迁移到iOS app的设计</span></strong></span></p>
<p><a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">VIPER</a>是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。</p>
<p>迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次:</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160107/1452153564205784.png" alt="024.png" title="1452153564205784.png"></p>
<p>V<span style="line-height: 1.8;">IPER</span></p>
<ul>
<li><p><strong>交互器 </strong>– 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。</p>
</li>
<li><p><strong>展示器</strong> – 包含UI层面的业务逻辑以及在交互器层面的方法调用。</p>
</li>
<li><p><strong>实体</strong> – 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。</p>
</li>
<li><p><strong>路由器</strong> – 用来连接VIPER的各个模块。</p>
</li>
</ul>
<p>基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程–想想认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。</p>
<p>当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同:</p>
<ul>
<li><p><strong>Model</strong> 逻辑通过把实体作为最小的数据结构转换到交互器中。</p>
</li>
<li><p><strong>Controller/Presenter/ViewModel</strong>的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。</p>
</li>
<li><p><strong>VIPER</strong>是第一个通过路由器实现明确的地址导航模式。</p>
</li>
</ul>
<p><span style="font-size: 16px; color: rgb(127, 127, 127);"><strong>“找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。”</strong></span></p>
<p>例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。</p>
<p><span style="white-space: nowrap;"></span></p>
<pre class="brush:js;toolbar:false">import&nbsp;UIKit

struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Entity&nbsp;(usually&nbsp;more&nbsp;complex&nbsp;e.g.&nbsp;NSManagedObject)
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String
}

struct&nbsp;GreetingData&nbsp;{&nbsp;//&nbsp;Transport&nbsp;data&nbsp;structure&nbsp;(not&nbsp;Entity)
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting:&nbsp;String
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject:&nbsp;String
}

protocol&nbsp;GreetingProvider&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData()
}

protocol&nbsp;GreetingOutput:&nbsp;class&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData)
}

class&nbsp;GreetingInteractor&nbsp;:&nbsp;GreetingProvider&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;output:&nbsp;GreetingOutput!
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")&nbsp;//&nbsp;usually&nbsp;comes&nbsp;from&nbsp;data&nbsp;access&nbsp;layer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject&nbsp;=&nbsp;person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;person.lastName
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;GreetingData(greeting:&nbsp;"Hello",&nbsp;subject:&nbsp;subject)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.output.receiveGreetingData(greeting)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

protocol&nbsp;GreetingViewEventHandler&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton()
}

protocol&nbsp;GreetingView:&nbsp;class&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)
}

class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingOutput,&nbsp;GreetingViewEventHandler&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;view:&nbsp;GreetingView!
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingProvider:&nbsp;GreetingProvider!
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingProvider.provideGreetingData()
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;greetingData.greeting&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;greetingData.subject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting)
&nbsp;&nbsp;&nbsp;&nbsp;}
}

class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;eventHandler:&nbsp;GreetingViewEventHandler!
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton()
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel()
&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.eventHandler.didTapShowGreetingButton()
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here
}
//&nbsp;Assembling&nbsp;of&nbsp;VIPER&nbsp;module,&nbsp;without&nbsp;Router
let&nbsp;view&nbsp;=&nbsp;GreetingViewController()
let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter()
let&nbsp;interactor&nbsp;=&nbsp;GreetingInteractor()
view.eventHandler&nbsp;=&nbsp;presenter
presenter.view&nbsp;=&nbsp;view
presenter.greetingProvider&nbsp;=&nbsp;interactor
interactor.output&nbsp;=&nbsp;presenter</pre>

<p><span style="line-height: 1.8;">让我们再来评估一下特性:</span></p>
<ul>
<li><p>任务均摊 – 毫无疑问，VIPER是任务划分中的佼佼者。</p>
</li>
<li><p>可测试性 – 不出意外地，更好的分布性就有更好的可测试性。</p>
</li>
<li><p>易用性 – 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。</p>
</li>
</ul>
<p><strong>什么是LEGO</strong></p>
<p>当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些<a href="https://inessential.com/2014/03/16/smaller_please" target="_blank" rel="external">问题</a>，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 <a href="https://github.com/rambler-ios/Generamba">Generamba</a> 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。</p>
<p><span style="font-size: 18px; color: rgb(0, 176, 80);"><strong><span style="font-size: 18px; line-height: 1.8;">总结</span></strong></span></p>
<p>我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。</p>
<p>因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.cocoachina.com/ios/20160108/14916.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20160108/1491
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="架构模式" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="架构" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="MVC" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/MVC/"/>
    
      <category term="MVP" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/MVP/"/>
    
      <category term="MVVM" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/MVVM/"/>
    
      <category term="VIPER" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/VIPER/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS可视化动态绘制八种排序过程</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/10/21/16.10.21_iOS%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/10/21/16.10.21_iOS可视化动态绘制八种排序过程/</id>
    <published>2016-10-21T02:44:53.000Z</published>
    <updated>2017-09-11T13:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.cocoachina.com/ios/20170105/18522.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20170105/18522.html</a></p>
<p>前面几篇博客都是关于排序的，在之前陆陆续续发布的博客中，我们先后介绍了冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序以及快速排序。俗话说的好，做事儿要善始善终，本篇博客就算是对之前那几篇博客的总结了。而本篇博客的示例Demo也是在之前那些博客Demo的基础上做的，也算是集成了各种排序的方法，然后给出了可视化的解决方案。今天博客的内容还是比较有趣的。</p>
<p>因为本猿是做iOS开发的，所以就使用iOS相关的组件来表示上述各种排序的过程。使用可视化方式来感受一下上述这些排序方法的异同。本篇博客所使用的相关的排序代码都是来自于之前的博客。因为我们在之前实现各种排序Demo时，我们定义了相应的排序接口SortType，所以上述的七种排序对外的调用方式是一致的，所以在此基础上给出相应排序的可视化解决方案并不困难。本篇博客就会给出其相应的扩展过程。</p>
<p>如果你想对上述7中排序进行详细的了解，请移步与之前的博客《<a href="http://www.cnblogs.com/ludashi/p/6031379.html" target="_blank" rel="external">冒泡排序、插入排序、希尔排序、选择排序</a>》、《<a href="http://www.cnblogs.com/ludashi/p/6043006.html" target="_blank" rel="external">堆排序</a>》、《<a href="http://www.cnblogs.com/ludashi/p/6051871.html" target="_blank" rel="external">归并排序</a>》、《<a href="http://www.cnblogs.com/ludashi/p/6051912.html" target="_blank" rel="external">快速排序</a>》、《<a href="http://www.cnblogs.com/ludashi/p/6069807.html" target="_blank" rel="external">基数排序</a>》。废话少说，开始今天的博客。</p>
<p><span style="font-size: 14px;"><strong>一、可视化解决方案综述</strong></span></p>
<p><strong>1.交互UI综述</strong></p>
<p>在本篇博客的第一部分我们先来整体的看一下我们Demo的功能。下方就是我们今天博客中的Demo的交互示意图。上方的输入框可以输入要排序元素的个数，下方输入的是300。程序会根据你输入的个数来随机生成数据，你输入300，就会随机生成300个数据提供排序使用。下方的SegmentControl可以选择不同的排序方式，本篇博客给出了7中常用的排序方式，选择完排序方式后可以点击右上方的排序按钮进行相应的排序。</p>
<p>下方显示的不同颜色的颜色条就是我们要排序的东西，我们会按照从小到大的方式对这些色条进行排序。左图中是未排序的状态，右图中是已经排序的状态。我们上面随机生成的数据反应到色条上就是色条的高度，我们按照色条的高度进行从小到大的排序。下方会给出每种排序的介绍。　</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541042427587.png" alt="5.png" title="1483541042427587.png"></p>
<p><strong>2、部分核心代码实现</strong></p>
<p>为了实现今天的Demo，我们需要对之前我们实现的那一些列的排序的方法进行扩展。因为我们之前在实现各种排序时，我们先定义了SortType接口，依据“开放封闭原则”，我们可以为各种排序的类创建一个“简单工厂”以供我们的视图层使用。关于设计模式更多以及更详细的内容，可以移步之前发布的设计模式系列博客《设计模式Swift版》。　　</p>
<p>上方就是为各种Sort类提供的“简单工厂”。上面这个简单工厂在视图控制器中点击SegmentControl时会使用，因为我们在选择不同排序类的时候需要使用不同的排序对象。下方就是我们视图控制器对“简单工厂”的调用，当然我们所有排序类都有父类，你也可以使用“工厂方法”来创建相应的对象，在此就不做过多赘述了。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541057169487.png" alt="545446-20161115151207185-49120727.png" title="1483541057169487.png"></p>
<p>下方代码段就是点击SegmentControl要调用的方法，其中从“简单工厂”中获取到相应排序方式的对象后，然后在设置相应的闭包回调。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541089985015.png" alt="545446-20161115163118092-560378900.png" title="1483541089985015.png">　　</p>
<p><strong>二、冒泡排序</strong></p>
<p>接下来我们来逐一看一下每种排序的具体效果。下方就是冒泡排序的效果，因为冒泡排序的时间复杂度是O(n^2)的，所以我们先设置元素个数是80， 如果太大的话会比较慢。因为我们在排序步骤结果输出时，每进行一次交换操作或者比较操作让排序线程休眠0.001秒，便于我们观察整个排序过程。</p>
<p>从下方这个动图上我们不难看出冒泡的整个过程，较小的数据从右往左以此往外冒。下方这个效果还是比较直观的，整个冒泡过程就是从后往前比较，如果后边的数要比前边的小就交换。冒泡过程如下所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541263890536.gif" alt="202.gif" title="1483541263890536.gif"></p>
<p><strong>三、选择排序</strong></p>
<p>选择排序的时间复杂度也是O(n^2)。下方是“选择排序”的可视化过程，选择排序的过程就是从无序序列中找出最小的那个值放到有序序列中最后方。不断执行这个过程，我们的序列就是有序的了。下方就是选择排序的整个过程，元素的个数是80.</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541288284901.gif" alt="303.gif" title="1483541288284901.gif"></p>
<p><strong><span style="line-height: 1.8;">四、插入排序</span></strong></p>
<p>插入排序的复杂度与上述选择排序的时间复杂度一样，都是O(n^2)。下方就是插入排序的运行结果。插入排序是从无序序列中取出第一个值，然后插入到前方有序序列中相应的位置。每次插入后，有序序列就会增加1，无序序列就会减少1。下方就是插入排序的过程，如下所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541303642900.gif" alt="404.gif" title="1483541303642900.gif"></p>
<p><strong>五、希尔排序</strong></p>
<p>希尔排序的效率要高一些，其时间复杂度是O(n^(3/2))。下方就是希尔排序的具体执行步骤，希尔排序又称为缩小增量排序。该排序方式是插入排序的升级版，等增量缩小到1时，我们的序列就是有序的了。下方就是希尔排序的具体执行步骤，如下所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541325818326.gif" alt="505.gif" title="1483541325818326.gif"></p>
<p><strong>六、堆排序</strong></p>
<p>堆排序比希尔排序更为高效，其时间复杂度为O(nlog2n)。下方的“堆排序”是根据大顶堆来进行排序的，大顶堆第一个值是序列中最大的，我们可以利用这一点获取无序序列中最大的那个值。首先我们将序列调整为大顶堆，然后把大顶堆的第一个值与最后一个值进行交换，然后再将剩下的序列调整成大顶堆，然后进行下一轮的替换。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541346957748.gif" alt="606.gif" title="1483541346957748.gif"></p>
<p><strong>七、归并排序</strong></p>
<p>归并排序的时间复杂度也是O(nlog2n)。归并排序就是将无序数组拆分成多个只有一个元素的数组，然后进行两两合并。在合并的过程中将两个数组中的元素进行比较，将较小的放在前方，两个有序的数组合并后依然是有序的，然后再次进行两两合并，直到合并成一个数组为止。下方就是归并排序的执行顺序，从执行过程中，我们可以清楚的看到在排序过程中被分割的小的有序序列。归并排序的执行过程如下所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541367382388.gif" alt="707.gif" title="1483541367382388.gif"></p>
<p><strong>八、快速排序</strong></p>
<p>快速排序的时间复杂度为O(nlog2n)。下方是快速排序的执行步骤，快速排序是利用里分治法的思想。从无序序列中取出一个值，比该值大的放在前方，比该值小的放在后方。然后递归执行前半部分和后半部分依次递归下去，我们的序列就是有序的了。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541384567939.gif" alt="808.gif" title="1483541384567939.gif"></p>
<p><strong>九、基数排序</strong></p>
<p>下方是基数排序的运行效果，我们先输入1000个元素，生成1000个随机数，选择基数排序。如下所示：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20170104/1483541403606999.gif" alt="909.gif" title="1483541403606999.gif"></p>
<p><strong>十、上述排序的比较</strong></p>
<p>关于上述排序的比较，在此就不做过多赘述了，就引用“维基百科”中的表格来说明吧，如下所示:　　</p>
<p>今天博客中所涉及的Demo依然会在github上进行分享，分享地址如下。</p>
<p>github源码分享地址：<a href="https://github.com/lizelu/DataStruct-Swift/tree/master/AllKindsOfSortForiOS">https://github.com/lizelu/DataStruct-Swift/tree/master/AllKindsOfSortForiOS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.cocoachina.com/ios/20170105/18522.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20170105/1852
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="swift" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/swift/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="swift" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/swift/"/>
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="动画" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS Crash 分析</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/09/10/16.9.10_iOS_Crash%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/09/10/16.9.10_iOS_Crash分析/</id>
    <published>2016-09-10T04:44:53.000Z</published>
    <updated>2017-09-11T13:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/diyagoanyhacker/article/details/41247367" target="_blank" rel="external">http://blog.csdn.net/diyagoanyhacker/article/details/41247367</a></p>
<p><a href="http://blog.csdn.net/diyagoanyhacker/article/details/41247367" target="_blank" rel="external">iOS Crash 分析（文一）- 开始</a><br><a href="http://blog.csdn.net/diyagoanyhacker/article/details/41247389" target="_blank" rel="external">iOS Crash 分析（文二）-崩溃日志组成</a><br><a href="http://blog.csdn.net/diyagoanyhacker/article/details/41247411" target="_blank" rel="external">iOS Crash 分析（文三）- 符号化崩溃日志</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://blog.csdn.net/diyagoanyhacker/article/details/41247367&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/diyagoanyh
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="Crash" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/Crash/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="Crash" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>[转]一步一步写算法（之 算法总结）</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/07/13/16.7.13%20_%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%8B%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/07/13/16.7.13 _一步一步写算法（之算法总结）/</id>
    <published>2016-07-13T00:44:10.000Z</published>
    <updated>2017-09-11T12:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/feixiaoxing/article/details/6993718" target="_blank" rel="external">http://blog.csdn.net/feixiaoxing/article/details/6993718</a></p>
<p>&nbsp;&nbsp; &nbsp;自10月初编写算法系列的博客以来，陆陆续续以来写了几十篇。按照计划，还有三个部分的内容没有介绍，主要是（Dijkstra算法、二叉平衡树、红黑树）。这部分会在后面的博客补充完整。这里主要是做一个总结，有兴趣的朋友可以好好看看，欢迎大家提出宝贵意见。</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（1） 排序算法</strong></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6845132" target="_blank" rel="external">快速排序 </a><br>&nbsp;&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6846008" target="_blank" rel="external">合并排序</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6846664" target="_blank" rel="external">&nbsp;堆排序</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6874619" target="_blank" rel="external">&nbsp;选择排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6876831" target="_blank" rel="external">基数排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6844826" target="_blank" rel="external">冒泡排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6844826" target="_blank" rel="external">插入排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6844826" target="_blank" rel="external">希尔排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6905260" target="_blank" rel="external">链表排序</a></p>
<p>&nbsp;&nbsp; &nbsp;<strong>（2） 数据结构</strong></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6847885" target="_blank" rel="external">线性队列</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6847998" target="_blank" rel="external">线性堆栈</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6848077" target="_blank" rel="external">&nbsp;单向链表</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6849457" target="_blank" rel="external">&nbsp;双向链表</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6853455" target="_blank" rel="external">循环单向链表</a></p>
<p>&nbsp;&nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6860493" target="_blank" rel="external"> &nbsp;排序二叉树</a>（<a href="http://blog.csdn.net/feixiaoxing/article/details/6863946" target="_blank" rel="external">插入</a>，删除<a href="http://blog.csdn.net/feixiaoxing/article/details/6867460" target="_blank" rel="external">上</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6867997" target="_blank" rel="external">中</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6868221" target="_blank" rel="external">下</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6892471" target="_blank" rel="external">保存和加载</a>）</p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6885657" target="_blank" rel="external">&nbsp;哈希表</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6901584" target="_blank" rel="external">哈希二叉树</a></p>
<p>&nbsp;&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（3）图</strong></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6918768" target="_blank" rel="external">图结构</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6922766" target="_blank" rel="external">图创建</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6926004" target="_blank" rel="external">图的添加、删除</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6929586" target="_blank" rel="external">&nbsp;图的保存</a></p>
<p>&nbsp;&nbsp; &nbsp;prim算法（<a href="http://blog.csdn.net/feixiaoxing/article/details/6937338" target="_blank" rel="external">上</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6938916" target="_blank" rel="external">中</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6940335" target="_blank" rel="external">下</a>）</p>
<p>&nbsp;&nbsp; &nbsp;哈夫曼树（<a href="http://blog.csdn.net/feixiaoxing/article/details/6960990" target="_blank" rel="external">上</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6963136" target="_blank" rel="external">下</a>） &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;克鲁斯卡尔算法（<a href="http://blog.csdn.net/feixiaoxing/article/details/6969776" target="_blank" rel="external">上</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6974826" target="_blank" rel="external">中</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6978095" target="_blank" rel="external">下</a>）</p>
<p>&nbsp;&nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;<strong>（4）常用算法</strong></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6844723" target="_blank" rel="external">查找</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6847808" target="_blank" rel="external">内存分配</a></p>
<p>&nbsp;&nbsp; &nbsp;字符串查找（<a href="http://blog.csdn.net/feixiaoxing/article/details/6908453" target="_blank" rel="external">上</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6911730" target="_blank" rel="external">中</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6915588" target="_blank" rel="external">下</a>）</p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6957546" target="_blank" rel="external">通用数据结构</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6953562" target="_blank" rel="external">通用算法</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6838362" target="_blank" rel="external">循环和递归</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6838773" target="_blank" rel="external">递归和堆栈</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6839301" target="_blank" rel="external">内存中的数据</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6982932" target="_blank" rel="external">&nbsp;A*算法</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6989591" target="_blank" rel="external">可变参数</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6933416" target="_blank" rel="external">函数堆栈</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6894981" target="_blank" rel="external">递归寻路</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6897095" target="_blank" rel="external">&nbsp;广度遍历</a>、<a href="http://blog.csdn.net/feixiaoxing/article/details/6897644" target="_blank" rel="external">深度遍历</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6889211" target="_blank" rel="external">排序二叉树线索化</a></p>
<p>&nbsp;&nbsp; &nbsp;<strong>（5）趣味算法题目</strong></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6933416" target="_blank" rel="external">链表逆转</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6856686" target="_blank" rel="external">大数计算</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6856936" target="_blank" rel="external">&nbsp;n！末位0个数计算</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6860339" target="_blank" rel="external">洗牌算法</a></p>
<p>&nbsp;&nbsp; <a href="http://blog.csdn.net/feixiaoxing/article/details/6917556" target="_blank" rel="external">&nbsp;“数星星”</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6877965" target="_blank" rel="external">八皇后</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6877461" target="_blank" rel="external">数据选择</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6871294" target="_blank" rel="external">单词统计</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6871148" target="_blank" rel="external">爬楼梯</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6871148" target="_blank" rel="external">回数</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6949758" target="_blank" rel="external">链表重合</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6945730" target="_blank" rel="external">寻找丢失的数</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6991770" target="_blank" rel="external">最大公约数、最小公倍数</a></p>
<p>&nbsp;&nbsp; &nbsp;<a href="http://blog.csdn.net/feixiaoxing/article/details/6882510" target="_blank" rel="external">挑选最大的n个数</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://blog.csdn.net/feixiaoxing/article/details/6993718&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/feixiaoxing/art
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/c-c/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="数据结构和算法" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="c/c++" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS用CGContextRef画各种图形</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/06/01/16.6.1_IOS%E7%94%A8CGContextRef%E7%94%BB%E5%90%84%E7%A7%8D%E5%9B%BE%E5%BD%A2/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/06/01/16.6.1_IOS用CGContextRef画各种图形/</id>
    <published>2016-06-01T02:04:33.000Z</published>
    <updated>2017-09-11T12:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/rhljiayou/article/details/9919713" target="_blank" rel="external">http://blog.csdn.net/rhljiayou/article/details/9919713</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先了解一下CGContextRef:<br>An opaque type that represents a Quartz 2D drawing environment.<br>Graphics Context是图形上下文,可以将其理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.<br>自己学习时实现的demo，希望对大家有帮助，具体的实现看代码，并有完美的注释解释，还有一些对我帮助的博文供大家参考。都在代码里面。<br>看一下demo效果图先：<br><a href="http://img.blog.csdn.net/20130812112413640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmhsamlheW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20130812112413640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmhsamlheW91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></a></p>
<p>自定义CustomView类,CustomView.h:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span>  </span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span>  </span></div><div class="line"><span class="meta">#define PI 3.14159265358979323846  </span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomView</span> : <span class="title">UIView</span>  </span></div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>实现类CustomView.m：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CustomView.h"</span>  </span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomView</span>  </span></div><div class="line">  </div><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">// 覆盖drawRect方法，你可以在此自定义绘画和动画  </span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect  </div><div class="line">&#123;  </div><div class="line">    <span class="comment">//An opaque type that represents a Quartz 2D drawing environment.  </span></div><div class="line">    <span class="comment">//一个不透明类型的Quartz 2D绘画环境,相当于一个画布,你可以在上面任意绘画  </span></div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();  </div><div class="line">      </div><div class="line">    <span class="comment">/*写文字*/</span>  </div><div class="line">    <span class="built_in">CGContextSetRGBFillColor</span> (context,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>);<span class="comment">//设置填充颜色  </span></div><div class="line">    <span class="built_in">UIFont</span>  *font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">15.0</span>];<span class="comment">//设置  </span></div><div class="line">    [<span class="string">@"画圆："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画线及孤线："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画矩形："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">120</span>, <span class="number">80</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画扇形和椭圆："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">160</span>, <span class="number">110</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画三角形："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">220</span>, <span class="number">80</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画圆角矩形："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">260</span>, <span class="number">100</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"画贝塞尔曲线："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">    [<span class="string">@"图片："</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">340</span>, <span class="number">80</span>, <span class="number">20</span>) withFont:font];  </div><div class="line">  </div><div class="line">    <span class="comment">/*画圆*/</span>  </div><div class="line">    <span class="comment">//边框圆  </span></div><div class="line">    <span class="built_in">CGContextSetRGBStrokeColor</span>(context,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1.0</span>);<span class="comment">//画笔线的颜色  </span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">1.0</span>);<span class="comment">//线的宽度  </span></div><div class="line">    <span class="comment">//void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度   </span></div><div class="line">    <span class="comment">// x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。  </span></div><div class="line">    <span class="built_in">CGContextAddArc</span>(context, <span class="number">100</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>*PI, <span class="number">0</span>); <span class="comment">//添加一个圆  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathStroke); <span class="comment">//绘制路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">//填充圆，无边框  </span></div><div class="line">    <span class="built_in">CGContextAddArc</span>(context, <span class="number">150</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>*PI, <span class="number">0</span>); <span class="comment">//添加一个圆  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFill);<span class="comment">//绘制填充  </span></div><div class="line">      </div><div class="line">    <span class="comment">//画大圆并填充颜  </span></div><div class="line">    <span class="built_in">UIColor</span>*aColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">1</span> green:<span class="number">0.0</span> blue:<span class="number">0</span> alpha:<span class="number">1</span>];  </div><div class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, aColor.CGColor);<span class="comment">//填充颜色  </span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">3.0</span>);<span class="comment">//线的宽度  </span></div><div class="line">    <span class="built_in">CGContextAddArc</span>(context, <span class="number">250</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">2</span>*PI, <span class="number">0</span>); <span class="comment">//添加一个圆  </span></div><div class="line">    <span class="comment">//kCGPathFill填充非零绕数规则,kCGPathEOFill表示用奇偶规则,kCGPathStroke路径,kCGPathFillStroke路径填充,kCGPathEOFillStroke表示描线，不是填充  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke); <span class="comment">//绘制路径加填充  </span></div><div class="line">      </div><div class="line">    <span class="comment">/*画线及孤线*/</span>  </div><div class="line">    <span class="comment">//画线  </span></div><div class="line">    <span class="built_in">CGPoint</span> aPoints[<span class="number">2</span>];<span class="comment">//坐标点  </span></div><div class="line">    aPoints[<span class="number">0</span>] =<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">80</span>);<span class="comment">//坐标1  </span></div><div class="line">    aPoints[<span class="number">1</span>] =<span class="built_in">CGPointMake</span>(<span class="number">130</span>, <span class="number">80</span>);<span class="comment">//坐标2  </span></div><div class="line">    <span class="comment">//CGContextAddLines(CGContextRef c, const CGPoint points[],size_t count)  </span></div><div class="line">    <span class="comment">//points[]坐标数组，和count大小  </span></div><div class="line">    <span class="built_in">CGContextAddLines</span>(context, aPoints, <span class="number">2</span>);<span class="comment">//添加线  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathStroke); <span class="comment">//根据坐标绘制路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">//画笑脸弧线  </span></div><div class="line">    <span class="comment">//左  </span></div><div class="line">    <span class="built_in">CGContextSetRGBStrokeColor</span>(context, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//改变画笔颜色  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">140</span>, <span class="number">80</span>);<span class="comment">//开始坐标p1  </span></div><div class="line">    <span class="comment">//CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius)  </span></div><div class="line">    <span class="comment">//x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度,  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">148</span>, <span class="number">68</span>, <span class="number">156</span>, <span class="number">80</span>, <span class="number">10</span>);  </div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);<span class="comment">//绘画路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">//右  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">160</span>, <span class="number">80</span>);<span class="comment">//开始坐标p1  </span></div><div class="line">    <span class="comment">//CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius)  </span></div><div class="line">    <span class="comment">//x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度,  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">168</span>, <span class="number">68</span>, <span class="number">176</span>, <span class="number">80</span>, <span class="number">10</span>);  </div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);<span class="comment">//绘画路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">//右  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">150</span>, <span class="number">90</span>);<span class="comment">//开始坐标p1  </span></div><div class="line">    <span class="comment">//CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius)  </span></div><div class="line">    <span class="comment">//x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度,  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">158</span>, <span class="number">102</span>, <span class="number">166</span>, <span class="number">90</span>, <span class="number">10</span>);  </div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);<span class="comment">//绘画路径  </span></div><div class="line">    <span class="comment">//注，如果还是没弄明白怎么回事，请参考：http://donbe.blog.163.com/blog/static/138048021201052093633776/  </span></div><div class="line">      </div><div class="line">    <span class="comment">/*画矩形*/</span>  </div><div class="line">    <span class="built_in">CGContextStrokeRect</span>(context,<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">120</span>, <span class="number">10</span>, <span class="number">10</span>));<span class="comment">//画方框  </span></div><div class="line">    <span class="built_in">CGContextFillRect</span>(context,<span class="built_in">CGRectMake</span>(<span class="number">120</span>, <span class="number">120</span>, <span class="number">10</span>, <span class="number">10</span>));<span class="comment">//填充框  </span></div><div class="line">    <span class="comment">//矩形，并填弃颜色  </span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">2.0</span>);<span class="comment">//线的宽度  </span></div><div class="line">    aColor = [<span class="built_in">UIColor</span> blueColor];<span class="comment">//blue蓝色  </span></div><div class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, aColor.CGColor);<span class="comment">//填充颜色  </span></div><div class="line">    aColor = [<span class="built_in">UIColor</span> yellowColor];  </div><div class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, aColor.CGColor);<span class="comment">//线框颜色  </span></div><div class="line">    <span class="built_in">CGContextAddRect</span>(context,<span class="built_in">CGRectMake</span>(<span class="number">140</span>, <span class="number">120</span>, <span class="number">60</span>, <span class="number">30</span>));<span class="comment">//画方框  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke);<span class="comment">//绘画路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">//矩形，并填弃渐变颜色  </span></div><div class="line">    <span class="comment">//关于颜色参考http://blog.sina.com.cn/s/blog_6ec3c9ce01015v3c.html  </span></div><div class="line">    <span class="comment">//http://blog.csdn.net/reylen/article/details/8622932  </span></div><div class="line">    <span class="comment">//第一种填充方式，第一种方式必须导入类库quartcore并#import &lt;QuartzCore/QuartzCore.h&gt;，这个就不属于在context上画，而是将层插入到view层上面。那么这里就设计到Quartz Core 图层编程了。  </span></div><div class="line">    <span class="built_in">CAGradientLayer</span> *gradient1 = [<span class="built_in">CAGradientLayer</span> layer];  </div><div class="line">    gradient1.frame = <span class="built_in">CGRectMake</span>(<span class="number">240</span>, <span class="number">120</span>, <span class="number">60</span>, <span class="number">30</span>);  </div><div class="line">    gradient1.colors = [<span class="built_in">NSArray</span> arrayWithObjects:(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> whiteColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> grayColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blackColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> yellowColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> blueColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> greenColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> orangeColor].CGColor,  </div><div class="line">                        (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> brownColor].CGColor,<span class="literal">nil</span>];  </div><div class="line">    [<span class="keyword">self</span>.layer insertSublayer:gradient1 atIndex:<span class="number">0</span>];  </div><div class="line">    <span class="comment">//第二种填充方式   </span></div><div class="line">    <span class="built_in">CGColorSpaceRef</span> rgb = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();  </div><div class="line">    <span class="built_in">CGFloat</span> colors[] =  </div><div class="line">    &#123;  </div><div class="line">        <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>, <span class="number">1.00</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">1.00</span>,  </div><div class="line">    &#125;;  </div><div class="line">    <span class="built_in">CGGradientRef</span> gradient = <span class="built_in">CGGradientCreateWithColorComponents</span>  </div><div class="line">    (rgb, colors, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(colors)/(<span class="keyword">sizeof</span>(colors[<span class="number">0</span>])*<span class="number">4</span>));<span class="comment">//形成梯形，渐变的效果   </span></div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(rgb);  </div><div class="line">    <span class="comment">//画线形成一个矩形  </span></div><div class="line">    <span class="comment">//CGContextSaveGState与CGContextRestoreGState的作用  </span></div><div class="line">    <span class="comment">/* </span></div><div class="line">     CGContextSaveGState函数的作用是将当前图形状态推入堆栈。之后，您对图形状态所做的修改会影响随后的描画操作，但不影响存储在堆栈中的拷贝。在修改完成后，您可以通过CGContextRestoreGState函数把堆栈顶部的状态弹出，返回到之前的图形状态。这种推入和弹出的方式是回到之前图形状态的快速方法，避免逐个撤消所有的状态修改；这也是将某些状态（比如裁剪路径）恢复到原有设置的唯一方式。 </div><div class="line">     */  </div><div class="line">    <span class="built_in">CGContextSaveGState</span>(context);  </div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">220</span>, <span class="number">90</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">240</span>, <span class="number">90</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">240</span>, <span class="number">110</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">220</span>, <span class="number">110</span>);  </div><div class="line">    <span class="built_in">CGContextClip</span>(context);<span class="comment">//context裁剪路径,后续操作的路径  </span></div><div class="line">    <span class="comment">//CGContextDrawLinearGradient(CGContextRef context,CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint,CGGradientDrawingOptions options)  </span></div><div class="line">    <span class="comment">//gradient渐变颜色,startPoint开始渐变的起始位置,endPoint结束坐标,options开始坐标之前or开始之后开始渐变  </span></div><div class="line">    <span class="built_in">CGContextDrawLinearGradient</span>(context, gradient,<span class="built_in">CGPointMake</span>  </div><div class="line">                                (<span class="number">220</span>,<span class="number">90</span>) ,<span class="built_in">CGPointMake</span>(<span class="number">240</span>,<span class="number">110</span>),  </div><div class="line">                                kCGGradientDrawsAfterEndLocation);  </div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(context);<span class="comment">// 恢复到之前的context  </span></div><div class="line">      </div><div class="line">    <span class="comment">//再写一个看看效果  </span></div><div class="line">    <span class="built_in">CGContextSaveGState</span>(context);  </div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">260</span>, <span class="number">90</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">280</span>, <span class="number">90</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">280</span>, <span class="number">100</span>);  </div><div class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">260</span>, <span class="number">100</span>);  </div><div class="line">    <span class="built_in">CGContextClip</span>(context);<span class="comment">//裁剪路径  </span></div><div class="line">    <span class="comment">//说白了，开始坐标和结束坐标是控制渐变的方向和形状  </span></div><div class="line">    <span class="built_in">CGContextDrawLinearGradient</span>(context, gradient,<span class="built_in">CGPointMake</span>  </div><div class="line">                                (<span class="number">260</span>, <span class="number">90</span>) ,<span class="built_in">CGPointMake</span>(<span class="number">260</span>, <span class="number">100</span>),  </div><div class="line">                                kCGGradientDrawsAfterEndLocation);  </div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(context);<span class="comment">// 恢复到之前的context  </span></div><div class="line">      </div><div class="line">    <span class="comment">//下面再看一个颜色渐变的圆  </span></div><div class="line">    <span class="built_in">CGContextDrawRadialGradient</span>(context, gradient, <span class="built_in">CGPointMake</span>(<span class="number">300</span>, <span class="number">100</span>), <span class="number">0.0</span>, <span class="built_in">CGPointMake</span>(<span class="number">300</span>, <span class="number">100</span>), <span class="number">10</span>, kCGGradientDrawsBeforeStartLocation);  </div><div class="line">      </div><div class="line">    <span class="comment">/*画扇形和椭圆*/</span>  </div><div class="line">    <span class="comment">//画扇形，也就画圆，只不过是设置角度的大小，形成一个扇形  </span></div><div class="line">    aColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span> green:<span class="number">1</span> blue:<span class="number">1</span> alpha:<span class="number">1</span>];  </div><div class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, aColor.CGColor);<span class="comment">//填充颜色  </span></div><div class="line">    <span class="comment">//以10为半径围绕圆心画指定角度扇形  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">160</span>, <span class="number">180</span>);  </div><div class="line">    <span class="built_in">CGContextAddArc</span>(context, <span class="number">160</span>, <span class="number">180</span>, <span class="number">30</span>,  <span class="number">-60</span> * PI / <span class="number">180</span>, <span class="number">-120</span> * PI / <span class="number">180</span>, <span class="number">1</span>);  </div><div class="line">    <span class="built_in">CGContextClosePath</span>(context);  </div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke); <span class="comment">//绘制路径  </span></div><div class="line">  </div><div class="line">    <span class="comment">//画椭圆  </span></div><div class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">160</span>, <span class="number">180</span>, <span class="number">20</span>, <span class="number">8</span>)); <span class="comment">//椭圆  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke);  </div><div class="line">      </div><div class="line">    <span class="comment">/*画三角形*/</span>  </div><div class="line">    <span class="comment">//只要三个点就行跟画一条线方式一样，把三点连接起来  </span></div><div class="line">    <span class="built_in">CGPoint</span> sPoints[<span class="number">3</span>];<span class="comment">//坐标点  </span></div><div class="line">    sPoints[<span class="number">0</span>] =<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">220</span>);<span class="comment">//坐标1  </span></div><div class="line">    sPoints[<span class="number">1</span>] =<span class="built_in">CGPointMake</span>(<span class="number">130</span>, <span class="number">220</span>);<span class="comment">//坐标2  </span></div><div class="line">    sPoints[<span class="number">2</span>] =<span class="built_in">CGPointMake</span>(<span class="number">130</span>, <span class="number">160</span>);<span class="comment">//坐标3  </span></div><div class="line">    <span class="built_in">CGContextAddLines</span>(context, sPoints, <span class="number">3</span>);<span class="comment">//添加线  </span></div><div class="line">    <span class="built_in">CGContextClosePath</span>(context);<span class="comment">//封起来  </span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke); <span class="comment">//根据坐标绘制路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">/*画圆角矩形*/</span>  </div><div class="line">    <span class="keyword">float</span> fw = <span class="number">180</span>;  </div><div class="line">    <span class="keyword">float</span> fh = <span class="number">280</span>;  </div><div class="line">      </div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, fw, fh<span class="number">-20</span>);  <span class="comment">// 开始坐标右边开始  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, fw, fh, fw<span class="number">-20</span>, fh, <span class="number">10</span>);  <span class="comment">// 右下角角度  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">120</span>, fh, <span class="number">120</span>, fh<span class="number">-20</span>, <span class="number">10</span>); <span class="comment">// 左下角角度  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">120</span>, <span class="number">250</span>, fw<span class="number">-20</span>, <span class="number">250</span>, <span class="number">10</span>); <span class="comment">// 左上角  </span></div><div class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, fw, <span class="number">250</span>, fw, fh<span class="number">-20</span>, <span class="number">10</span>); <span class="comment">// 右上角  </span></div><div class="line">    <span class="built_in">CGContextClosePath</span>(context);  </div><div class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFillStroke); <span class="comment">//根据坐标绘制路径  </span></div><div class="line">      </div><div class="line">    <span class="comment">/*画贝塞尔曲线*/</span>  </div><div class="line">    <span class="comment">//二次曲线  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">120</span>, <span class="number">300</span>);<span class="comment">//设置Path的起点  </span></div><div class="line">    <span class="built_in">CGContextAddQuadCurveToPoint</span>(context,<span class="number">190</span>, <span class="number">310</span>, <span class="number">120</span>, <span class="number">390</span>);<span class="comment">//设置贝塞尔曲线的控制点坐标和终点坐标  </span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);  </div><div class="line">    <span class="comment">//三次曲线函数  </span></div><div class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">200</span>, <span class="number">300</span>);<span class="comment">//设置Path的起点  </span></div><div class="line">    <span class="built_in">CGContextAddCurveToPoint</span>(context,<span class="number">250</span>, <span class="number">280</span>, <span class="number">250</span>, <span class="number">400</span>, <span class="number">280</span>, <span class="number">300</span>);<span class="comment">//设置贝塞尔曲线的控制点坐标和控制点坐标终点坐标  </span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(context);  </div><div class="line">      </div><div class="line">      </div><div class="line">    <span class="comment">/*图片*/</span>  </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"apple.jpg"</span>];  </div><div class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">60</span>, <span class="number">340</span>, <span class="number">20</span>, <span class="number">20</span>)];<span class="comment">//在坐标中画出图片  </span></div><div class="line"><span class="comment">//    [image drawAtPoint:CGPointMake(100, 340)];//保持图片大小在point点开始画图片，可以把注释去掉看看  </span></div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">340</span>, <span class="number">20</span>, <span class="number">20</span>), image.CGImage);<span class="comment">//使用这个使图片上下颠倒了，参考http://blog.csdn.net/koupoo/article/details/8670024  </span></div><div class="line">      </div><div class="line"><span class="comment">//    CGContextDrawTiledImage(context, CGRectMake(0, 0, 20, 20), image.CGImage);//平铺图  </span></div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CustomView *customView = [[CustomView alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="keyword">self</span>.view.frame.size.height)];  </div><div class="line">    [<span class="keyword">self</span>.view addSubview:customView];</div></pre></td></tr></table></figure>
<p>ok，完成。<br>大家如果看过我的其它博客，会发现，这遍博客跟我的某一片博客很像，没错，就是<a href="http://blog.csdn.net/rhljiayou/article/details/7212620" target="_blank" rel="external">http://blog.csdn.net/rhljiayou/article/details/7212620</a><br>当年写andriod的时候写的一遍博客。<br>请大家尊重一下我的劳动成功，转载请注明原创地址！<br><a href="http://blog.csdn.net/rhljiayou/article/details/9919713" target="_blank" rel="external">http://blog.csdn.net/rhljiayou/article/details/9919713</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://blog.csdn.net/rhljiayou/article/details/9919713&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/rhljiayou/article
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="图形绘制" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="CGContextRef" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/CGContextRef/"/>
    
      <category term="图形绘制" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>[转]AFNetworking、ASIHTTPRequest中SSL的使用</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/05/20/16.5.20_AFNetworking%E3%80%81ASIHTTPRequest%E4%B8%ADSSL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/05/20/16.5.20_AFNetworking、ASIHTTPRequest中SSL的使用/</id>
    <published>2016-05-20T02:10:13.000Z</published>
    <updated>2017-09-11T12:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.caijixia.net/jianzhanjingyan/2014080371676.html" target="_blank" rel="external">https://www.caijixia.net/jianzhanjingyan/2014080371676.html</a></p>
<p>首先介绍下AFNetworking中的使用：<br>2.0要注意个地方：IOS7及其以后，采用AFHTTPSessionManager，IOS7之前采用AFHTTPRequestOperationManager。<br>以AFHTTPSessionManager为例，代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *httpClient = [AFHTTPSessionManager manager]; httpClient.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient.responseSerializer = [AFHTTPResponseSerializer serializer]; <span class="comment">// SSL Pinning NSString *certificatePath = [[NSBundle mainBundle] pathForResource:@certificate ofType:@der]; NSData *certificateData = [NSData dataWithContentsOfFile:certificatePath]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:YES]; [securityPolicy setPinnedCertificates:@[certificateData]]; [securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate]; [httpClient setSecurityPolicy:securityPolicy]; [httpClient GET:@http://xxxx parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; //失败信息 &#125;];</span></div></pre></td></tr></table></figure></p>
<p>以AFHTTPRequestOperationManager为例，站群，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *httpClient1 = [AFHTTPRequestOperationManager manager]; </div><div class="line">httpClient1.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient1.responseSerializer = [AFHTTPResponseSerializer serializer]; <span class="comment">// SSL Pinning </span></div><div class="line"><span class="built_in">NSString</span> *certificatePath1 = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:@certificate ofType:@der]; </div><div class="line"><span class="built_in">NSData</span> *certificateData1 = [<span class="built_in">NSData</span> dataWithContentsOfFile:certificatePath1]; AFSecurityPolicy *securityPolicy1 = [[AFSecurityPolicy alloc] init]; </div><div class="line">[securityPolicy1 setAllowInvalidCertificates:<span class="literal">YES</span>]; [securityPolicy1 setPinnedCertificates:@[certificateData1]]; </div><div class="line">[securityPolicy1 setSSLPinningMode:AFSSLPinningModeCertificate]; </div><div class="line">[httpClient setSecurityPolicy:securityPolicy1];</div><div class="line">[httpClient1 GET:@http:<span class="comment">//xxxx parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //成功信息 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //失败信息 &#125;];</span></div></pre></td></tr></table></figure>
<p>下面来讲下ASI，<br>以ASIFormDataRequest为例，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ASIFormDataRequest * request; request = [ASIFormDataRequest requestWithURL:[<span class="built_in">NSURL</span> URLWithString:@]]; </div><div class="line"><span class="built_in">NSData</span> *cerFile = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:@d1 ofType:@cer]]; </div><div class="line">SecCertificateRef cert = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)cerFile); </div><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:(__bridge <span class="keyword">id</span>)cert,<span class="literal">nil</span>];</div><div class="line">[request setClientCertificates:array]; </div><div class="line">[request setValidatesSecureCertificate:<span class="literal">NO</span>]; [request startSynchronous];</div></pre></td></tr></table></figure>
<p>ASIHTTPRequest的参考<a href="http://www.tuicool.com/articles/UN3AveR，代码就不贴了。" target="_blank" rel="external">http://www.tuicool.com/articles/UN3AveR，代码就不贴了。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://www.caijixia.net/jianzhanjingyan/2014080371676.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.caijixia.net/jianzhan
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/AFNetworking/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/AFNetworking/"/>
    
      <category term="ASIHTTPRequest" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/ASIHTTPRequest/"/>
    
      <category term="SSL" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>[转]让你快速上手Runtime</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/03/08/16.03.08_%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRuntime/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/03/08/16.03.08_让你快速上手Runtime/</id>
    <published>2016-03-08T08:44:53.000Z</published>
    <updated>2017-09-10T13:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">http://www.jianshu.com/p/e071206103a4</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:<a href="http://weibo.com/2034818060/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank" rel="external">袁峥Seemygo</a>,也可以来<a href="http://www.520it.com" target="_blank" rel="external">小码哥</a>，了解下我们的iOS培训课程。后续还会更新更多内容。。。</p>
<h3 id="一、runtime简介"><a href="#一、runtime简介" class="headerlink" title="一、runtime简介"></a>一、runtime简介</h3><ul>
<li>RunTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：<ul>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
</li>
</ul>
<h3 id="二、runtime作用"><a href="#二、runtime作用" class="headerlink" title="二、runtime作用"></a>二、runtime作用</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><ul>
<li><code>方法调用的本质</code>，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import <objc message.h=""></objc></li>
<li>消息机制简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 创建person对象</span></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法</span></div><div class="line">[p eat];</div><div class="line"></div><div class="line"><span class="comment">// 本质：让对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line"></div><div class="line"><span class="comment">// 调用类方法的方式：两种</span></div><div class="line"><span class="comment">// 第一种通过类名调用</span></div><div class="line">[Person eat];</div><div class="line"><span class="comment">// 第二种通过类对象调用</span></div><div class="line">[[Person <span class="keyword">class</span>] eat];</div><div class="line"></div><div class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</div></pre></td></tr></table></figure>
<ul>
<li>消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/304825-eced87b260a7c5d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="2-交换方法"><a href="#2-交换方法" class="headerlink" title="2.交换方法"></a>2.交换方法</h4><ul>
<li><code>开发使用场景</code>:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li><code>方式一</code>:继承系统的类，重写方法.</li>
<li><code>方式二</code>:使用runtime,交换方法.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class="line">    <span class="comment">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">// 加载分类到内存的时候调用</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换方法</span></div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 交换方法地址，相当于交换实现方式</span></div><div class="line">    method_exchangeImplementations(imageWithName, imageName);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></div><div class="line"></div><div class="line"><span class="comment">// 既能加载图片又能打印</span></div><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"加载空的图片"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li><p>交换原理：</p>
<ul>
<li>交换之前：</li>
</ul>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/304825-f53a2ea56804ad60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>*   交换之后：
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/304825-c76afa4089255d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3.动态添加方法"></a>3.动态添加方法</h4><ul>
<li><code>开发使用场景</code>：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li><code>经典面试题</code>：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li><code>简单使用</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// void(*)()</span></div><div class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></div><div class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</div><div class="line">        <span class="comment">// 动态添加eat方法</span></div><div class="line"></div><div class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></div><div class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></div><div class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></div><div class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="4-给分类添加属性"><a href="#4-给分类添加属性" class="headerlink" title="4.给分类添加属性"></a>4.给分类添加属性</h4><ul>
<li><code>原理</code>：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line">    <span class="comment">// 给系统NSObject类动态添加属性name</span></div><div class="line"></div><div class="line">    <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    objc.name = <span class="string">@"小码哥"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 定义关联的key</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></div><div class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></div><div class="line">    <span class="comment">// 第三个参数：关联的value</span></div><div class="line">    <span class="comment">// 第四个参数:关联的策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="5-字典转模型"><a href="#5-字典转模型" class="headerlink" title="5.字典转模型"></a>5.字典转模型</h4><ul>
<li><code>设计模型</code>：字典转模型的第一步<ul>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>问题：一个一个的生成模型属性，很慢？</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li>解决：提供一个分类，专门根据字典生成对应的属性字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Log</span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 自动打印属性字符串</span></div><div class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 拼接属性字符串代码</span></div><div class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</div><div class="line"></div><div class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 类型经常变，抽出来</span></div><div class="line">         <span class="built_in">NSString</span> *type;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</div><div class="line">            type = <span class="string">@"NSString"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</div><div class="line">            type = <span class="string">@"NSArray"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</div><div class="line">            type = <span class="string">@"int"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</div><div class="line">            type = <span class="string">@"NSDictionary"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 属性字符串</span></div><div class="line">        <span class="built_in">NSString</span> *str;</div><div class="line">        <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</div><div class="line">            str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 每生成属性字符串，就自动换行。</span></div><div class="line">        [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式一：KVC</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Status</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)statusWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    Status *status = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    [status setValuesForKeysWithDictionary:dict];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> status;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li><code>KVC字典转模型弊端</code>：必须保证，模型中的属性和字典中的key一一对应。<ul>
<li>如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code><br>报<code>key</code>找不到的错。</li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖，<br>就能继续使用KVC，字典转模型了。</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>字典转模型的方式二</code>：Runtime<ul>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line">    <span class="comment">// 解析Plist文件</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"status.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="built_in">NSDictionary</span> *statusDict = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class="line"></div><div class="line">    <span class="comment">// 获取字典数组</span></div><div class="line">    <span class="built_in">NSArray</span> *dictArr = statusDict[<span class="string">@"statuses"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 自动生成模型的属性字符串</span></div><div class="line"><span class="comment">//    [NSObject resolveDict:dictArr[0][@"user"]];</span></div><div class="line"></div><div class="line">    _statuses = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="comment">// 遍历字典数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line"></div><div class="line">        Status *status = [Status modelWithDict:dict];</div><div class="line"></div><div class="line">        [_statuses addObject:status];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试数据</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,_statuses,[_statuses[<span class="number">0</span>] user]);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行时</span></div><div class="line"></div><div class="line">    <span class="comment">// 0.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值</span></div><div class="line"></div><div class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></div><div class="line">    <span class="comment">// Ivar：成员属性的意思</span></div><div class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></div><div class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></div><div class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></div><div class="line">    <span class="comment">/* 类似下面这种写法</span></div><div class="line"></div><div class="line">     Ivar ivar;</div><div class="line">     Ivar ivar1;</div><div class="line">     Ivar ivar2;</div><div class="line">     // 定义一个ivar的数组a</div><div class="line">     Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">     // 用一个Ivar *指针指向数组第一个元素</div><div class="line">     Ivar *ivarList = a;</div><div class="line"></div><div class="line">     // 根据指针访问数组第一个元素</div><div class="line">     ivarList[0];</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 获取类中的所有成员属性</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 根据角标，从数组取出对应的成员属性</span></div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">        <span class="comment">// 获取成员属性名</span></div><div class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">        <span class="comment">// 处理成员属性名-&gt;字典中的key</span></div><div class="line">        <span class="comment">// 从第一个角标开始截取</span></div><div class="line">        <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">        <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">        <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">        <span class="comment">// 判断下value是否是字典</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 字典转模型</span></div><div class="line">            <span class="comment">// 获取模型的类对象，调用modelWithDict</span></div><div class="line">            <span class="comment">// 模型的类名已知，就是成员属性的类型</span></div><div class="line"></div><div class="line">            <span class="comment">// 获取成员属性类型</span></div><div class="line">           <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">          <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></div><div class="line">            <span class="comment">// 裁剪类型字符串</span></div><div class="line">            <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">           type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">            range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">            <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></div><div class="line">          type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line">            <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">            Class modelClass = <span class="built_in">NSClassFromString</span>(type);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line"></div><div class="line">                <span class="comment">// 把字典转模型</span></div><div class="line">                value  =  [modelClass modelWithDict:value];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">               Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                  <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></div><div class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.jianshu.com/p/e071206103a4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e071206103a4&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="runtime" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/runtime/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="runtime" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/runtime/"/>
    
      <category term="动态运行时" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
      <category term="移动开发" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS开发之AFNetworking 3.0.4使用</title>
    <link href="https://github.com/zhoutq/zhoutq.github.io/2016/02/05/16.2.9_iOS%E5%BC%80%E5%8F%91%E4%B9%8BAFNetworking3.0.4%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/zhoutq/zhoutq.github.io/2016/02/05/16.2.9_iOS开发之AFNetworking3.0.4使用/</id>
    <published>2016-02-05T08:44:53.000Z</published>
    <updated>2017-09-12T13:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.jianshu.com/p/11bb0d4dc649" target="_blank" rel="external">http://www.jianshu.com/p/11bb0d4dc649</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天使用Cocoapods导入AFN做POST的时候，导入的最新版的3.0.4,突然发现找不到AFHTTPRequestOperationManager了。。。上github上一看，发现没有这个了。刚开始以为是cocoapods没有给我导进去，因为是小demo，就想自己写一个网络请求的，发现也没有这NSURLConnection了，被弃用了，突然意识到，这个就是AFHTTPRequestOperationManager找不到的原因了，它是基于NSURLConnection封装的！！于是找了一下，现在都用的是NSURLSession了，AFN中用的是AFHTTPSessionManager了~~</p>
<p>特地记录下来，以便遇到这个的朋友们看看！</p>
<p>ps:如果想用以前的话，cocoapods 就不要用最新的版本了，2.6的上面有。</p>
<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; </div><div class="line"></div><div class="line">[manager GET:URL parameters:<span class="literal">nil</span> progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;  </div><div class="line"></div><div class="line">&#125;     </div><div class="line">success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;  </div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"这里打印请求成功要做的事"</span>);  </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull   error) &#123;  </div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);  <span class="comment">//这里打印错误信息</span></div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSMutableDictionary</span> *parameters = @&#123;<span class="string">@""</span>:<span class="string">@""</span>,<span class="string">@""</span>:<span class="string">@""</span>&#125;;</div><div class="line"></div><div class="line">[manager POST:URL parameters:parameters progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>暂时用的比较多的就这两个，用到其他的 再来更新！！</p>
<p>最近又用到了下载，索性 上传下载都研究了一下 ，补充进来</p>
<h3 id="补充试用AFN3-0下载方法"><a href="#补充试用AFN3-0下载方法" class="headerlink" title="补充试用AFN3.0下载方法"></a>补充试用AFN3.0下载方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  AFN3.0 下载</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)downLoad&#123;</div><div class="line"></div><div class="line"><span class="comment">//1.创建管理者对象</span></div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line"><span class="comment">//2.确定请求的URL地址</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line"></div><div class="line"><span class="comment">//3.创建请求对象</span></div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line"></div><div class="line"><span class="comment">//下载任务</span></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [manager downloadTaskWithRequest:request progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</div><div class="line"><span class="comment">//打印下下载进度</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"%lf"</span>,<span class="number">1.0</span> * downloadProgress.completedUnitCount / downloadProgress.totalUnitCount);</div><div class="line"></div><div class="line">&#125; destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</div><div class="line"><span class="comment">//下载地址</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"默认下载地址:%@"</span>,targetPath);</div><div class="line"></div><div class="line"><span class="comment">//设置下载路径，通过沙盒获取缓存地址，最后返回NSURL对象</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)lastObject];</div><div class="line"><span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</div><div class="line"></div><div class="line"></div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line"></div><div class="line"><span class="comment">//下载完成调用的方法</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"下载完成："</span>);</div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"%@--%@"</span>,response,filePath);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//开始启动任务</span></div><div class="line">[task resume];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AFN3-0-上传"><a href="#AFN3-0-上传" class="headerlink" title="AFN3.0 上传"></a>AFN3.0 上传</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  AFN 3.0 上传</div><div class="line">*      有两种方式</div><div class="line">*          upLoad1 和 upLoad2</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//第一种方法是通过工程中的文件进行上传</span></div><div class="line">- (<span class="keyword">void</span>)upLoad1&#123;</div><div class="line"></div><div class="line"><span class="comment">//1。创建管理者对象</span></div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line"></div><div class="line"><span class="comment">//2.上传文件</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"username"</span>:<span class="string">@"1234"</span>&#125;;</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *urlString = <span class="string">@"22222"</span>;</div><div class="line">[manager POST:urlString parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</div><div class="line"><span class="comment">//上传文件参数</span></div><div class="line"><span class="built_in">UIImage</span> *iamge = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123.png"</span>];</div><div class="line"><span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(iamge);</div><div class="line"><span class="comment">//这个就是参数</span></div><div class="line">[formData appendPartWithFileData:data name:<span class="string">@"file"</span> fileName:<span class="string">@"123.png"</span> mimeType:<span class="string">@"image/png"</span>];</div><div class="line"></div><div class="line">&#125; progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line"><span class="comment">//打印下上传进度</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"%lf"</span>,<span class="number">1.0</span> *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount);</div><div class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line"><span class="comment">//请求成功</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"请求成功：%@"</span>,responseObject);</div><div class="line"></div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line"></div><div class="line"><span class="comment">//请求失败</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"请求失败：%@"</span>,error);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二种是通过URL来获取路径，进入沙盒或者系统相册等等</span></div><div class="line">- (<span class="keyword">void</span>)upLoda2&#123;</div><div class="line"><span class="comment">//1.创建管理者对象</span></div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line"><span class="comment">//2.上传文件</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"username"</span>:<span class="string">@"1234"</span>&#125;;</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *urlString = <span class="string">@"22222"</span>;</div><div class="line">[manager POST:urlString parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</div><div class="line"></div><div class="line">[formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"文件地址"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"1234.png"</span> mimeType:<span class="string">@"application/octet-stream"</span> error:<span class="literal">nil</span>];</div><div class="line">&#125; progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line"></div><div class="line"><span class="comment">//打印下上传进度</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"%lf"</span>,<span class="number">1.0</span> *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount);</div><div class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line"></div><div class="line"><span class="comment">//请求成功</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"请求成功：%@"</span>,responseObject);</div><div class="line"></div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line"></div><div class="line"><span class="comment">//请求失败</span></div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"请求失败：%@"</span>,error);</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="监测当前网络状态（网络监听）"><a href="#监测当前网络状态（网络监听）" class="headerlink" title="监测当前网络状态（网络监听）"></a>监测当前网络状态（网络监听）</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)AFNetworkStatus&#123;</div><div class="line"></div><div class="line"><span class="comment">//1.创建网络监测者</span></div><div class="line">AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];</div><div class="line"></div><div class="line"><span class="comment">/*枚举里面四个状态  分别对应 未知 无网络 数据 WiFi</span></div><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">AFNetworkReachabilityStatusUnknown          = -1,      未知</div><div class="line">AFNetworkReachabilityStatusNotReachable     = 0,       无网络</div><div class="line">AFNetworkReachabilityStatusReachableViaWWAN = 1,       蜂窝数据网络</div><div class="line">AFNetworkReachabilityStatusReachableViaWiFi = 2,       WiFi</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"></div><div class="line">[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line"><span class="comment">//这里是监测到网络改变的block  可以写成switch方便</span></div><div class="line"><span class="comment">//在里面可以随便写事件</span></div><div class="line"><span class="keyword">switch</span> (status) &#123;</div><div class="line"><span class="keyword">case</span> AFNetworkReachabilityStatusUnknown:</div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"未知网络状态"</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"无网络"</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"蜂窝数据网"</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</div><div class="line"><span class="built_in">WKNSLog</span>(<span class="string">@"WiFi网络"</span>);</div><div class="line"></div><div class="line"><span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">default</span>:</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;] ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有知道新版本用法的各位大神请不吝赐教，小白再次拜谢了！！</p>
<p>在使用的过程中遇到了一些问题的 总结，在这里，有需要的亲们可以去看一下，就不往这里放了，占地方。。。。</p>
<p>多谢各位道友的指正，在下载里面那个地方return [NSURL fileURLWithPath:filePath]; 已经改过来了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.jianshu.com/p/11bb0d4dc649&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/11bb0d4dc649&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/categories/iOS/AFNetworking/"/>
    
    
      <category term="iOS" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/iOS/"/>
    
      <category term="AFNetworking" scheme="https://github.com/zhoutq/zhoutq.github.io/tags/AFNetworking/"/>
    
  </entry>
  
</feed>
