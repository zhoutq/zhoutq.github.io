<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[数据结构与算法之排序基本用法(C语言)]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F09%2F17%2F17.09.16_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C(C%E8%AF%AD%E8%A8%80)%2F</url>
      <content type="text"><![CDATA[前言项目Git地址：DataStructuresAndAlgorithms-Sort。 基本用法： 冒泡排序 插入排序 折半插入排序 选择排序 快速排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//// main.c// SortTest//// Created by zhoutq on 2017/9/17.// Copyright © 2017年 zhoutq. All rights reserved.//#include &lt;stdio.h&gt;void printfSort(int a[], int n) &#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d,",a[i]); &#125; printf("\n");&#125;// 冒泡排序：时间复杂度 -- O(n^2)/*在冒泡排序过程中会将数组分成两部分，一部分是已经有序的数列，一部分是无序的数列。无序数列中不断的将其中最小的值往有序序列中冒泡，泡冒完后，我们的序列就创建好了。*/void bubbleSort(int a[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - 1 - i; j++) &#123; // 如果前面的大于后面的，将大的放到后面 if (a[j] &gt; a[j + 1]) &#123; int temp; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; // 再用后面的和它后面的比较 &#125; &#125;&#125;// 插入排序：时间复杂度 -- O(n^2)/*插入排序算是比较好理解的排序方式，插入排序也是将要排序的数列分为两部分，前半部分是已经排好序的，后半部分则是无序的。插入排序中的插入是指“取出无序数列中第一个值，插入到有序数列中相应的位置”。其实这个插入过程也是不断比较和交换的过程。*/void insertSort(int a[], int n) &#123; for (int i = 1; i &lt; n; i ++) &#123; int j = i - 1; //有序数列end int num = a[i]; // 带插入数 while (j &gt;= 0 &amp;&amp; a[j] &gt; num) &#123; // 如果num比有序比较数大，则将比较数往后移动 （从后往前查找，大的往后移动） a[j + 1] = a[j]; j--; &#125; a[j + 1] = num; &#125;&#125;//折半插入void binaryInsertSort(int a[], int n)&#123; for (int i = 1; i &lt; n; i++) &#123; int low=0,high=i; int num = a[i]; //复制为哨兵，即存储待排序元素 while (low &lt;= high) &#123; //查找在有序表的插入位置 (遍历表) int m = (low + high) / 2; if(num&lt;a[m]) &#123; high = m - 1; &#125; else &#123; low = m + 1; &#125; &#125; int j = i-1; for (j = i-1; j &gt;= high + 1; j--) &#123; a[j + 1] = a[j]; &#125; a[j+1] = num; //插入到正确位置 &#125;&#125;// 选择排序：时间复杂度 -- O(n^2)/* 在选择排序过程中，数组仍然被分作有序和无序两部分。而选择排序中的“选择”是指不断从无序序列中选择最小的值放入到有序序列的最后的位置，换句话说就是从现有的无序序列中找出那个最小的值，然后与无序序列的第一个值进行交换，然后缩小无序序列的范围即可。因为有序序列的最后一个值与无序序列的第一个值紧挨着，交换后，这个无序序列中的第一个值就成了有序序列的最后一个值。重复这个选择的过程，我们的数组就会变得有序。*/void selectSort(int a[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) &#123; if (a[j] &lt; a[min]) &#123; min = j; //记录最小的数，继续查询 &#125; &#125; if (min != i) &#123; int temp; temp = a[i]; a[i] = a[min]; a[min] = temp; &#125; &#125;&#125;// 快速排序：时间复杂度 -- O(nlogn)/* 快速排序的思想主要是取出无序序列中第一个值，然后通过比较将比该值小的元素放到该值的前方，将比该值大的元素放在该值的后方。 这样一来该值前方的数据都要比该值小，该值后方的数据都要比该值大。然后再次对前半部分和后边半部分无序的数列进行上述操作， 这样不断的操作，无序的序列的规模不断被缩小。等问题的规模被缩小到一定程度后，我们的序列就变的有序了*/void quickSort(int a[], int left, int right)&#123; int i, j, key; if(left &gt; right) return; key = a[left]; i = left; j = right; while(i != j) &#123; // 右边的从右到左查找比key小的数，大于key则继续往左走 while(a[j] &gt;= key &amp;&amp; i &lt; j) j--; // 左边的从左到右查找比key大的数，小于key则继续往右走 while(a[i] &lt;= key &amp;&amp; i &lt; j) i++; // 表示已经查到，则交换左右俩数 if(i &lt; j) &#123; a[i] = a[i]^a[j]; a[j] = a[i]^a[j]; a[i] = a[i]^a[j]; &#125; &#125; a[left] = a[i]; a[i] = key; quickSort(a, left, i - 1); quickSort(a, i + 1, right);&#125;int main(int argc, const char * argv[]) &#123; int a[10] = &#123;2,3,1,6,9,1,4,8,5,7&#125;; // int a[10] = &#123;2,2,2,2,2,1,1,1,1,1&#125;; printfSort(a, 10); // bubbleSort(a, 10); // insertSort(a, 10); // binaryInsertSort(a, 10); // selectSort(a, 10); quickSort(a, 0, 9); printfSort(a, 10); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法之二叉树基本用法(C语言)]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F09%2F16%2F17.09.16_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(C%E8%AF%AD%E8%A8%80)%2F</url>
      <content type="text"><![CDATA[前言项目Git地址：DataStructuresAndAlgorithms-BTree。 基本用法： 创建二叉树 前序遍历二叉树 中序遍历二叉树 后序遍历二叉树 二叉树节点个数 二叉树叶子节点个数 二叉树第k层节点个数 二叉树深度 二叉树转换为有序双向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243//// main.c// BTreeTest//// Created by zhoutq on 2017/9/16.// Copyright © 2017年 zhoutq. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;malloc/malloc.h&gt;#include &lt;stdlib.h&gt;/*定义二叉树节点类型*/typedef struct BNode &#123; char data; struct BNode *lChild, *rChild;&#125;BTree;/*创建二叉树:先创建根节点，然后递归用同样的方法创建其左右子节点 a / \ b e / \ / c d f 如果创建上面二叉树，‘ ’表示结束子节点创建，则输入字符串为: ‘a’ - 'b' - 'c' - ' ' - ' ' - 'd' - ' ' - ' ' - 'e' - 'f' - ' ' - ' ' - ' '*/// 键盘输入读取BTree *CreateBTree() &#123; char c; printf("please input btree data:"); scanf("%c",&amp;c); getchar(); // 屏蔽回车 if (c == ' ') &#123; return NULL; &#125; BTree *bt = (BTree *)malloc(sizeof(BTree)); bt-&gt;data = c; bt-&gt;lChild = CreateBTree(); // 递归创建左子节点 bt-&gt;rChild = CreateBTree(); // 递归创建右子节点 return bt;&#125;// 数组读取BTree *CreateBTree2(char a[]) &#123; static int n = 0; char c = a[n++]; if (c == ' ') &#123; return NULL; &#125; BTree *bt = (BTree *)malloc(sizeof(BTree)); bt-&gt;data = c; bt-&gt;lChild = CreateBTree2(a); // 递归创建左子节点 bt-&gt;rChild = CreateBTree2(a); // 递归创建右子节点 return bt;&#125;/*前序遍历二叉树：遍历顺序 root -&gt; lChild -&gt; rChild，示例结果：abcdef*/void PreorderPrintfBTree(BTree *bt) &#123; if (!bt) &#123; return; &#125; printf("%c",bt-&gt;data); PreorderPrintfBTree(bt-&gt;lChild); PreorderPrintfBTree(bt-&gt;rChild);&#125;/*中序遍历二叉树：遍历顺序 lChild -&gt; root -&gt; rChild，示例结果：cbdafe*/void InorderPrintfBTree(BTree *bt) &#123; if (!bt) &#123; return; &#125; InorderPrintfBTree(bt-&gt;lChild); printf("%c",bt-&gt;data); InorderPrintfBTree(bt-&gt;rChild);&#125;/*后序遍历二叉树：遍历顺序 lChild -&gt; rChild -&gt; root，示例结果：cdbfea*/void PostorderPrintfBTree(BTree *bt) &#123; if (!bt) &#123; return; &#125; PostorderPrintfBTree(bt-&gt;lChild); PostorderPrintfBTree(bt-&gt;rChild); printf("%c",bt-&gt;data);&#125;/*二叉树节点个数：如果二叉树为空，则二叉树节点个数为 0 ，如果不为空，则二叉树节点个数为左子节点个数 + 右子节点个数 + 1(该根节点)*/int NodeCountBTree(BTree *bt) &#123; if (!bt) &#123; return 0; &#125; return (NodeCountBTree(bt-&gt;lChild) + NodeCountBTree(bt-&gt;rChild) + 1);&#125;/*二叉树叶子节点个数：如果二叉树为空，则二叉树叶子节点个数为 0 ，如果不为空，但左右子节点都为空，则二叉树叶子节点个数为 1如果不为空，则二叉树叶子节点个数为左右子节点叶子节点个数之和*/int LeafNodeCountBTree(BTree *bt) &#123; if (!bt) &#123; return 0; &#125; if (!bt-&gt;lChild &amp;&amp; !bt-&gt;rChild) &#123; return 1; &#125; return (LeafNodeCountBTree(bt-&gt;lChild) + LeafNodeCountBTree(bt-&gt;rChild));&#125;/*二叉树第k层节点个数：如果二叉树为空，则二叉树叶子节点个数为 0 ，如果是第一层，则二叉树第k层节点个数为 1如果不为空，则二叉树第k层节点个数为左右子节点第k-1层节点个数之和*/int KLevelNoteCount(BTree * bt, int k)&#123; if (!bt) &#123; return 0; &#125; if (1 == k) &#123; return 1; &#125; return KLevelNoteCount(bt-&gt;lChild, k - 1) + KLevelNoteCount(bt-&gt;rChild, k - 1);&#125;/*二叉树深度：如果二叉树为空，则二叉树深度为 0 ，如果不为空，则二叉树深度为子节点深度(左右子节点深度最大值) + 1(该根节点)*/int DepthBTree(BTree *bt) &#123; if (!bt) &#123; return 0; &#125; // 定义一个max的block函数 int (^max)(int , int ) = ^int(int a, int b)&#123; return a &gt; b ? a:b; &#125;; return (max(DepthBTree(bt-&gt;lChild),DepthBTree(bt-&gt;rChild)) + 1);&#125;/*二叉树转换为有序双向链表：转换顺序为 lChild + root + rChild*/void BTreeToBLinkList(BTree *bt, BTree **head,BTree **end) &#123; if(!bt) &#123; *head = NULL; *end = NULL; return; &#125; BTree *lHead, *lEnd, *rHead, *rEnd; BTreeToBLinkList(bt-&gt;lChild, &amp;lHead, &amp;lEnd); BTreeToBLinkList(bt-&gt;rChild, &amp;rHead, &amp;rEnd); bt-&gt;lChild = lEnd; // 左右子节点各自转换完成后，根节点的左子节点指向左子节点的end bt-&gt;rChild = rHead; // 左右子节点各自转换完成后，根节点的右子节点指向右子节点的head if (lEnd) lEnd-&gt;rChild = bt; // 同时，如果左子节点的end存在，则其右子节点指向根节点 if (rHead) rHead-&gt;lChild = bt; // 同时，如果右子节点的head存在，则其左子节点指向根节点 // 返回head和end *head = lHead ? : bt; // 如果左子节点lHead存在，则head为lHead,否则为根节点 if (end) *end = rEnd ? : bt; // 如果右子节点rEnd存在，则end为rEnd,否则为根节点, 加if判断是因为main函数调用的时候end入参为NULL，赋值会奔溃。&#125;int main(int argc, const char * argv[]) &#123; char a[] = &#123;'a','b','c',' ',' ','d',' ',' ','e','f',' ',' ',' '&#125;; BTree *bt = CreateBTree2(a); //CreateBTree(); PreorderPrintfBTree(bt); printf("\n"); // InorderPrintfBTree(bt); // printf("\n"); // PostorderPrintfBTree(bt); // printf("\n"); // printf("node count: %d\n",NodeCountBTree(bt)); // printf("leaf node count: %d\n",LeafNodeCountBTree(bt)); // printf("k leve node count: %d\n",KLevelNoteCount(bt, 2)); // printf("depth: %d\n",DepthBTree(bt)); BTree *head; BTreeToBLinkList(bt, &amp;head, NULL); // 定义一个打印转换后双链表的block函数 void (^PrintfDLinkList)(BTree *) = ^(BTree *head)&#123; BTree *p = head; while (p) &#123; printf("%c,",p-&gt;data); p = p-&gt;rChild; &#125; printf("\n"); &#125;; PrintfDLinkList(head); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法之双链表基本用法(C语言)]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F09%2F15%2F17.09.15_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95C%E8%AF%AD%E8%A8%80)%2F</url>
      <content type="text"><![CDATA[前言项目Git地址：DataStructuresAndAlgorithms-DLinkList。 基本用法： 创建双链表 打印双链表 双链表指定节点数之前插入新的元素 双链表删除元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// main.c// DLinkList//// Created by zhoutq on 2017/9/15.// Copyright © 2017年 zhoutq. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc/malloc.h&gt;/*定义双链表节点类型*/typedef struct DNode &#123; char data; struct DNode *pre; struct DNode *next;&#125;DLinkList;/*创建双链表*/DLinkList* CreateDLinkList(char a[], int n) &#123; // 创建头结点 DLinkList *head = (DLinkList *)malloc(sizeof(DLinkList)); head-&gt;pre = NULL; head-&gt;next = NULL; DLinkList *p, *q; p = head; // p 指向头结点 for (int i = 0; i &lt; n; i++) &#123; q = (DLinkList *)malloc(sizeof(DLinkList)); q-&gt;data = a[i]; q-&gt;pre = p; // 新创建节点的pre指向p q-&gt;next = NULL; p-&gt;next = q; // p的next指向q p = q; // p 后移 &#125; return head;&#125;/*打印双链表*/void PrintfDLinkList(DLinkList *head) &#123; DLinkList *p = head-&gt;next; while (p) &#123; printf("%c,",p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125;/*双链表指定节点数之前插入新的元素: a前面插入c*/void InsterDLinkList(DLinkList *head, char a, char c) &#123; DLinkList *p = head; DLinkList *q = NULL; while (p-&gt;next) &#123; // 判断 p 下一个节点数据是否为 a 数据 if (p-&gt;next-&gt;data == a) &#123; break; &#125; p = p-&gt;next; &#125; // break 后 创建新节点 q q = (DLinkList *)malloc(sizeof(DLinkList)); q-&gt;data = c; q-&gt;pre = p; q-&gt;next = p-&gt;next; // 将 q-&gt;next 为原先 p-&gt;next p-&gt;next-&gt;pre = q; // p-&gt;next 即data == a的节点的pre指向q p-&gt;next = q; // 然后 p-&gt;next 指向 q&#125;/*双链表删除元素*/void DeleteDLinkList(DLinkList *head, char a) &#123; DLinkList *p = head-&gt;next; while (p) &#123; if (p-&gt;data == a) &#123; p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; free(p); break; &#125; p = p-&gt;next; &#125;&#125;int main(int argc, const char * argv[]) &#123; char a[5] = &#123;'a','c','d','e','f'&#125;; DLinkList *dlist = CreateDLinkList(a, 5); PrintfDLinkList(dlist); InsterDLinkList(dlist, 'c', 'b'); PrintfDLinkList(dlist); DeleteDLinkList(dlist, 'c'); PrintfDLinkList(dlist); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法之单链表基本用法(C语言)]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F09%2F14%2F17.09.14_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95(C%E8%AF%AD%E8%A8%80)%2F</url>
      <content type="text"><![CDATA[前言关于单链表的概念，暂时未写，后期有时间更新。暂时忽律细节处理，以最简单的代码理解单链表基本操作！如果喜欢我的文章，可以关注我的GitHub:zhoutq,该项目已经上传到Git-&gt;DataStructuresAndAlgorithms-LinkList。 基本用法： 创建单链表 打印单链表 销毁单链表 单链表指定节点数之前插入新的元素 单链表删除元素 判断单链表是否为空 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//// main.c// LinkList//// Created by zhoutq on 2017/9/14.// Copyright © 2017年 zhoutq. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc/malloc.h&gt;/*定义单链表节点类型*/typedef struct Node &#123; char data; struct Node *next;&#125;LinkList;/*创建单链表*/LinkList* CreateLinkList(char a[], int n) &#123; // 初始化头结点 LinkList *head = (LinkList *)malloc(sizeof(LinkList)); head-&gt;next = NULL; LinkList *p, *q; // p 前一个节点，q 后一个节点 p = head; // p 指向头结点 for (int i = 0; i &lt; n; i++) &#123; // q 开辟空间，存储数据 q = (LinkList *)malloc(sizeof(LinkList)); q-&gt;data = a[i]; q-&gt;next = NULL; p-&gt;next = q; // 将 q 接入到 p 后面 p = q; // p 后移到q位置 &#125; return head;&#125;/*打印单链表*/void PrintfLinkList(LinkList *head) &#123; LinkList *p = head-&gt;next; while (p) &#123; printf("%c,",p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125;/*销毁单链表*/void DestoryLinkList(LinkList *head) &#123; LinkList *p, *q; p = head; while (p) &#123; q = p-&gt;next; free(p); p = q; &#125;&#125;/*单链表指定节点数之前插入新的元素*/void InsterLinkList(LinkList *head, char a, char c) &#123; LinkList *p = head; LinkList *q = NULL; while (p-&gt;next) &#123; if (p-&gt;next-&gt;data == a) &#123; break; &#125; p = p-&gt;next; &#125; q = (LinkList *)malloc(sizeof(LinkList)); q-&gt;data = c; q-&gt;next = p-&gt;next; p-&gt;next = q;&#125;/*单链表删除元素*/void DeleteLinkList(LinkList *head, char a) &#123; LinkList *p = head; LinkList *q = p-&gt;next; while (q) &#123; if (q-&gt;data == a) &#123; p-&gt;next = q-&gt;next; free(q); break; &#125; p = q; q = p-&gt;next; &#125;&#125;/*获取单链表中某个元素的位置*//*获取单链表中指定位置的元素值*//*求单链表的长度*//*判断单链表是否为空*/void EmptyLinkList(LinkList *head) &#123; LinkList *p = head; if (!p-&gt;next) &#123; printf("LinkList is empty\n"); &#125; else &#123; printf("LinkList not empty\n"); &#125;&#125;int main(int argc, const char * argv[]) &#123; char a[5] = &#123;'a','c','d','e','f'&#125;; LinkList *list = CreateLinkList(a, 5); PrintfLinkList(list); EmptyLinkList(list); InsterLinkList(list, 'c', 'b'); PrintfLinkList(list); EmptyLinkList(list); // DestoryLinkList(list); // PrintfLinkList(list); // EmptyLinkList(list); DeleteLinkList(list, 'c'); PrintfLinkList(list); EmptyLinkList(list); DeleteLinkList(list, 'f'); PrintfLinkList(list); EmptyLinkList(list); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直播专题]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F09%2F11%2F17.9.11_%E7%9B%B4%E6%92%AD%E4%B8%93%E9%A2%98%2F</url>
      <content type="text"><![CDATA[[ 直播协议的选择：RTMP vs. HLS文章转自：直播协议的选择：RTMP vs. HLS 前言 随着直播业务的兴起，越来越多的直播平台开始涌现，这火热的程度好像一个应用不带上直播业务出来都不好意思跟人打招呼。想要… 一步步搭建视频直播系统，基于LFLiveKit＋ijkplayer＋rtmp（iOS端）本文主要使用的三个技术： 推流：LFLiveKit 播放：ijkplayer 服务器:nginx+rtmp+ffmpeg 有了这三点技术就可以完成一个简约的直播系统。效果图如… iOS-直播开发(开发从底层做起)一直在忙, 也没写过几次博客! 但一直热衷于直播开发技术, 公司又不是直播方向的, 所以就年前忙里偷闲研究了一下直播开发, 然后翻阅了很多大神的技术博客等, 写了一个简单的D… HTTP Live Streaming直播(iOS直播)技术分析与实现作者：HBStream不经意间发现，大半年没写博客了，自觉汗颜。实则2012后半年，家中的事一样接着一样发生，实在是没有时间。快过年了，总算忙里偷闲，把最近的一些技术成果，总… iOS中集成ijkplayer视频直播框架ijkplayer是一款做视频直播的框架,基于ffmpeg,支持Android和iOS,网上也有很多集成说明,但是个人觉得还是不够详细,在这里详细的讲一下在iOS中如何集成i… 如何快速的开发一个完整的iOS直播app(原理篇)目录 【如何快速的开发一个完整的iOS直播app】(原理篇) 【如何快速的开发一个完整的iOS直播app】(播放篇) 【如何快速的开发一个完整的iOS直播app】(采集篇) … iOS视频直播初窥:高仿&lt;喵播APP&gt;效果图gif1gif2由于licecap录制的GIF失帧太严重,都模糊掉了,再放两张高清截图png1png2前言今年三月份，斗鱼获腾讯领投的1亿美元融资的消息被各大平台报道转… 1小时学会：最简单的iOS直播推流（一）介绍最简单的iOS 推流代码，视频捕获，软编码(faac，x264)，硬编码（aac，h264），美颜，flv编码，rtmp协议，陆续更新代码解析，你想学的知识这里都有，愿意懂直… 做一款仿映客的直播App？看我就够了一、直播现状简介Linkee.101.技术实现层面：技术相对都比较成熟，设备也都支持硬编码。IOS还提供现成的VideoToolBox框架，可以对摄像头和流媒体数据结构进行处… 快速集成iOS基于RTMP的视频推流效果图iTools有点卡,但是推到服务器倒是很快的.推流前言这篇blog是iOS视频直播初窥:&amp;lt;喵播APP&amp;gt;的一个补充.因为之前传到github上的项目中没有集成… 更多直播相关文章请关注我的简书专题iOS - 直播相关]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]教你搭建App内测下载平台]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F08%2F10%2F17.08.10_%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAApp%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[转自简书作者:zhao0 前言App开发测试过程中，我们会把安装包传到各种第三方的内测分发平台方便下载。这些平台或多或少有这样那样的限制，比如下载量啊、付费啊、不能方便找到历史版本啊。还有一方面，我们经常会打Debug版本的包方便调试，又不希望Debug包流传到外部去，这样就很有必要自己搭一个下载平台，于是就有了这个项目(github地址)。 技术调研怎么下载先说安卓，apk文件通过最简单的http/ftp下载就可以安装了，略过。iOS稍微复杂一点，需要两步才能完成。第一，下载链接必须是这样的格式 1itms-services://?action=download-manifest&amp;amp;url=一个plist文件的地址 第二，plist内容如下12345678910111213141516171819202122232425262728293031&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&amp;lt;plist version="1.0"&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;items&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;assets&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software-package&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;url&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ipa文件的地址&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;key&amp;gt;metadata&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;bundle-identifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;bundleID&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;bundle-version&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;title&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;AppTitle&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/plist&amp;gt; 其中，最重要的就是ipa文件的地址，要求必须是https协议，那就需要SSL证书，幸运的是我们可以信任自签名的证书。下载的过程就是这样，当然我们希望这个链接和plist的生成是自动完成的。 自签名证书参考如何创建一个自签名的SSL证书(X509) 包信息提取单单只能下载还不够，我们希望看到更多的信息：App名字、版本号、build号、更新时间、图标等。这些信息虽然可以留给上传者在上传的时候一并带上，但是作为有追求的程序员，把方便留给别人的最基本的，因此我们要从ipa/apk中提取这些信息。无论是ipa还是apk，本质都是zip压缩文件。对于iOS的ipa，包信息都放在Info.plist中，主要有CFBundleVersion、CFBundleIdentifier、CFBundleShortVersionString、CFBundleName等。图标文件的名字也是固定的，只要解压就可以得到。不过，苹果对png图片进行了了自定义的pngcrush压缩，有压缩自然就有还原工具pngdefry。对于Android的apk，解压后还能看到AndroidManifest.xml，但是里面的内容经过编码显示为乱码，不方便查看，需要借助开发工具aapt(Android Asset Packaging Tool)，方法如下aapt dump badging apkPath输出的文本格式如下，不是标准的歌声，需要手动转换一下。 123456package: name='com.jianshu.haruki' versionCode='16070101' versionName='1.11.2'sdkVersion:'14'targetSdkVersion:'22'...application: label='简书' icon='res/drawable-hdpi-v4/icon_jianshu_new.png'... 找轮子程序员有一个习惯，需要某个东西的时候会先一番搜索，直接用别人写好的，用着用着发现别人写的东西有这样那样的不足，然后撸起袖子自己造一个。这次也不例外，我在github上找到了一个ios-ipa-server，它的特点是简单，ipa文件存储在一个目录下，没有数据库，包信息只有上传时间(其实就是文件更新时间)，不能对app归类，只靠文件名区别，不支持上传，如下图： 浏览器访问下载页面时，后端实时解析包信息、解压icon图片，这样做效率是非常低的。这么多不足我们就有了造轮子的理由了。 自己造一个既然ios-ipa-server是基于node-express写的，正好我没写过nodejs，那就在它的基础上继续写吧，借机学(zhuang)习(bi)一下。整个项目的结构是这样的，提供四个API：包上传、获取所有App最新版本、获取某个App的所有版本、动态生成plist文件，数据存储使用sqlite3。 包上传接口设计如下： 12345678910111213141516171819path:POST /uploadparam: package:安装包文件response:&#123;id: 6,guid: "46269d71-9fda-76fc-3442-a118d6b08bf1",bundleID: "com.jianshu.Hugo",version: "2.11.4",build: "1608051045",icon: "https://10.20.30.233:1234/icon/46269d71-9fda-76fc-3442-a118d6b08bf1.png",name: "Hugo",uploadTime: "2016-12-01 20:50:05",platform: "ios",url: "itms-services://?action=download-manifest&amp;amp;url=https://10.20.30.233:1234/plist/46269d71-9fda-76fc-3442-a118d6b08bf1"&#125; 后端需要拿到安装包，提取出包信息和png图标图片，然后插入到数据库中，最后存储安装包文件和png图片，这也是最关键、最复杂的一个API。 123456789101112131415161718app.post('/upload', function(req, res) &#123;var form = new multiparty.Form();form.parse(req, function(err, fields, files) &#123;var obj = files.package[0];var tmp_path = obj.path;parseAppAndInsertToDb(tmp_path, info =&amp;gt; &#123;storeApp(tmp_path, info["guid"], error =&amp;gt; &#123;if (error) &#123;errorHandler(error,res)&#125;&#125;)console.log(info)res.send(info)&#125;, error =&amp;gt; &#123;errorHandler(error,res)&#125;);&#125;);&#125;); 接收表单信息用到了multiparty模块，parseAppAndInsertToDb内部完成了包信息的提取和存储，storeApp存储包文件。parseAppAndInsertToDb的实现如下， 12345678910111213141516171819202122232425function parseAppAndInsertToDb(filePath, callback, errorCallback) &#123;var guid = Guid.create().toString();var parse, extractif (path.extname(filePath) === ".ipa") &#123;parse = parseIpaextract = extractIpaIcon&#125; else if (path.extname(filePath) === ".apk") &#123;parse = parseApkextract = extractApkIcon&#125;Promise.all([parse(filePath),extract(filePath,guid)]).then(values =&amp;gt; &#123;var info = values[0]info["guid"] = guidexcuteDB("INSERT INTO info (guid, platform, build, bundleID, version, name) VALUES (?, ?, ?, ?, ?, ?);",[info["guid"], info["platform"], info["build"], info["bundleID"], info["version"], info["name"]],function(error)&#123;if (!error)&#123;callback(info)&#125; else &#123;errorCallback(error)&#125;&#125;);&#125;, reason =&amp;gt; &#123;errorCallback(reason)&#125;)&#125; 首先根据文件后缀名判断安装包类型，因为ipa和apk的处理逻辑不一样，所以分别对应两个方法，包信息的提取和icon提取可以同时进行，所以这里用了Promise.all。parseIpa和parseApk就是包信息的提取。extractApkIcon和extractIpaIcon则是icon的提取，extractIpaIcon多了一步还原png图片的处理。parseIpa用到了ipa-extract-info模块，parseApk则使用了apk-parser3，代码都非常简单。详细可进入github地址。 其他其他三个API则比较简单了，无非就是根据参数取数据，不再赘述。 集成和使用安装步骤非常简单，首先需要安装node，有了node之后只要一行命令 1npm install -g ipapk-server 安装完成之后输入命令 1ipapk-server 手机浏览器访问https://ip:port 即可打开下载页面 App的信息获取都设计成了API，提供给开发者更灵活的接入方式，可以做web页面，也可以做成App，我的好朋友mask(人格分裂术)贡献了不少工作，完成默认的web下载页面。更详细的内容请参考github。 写在最后简书作为一个优质原创内容社区，拥有大量优质原创内容，提供了极佳的阅读和书写体验，吸引了大量文字爱好者和程序员。简书技术团队在这里分享技术心得体会，是希望抛砖引玉，吸引更多的程序员大神来简书记录、分享、交流自己的心得体会。这个专题以后会不定期更新简书技术团队的文章，包括Android、iOS、前端、后端等等，欢迎大家关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]简单监测iOS卡顿的demo]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F06%2F21%2F17.06.21_%E7%AE%80%E5%8D%95%E7%9B%91%E6%B5%8BiOS%E5%8D%A1%E9%A1%BF%E7%9A%84demo%2F</url>
      <content type="text"><![CDATA[转自简书作者:game3108 前言本文的demo代码也会更新到github上。 做这个demo思路来源于微信team的：微信iOS卡顿监控系统。主要思路:通过监测Runloop的kCFRunLoopAfterWaiting，用一个子线程去检查，一次循环是否时间太长。其中主要涉及到了runloop的原理。关于整个原理：深入理解RunLoop讲解的比较仔细。以下就是runloop大概的运行方式：123456789101112131415161718192021222324252627282930313233343536373839404142/// 1. 通知Observers，即将进入RunLoop/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);do &#123;/// 2. 通知 Observers: 即将触发 Timer 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 4. 触发 Source0 (非基于port的) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);/// 5. GCD处理main block__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 6. 通知Observers，即将进入休眠/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);/// 7. sleep to wait msg.mach_msg() -&amp;gt; mach_msg_trap();/// 8. 通知Observers，线程被唤醒__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);/// 9. 如果是被Timer唤醒的，回调Timer__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);&#125; while (...);/// 10. 通知Observers，即将退出RunLoop/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 其中UI主要集中在__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);和__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);之前。获取kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting的状态就可以知道是否有卡顿的情况。 NSTimer的实现具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 // MonitorController.h // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface MonitorController : NSObject + (instancetype) sharedInstance; - (void) startMonitor; - (void) endMonitor; - (void) printLogTrace; @end``` ``` objectivec // MonitorController.m // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import "MonitorController.h" #include &amp;lt;libkern/OSAtomic.h&amp;gt; #include &amp;lt;execinfo.h&amp;gt; @interface MonitorController()&#123; CFRunLoopObserverRef _observer; double _lastRecordTime; NSMutableArray *_backtrace; &#125; @end @implementation MonitorController static double _waitStartTime; + (instancetype) sharedInstance&#123; static dispatch_once_t once; static id sharedInstance; dispatch_once(&amp;amp;once, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; - (void) startMonitor&#123; [self addMainThreadObserver]; [self addSecondaryThreadAndObserver]; &#125; - (void) endMonitor&#123; if (!_observer) &#123; return; &#125; CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); CFRelease(_observer); _observer = NULL; &#125; #pragma mark printLogTrace - (void)printLogTrace&#123; NSLog(@"====================堆栈\n %@ \n",_backtrace); &#125; #pragma mark addMainThreadObserver - (void) addMainThreadObserver &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //建立自动释放池 @autoreleasepool &#123; //获得当前thread的Run loop NSRunLoop *myRunLoop = [NSRunLoop currentRunLoop]; //设置Run loop observer的运行环境 CFRunLoopObserverContext context = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;; //创建Run loop observer对象 //第一个参数用于分配observer对象的内存 //第二个参数用以设置observer所要关注的事件，详见回调函数myRunLoopObserver中注释 //第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行 //第四个参数用于设置该observer的优先级 //第五个参数用于设置该observer的回调函数 //第六个参数用于设置该observer的运行环境 _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;amp;myRunLoopObserver, &amp;amp;context); if (_observer) &#123; //将Cocoa的NSRunLoop类型转换成Core Foundation的CFRunLoopRef类型 CFRunLoopRef cfRunLoop = [myRunLoop getCFRunLoop]; //将新建的observer加入到当前thread的run loop CFRunLoopAddObserver(cfRunLoop, _observer, kCFRunLoopDefaultMode); &#125; &#125; &#125;); &#125; void myRunLoopObserver(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; switch (activity) &#123; //The entrance of the run loop, before entering the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopEntry: NSLog(@"run loop entry"); break; //Inside the event processing loop before any timers are processed case kCFRunLoopBeforeTimers: NSLog(@"run loop before timers"); break; //Inside the event processing loop before any sources are processed case kCFRunLoopBeforeSources: NSLog(@"run loop before sources"); break; //Inside the event processing loop before the run loop sleeps, waiting for a source or timer to fire. //This activity does not occur if CFRunLoopRunInMode is called with a timeout of 0 seconds. //It also does not occur in a particular iteration of the event processing loop if a version 0 source fires case kCFRunLoopBeforeWaiting:&#123; _waitStartTime = 0; NSLog(@"run loop before waiting"); break; &#125; //Inside the event processing loop after the run loop wakes up, but before processing the event that woke it up. //This activity occurs only if the run loop did in fact go to sleep during the current loop case kCFRunLoopAfterWaiting:&#123; _waitStartTime = [[NSDate date] timeIntervalSince1970]; NSLog(@"run loop after waiting"); break; &#125; //The exit of the run loop, after exiting the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopExit: NSLog(@"run loop exit"); break; /* A combination of all the preceding stages case kCFRunLoopAllActivities: break; */ default: break; &#125; &#125; #pragma mark addSecondaryThreadAndObserver - (void) addSecondaryThreadAndObserver&#123; NSThread *thread = [self secondaryThread]; [self performSelector:@selector(addSecondaryTimer) onThread:thread withObject:nil waitUntilDone:YES]; &#125; - (NSThread *)secondaryThread &#123; static NSThread *_secondaryThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;amp;oncePredicate, ^&#123; _secondaryThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_secondaryThread start]; &#125;); return _secondaryThread; &#125; - (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"monitorControllerThread"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes]; [runLoop run]; &#125; &#125; - (void) addSecondaryTimer&#123; NSTimer *myTimer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; &#125; - (void)timerFired:(NSTimer *)timer&#123; if ( _waitStartTime &amp;lt; 1 )&#123; return; &#125; double currentTime = [[NSDate date] timeIntervalSince1970]; double timeDiff = currentTime - _waitStartTime; if (timeDiff &amp;gt; 2.0)&#123; if (_lastRecordTime - _waitStartTime &amp;lt; 0.001 &amp;amp;&amp;amp; _lastRecordTime != 0)&#123; NSLog(@"last time no :%f %f",timeDiff, _waitStartTime); return; &#125; [self logStack]; _lastRecordTime = _waitStartTime; &#125; &#125; - (void)logStack&#123; void* callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); int i; _backtrace = [NSMutableArray arrayWithCapacity:frames]; for ( i = 0 ; i &amp;lt; frames ; i++ )&#123; [_backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); &#125; @end 主要内容是首先在主线程注册了runloop observer的回调myRunLoopObserver每次小循环都会记录一下kCFRunLoopAfterWaiting的时间_waitStartTime，并且在kCFRunLoopBeforeWaiting制空。 另外开了一个子线程并开启他的runloop（模仿了AFNetworking的方式），并加上一个timer每隔1秒去进行监测。 如果当前时长与_waitStartTime差距大于2秒，则认为有卡顿情况，并记录了当前堆栈信息。 PS:整个demo写的比较简单，最后获取堆栈也仅获取了当前线程的堆栈信息([NSThread callStackSymbols]有同样效果)，也在寻找获取所有线程堆栈的方法，欢迎指点一下。 更新：了解到 plcrashreporter (github地址) 可以做到获取所有线程堆栈。 更新2:这篇文章也介绍了监测卡顿的方法：检测iOS的APP性能的一些方法通过Dispatch Semaphore保证同步这里记录一下。 写一个Semaphore版本的代码，也放在github上： 12345678910111213141516// SeMonitorController.h// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import &amp;lt;Foundation/Foundation.h&amp;gt;@interface SeMonitorController : NSObject+ (instancetype) sharedInstance;- (void) startMonitor;- (void) endMonitor;- (void) printLogTrace;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// SeMonitorController.m// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import "SeMonitorController.h"#import &amp;lt;libkern/OSAtomic.h&amp;gt;#import &amp;lt;execinfo.h&amp;gt;@interface SeMonitorController()&#123;CFRunLoopObserverRef _observer;dispatch_semaphore_t _semaphore;CFRunLoopActivity _activity;NSInteger _countTime;NSMutableArray *_backtrace;&#125;@end@implementation SeMonitorController+ (instancetype) sharedInstance&#123;static dispatch_once_t once;static id sharedInstance;dispatch_once(&amp;amp;once, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125;- (void) startMonitor&#123;[self registerObserver];&#125;- (void) endMonitor&#123;if (!_observer) &#123;return;&#125;CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);CFRelease(_observer);_observer = NULL;&#125;- (void) printLogTrace&#123;NSLog(@"====================堆栈\n %@ \n",_backtrace);&#125;static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;SeMonitorController *instrance = [SeMonitorController sharedInstance];instrance-&amp;gt;_activity = activity;// 发送信号dispatch_semaphore_t semaphore = instrance-&amp;gt;_semaphore;dispatch_semaphore_signal(semaphore);&#125;- (void)registerObserver&#123;CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;_observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;amp;runLoopObserverCallBack,&amp;amp;context);CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);// 创建信号_semaphore = dispatch_semaphore_create(0);// 在子线程监控时长dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;while (YES)&#123;// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)long st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));if (st != 0)&#123;if (_activity==kCFRunLoopBeforeSources || _activity==kCFRunLoopAfterWaiting)&#123;if (++_countTime &amp;lt; 5)continue;[self logStack];NSLog(@"something lag");&#125;&#125;_countTime = 0;&#125;&#125;);&#125;- (void)logStack&#123;void* callstack[128];int frames = backtrace(callstack, 128);char **strs = backtrace_symbols(callstack, frames);int i;_backtrace = [NSMutableArray arrayWithCapacity:frames];for ( i = 0 ; i &amp;lt; frames ; i++ )&#123;[_backtrace addObject:[NSString stringWithUTF8String:strs[i]]];&#125;free(strs);&#125;@end 用Dispatch Semaphore简化了代码复杂度，更加简洁。 参考资料本文csdn地址1.微信iOS卡顿监控系统2. iphone——使用run loop对象3.深入理解RunLoop4.检测iOS的APP性能的一些方法5.iOS实时卡顿监控]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AFNetworking3.0 如何取消网络请求]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F04%2F10%2F17.4.10_AFNetworking3.0%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E5%8D%95%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[前言本篇主要介绍AFNetworking3.0 如何取消网络请求，直接上代码： 1234567891011121314151617181920NSURL *URL = [NSURL URLWithString:@http];AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];NSURLSessionDataTask *task = [manager GET:URL.absoluteString parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) &#123;NSLog(@"JSON: %@", responseObject);&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123;NSLog(@"Error: %@", error);&#125;];//取消单个请求[task cancel];//取消当前所有[manager.operationQueue cancelAllOperations];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]掌握iOS多线程攻略]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F05%2F17.3.5_%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[原文：http://mobile.51cto.com/iphone-403490.htm ###多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。### 头条推荐#### iOS中多线程原理与runloop介绍iPhone中的线程应用并不是无节制的，官方给出的资料显示iPhone OS下的主线程的堆栈大小是1M，第二个线程开始都是512KB。并且该值不能通过编译器开关或线程API函数来更改。只有主线程有直接修改UI的能力。……&gt;&gt;详细#### Go语言1.1版发布“很高兴宣布 Go 语言 1.1 版的发布。在去年3月，我们发布了 1.0 版。此后我们发布了3个小版本更新，这些都只是修复了严重问题，所以各位到现在用的都是 Go 1.0.3 版。和 1.0 版相比，Go 1.1 包含了许多改进。最显著的改进是和性能相关。我们优化了编译器和链接器、垃圾回收器、goroutine 调度、映射实现和部分标准库。在 Go 1.1 之下，你的Go代码应该会明显快多了。还有Go语言本身一些细微变化，其中两点这里要摘出来说说：① return 的变化将带来更为简洁和正确的程序，② 引入了方法值（method values）。并行编程在这更为安全……&gt;&gt;详细兄弟专题：iOS人机交互指南之UI设计基础 1&nbsp;iOS多线程编程知多少在iOS的世界里有两种实现多线程的方式： 多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。 第一种：GCD 阅读全文 2&nbsp;GCD使用攻略 什么是GCDGrand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。 &nbsp; 应用举例让我们来看一个编程场景。我们要在iphone上做一个下载网页的功能，该功能非常简单，就是在iphone上放置一个按钮，点击该按钮时，显示一个转动的圆圈，表示正在进行下载，下载完成之后，将内容加载到界面上的一个文本控件中。 阅读全文 3&nbsp;GCD介绍(一):基本概念和Dispatch Queue 什么是GCD？ Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。 除了代码的平行执行能力，GCD还提供高度集成的事件控制系统。可以设置句柄来响应文件描述符、mach ports（Mach port&nbsp;用于 OS X上的进程间通讯）、进程、计时器、信号、用户生成事件。这些句柄通过GCD来并发执行。 阅读全文 4&nbsp;GCD介绍(二):多核心的性能 概念 为了在单一进程中充分发挥多核的优势，我们有必要使用多线程技术（我们没必要去提多进程，这玩意儿和GCD没关系）。在低层，GCD全局dispatch queue仅仅是工作线程池的抽象。这些队列中的Block一旦可用，就会被dispatch到工作线程中。提交至用户队列的Block最终也会通过全局队列进入相同的工作线程池（除非你的用户队列的目标是主线程，但是为了提高运行速度，我们绝不会这么干）。 有两种途径来通过GCD&ldquo;榨取&rdquo;多核心系统的性能：将单一任务或者一组相关任务并发至全局队列中运算；将多个不相关的任务或者关联不紧密的任务并发至用户队列中运算； 阅读全文 5&nbsp;GCD介绍(三):Dispatch Sources 何为Dispatch Sources 简单来说，dispatch source是一个监视某些类型事件的对象。当这些事件发生时，它自动将一个block放入一个dispatch queue的执行例程中。 说的貌似有点不清不楚。我们到底讨论哪些事件类型？ 阅读全文 6&nbsp;GCD介绍(四):完结 Dispatch Queue挂起 dispatch queue可以被挂起和恢复。使用&nbsp;dispatch_suspend函数来挂起，使用 &nbsp;dispatch_resume&nbsp;函数来恢复。这两个函数的行为是如你所愿的。另外，这两个函数也可以用于dispatch source。 一个要注意的地方是，dispatch queue的挂起是block粒度的。换句话说，挂起一个queue并不会将当前正在执行的block挂起。它会允许当前执行的block执行完毕，然后后续的block不再会被执行，直至queue被恢复。 阅读全文 7&nbsp;GCD实战一:使用串行队列实现简单的预加载 本文为大家介绍了如何使用串行队列实现简单的预加载，思路是使用gcd创建串行队列，然后在此队列中先后执行两个任务：1.预加载一个viewController 2.将这个viewController推入。文章最后提供了源码下载，希望对各位有所帮助。 其主要思路是使用gcd创建串行队列，然后在此队列中先后执行两个任务：1.预加载一个viewController 2.将这个viewController推入 代码如下： 阅读全文 8&nbsp;GCD实战二:资源竞争 概述 我将分四步来带大家研究研究程序的并发计算。第一步是基本的串行程序，然后使用GCD把它并行计算化。如果你想顺着步骤来尝试这些程序的话，可以下载源码。注意，别运行imagegcd2.m，这是个反面教材。 源码下载：http://down.51cto.com/data/872222 阅读全文 9&nbsp;iOS多线程初体验iOS多线程初体验是本文要介绍的内容，iPhone中的线程应用并不是无节制的，官方给出的资料显示iPhone OS下的主线程的堆栈大小是1M，第二个线程开始都是512KB。并且该值不能通过编译器开关或线程API函数来更改。只有主线程有直接修改UI的能力。 一、 NSOperation和NSOperationQueue 1、一个继承自&nbsp; NSOperation的操作类，该类的实现中必须有 - (void)main方法的。 2、使用NSOperation的最简单方法就是将其放入NSOperationQueue中。 阅读全文 10&nbsp;iPhone多线程编程初体验找了很长时间IPhone下多线程的编程的内容, 用到的类是UIKit的中NSThread.。 在google过程中,发现很多文都惊喜地标题着类似&lt; 多线程的OS4来了&gt;, 这些想正向引导一下, 0S4的亮点在于多任务,一个任务为一个进程,也叫多进程, 而多线程在早期的IPHONEOS上都是有的. IPHONE OS中任务的概念是一个应用, 在一个时间你只能做一件事情, 即不能同时玩游戏,同时上QQ. 而多任务的时候是可以这么做的. 流程大概如下: 阅读全文 11&nbsp;剖析iPhone多线程iPhone多线程是本文要介绍的内容，多线程在各种编程语言中都是难点，很多语言中实现起来很麻烦，objective-c虽然源于c,但其多线程编程却相当简单，可以与java相媲美。这篇文章主要从线程创建与启动、线程的同步与锁、线程的交互、线程池等等四个方面简单的讲解一下iphone中的多线程编程。 一、线程创建与启动 线程创建主要有二种方式： 1. -&nbsp;(id)init;&nbsp;//&nbsp;designated&nbsp;initializer &nbsp; 2. -&nbsp;(id)initWithTarget:(id)target&nbsp;selector:(SEL)selector&nbsp;object:(id)argument;&nbsp; 当然，还有一种比较特殊，就是使用所谓的convenient method，这个方法可以直接生成一个线程并启动它，而且无需为线程的清理负责。这个方法的接口是： 阅读全文 12&nbsp;iPhone开发多线程使用与注意事项iPhone开发多线程使用与注意事项是本文要介绍的内容，主要介绍一下iPhone SDK中多线程的使用方法以及注意事项。虽然现在大部分PC应用程序都支持多线程/多任务的开发方式，但是在iPhone上，Apple并不推荐使用多线程的编程方式。 但是多线程编程毕竟是发展的趋势，而且据说即将推出的iPhone OS4将全面支持多线程的处理方式。所以说掌握多线程的编程方式，在某些场合一定能挖掘出iPhone的更大潜力。 从例子入手 先从一个例程入手，具体的代码参考了这里。还有例程可以下载。 阅读全文 13&nbsp;iPhone SDK 多线程使用方法以及注意事项iPhone SDK 多线程使用方法以及注意事项是本文要介绍的内容，不多说，直接进入话题。虽然现在大部分PC应用程序都支持多线程/多任务的开发方式，但是在iPhone上，Apple并不推荐使用多线程的编程方式。但是多线程编程毕竟是发展的趋势，而且据说即将推出的iPhone OS4将全 &nbsp; 虽然现在大部分PC应用程序都支持多线程/多任务的开发方式，但是在iPhone上，Apple并不推荐使用多线程的编程方式。但是多线程编程毕竟是发展的趋势，而且据说即将推出的iPhone OS4将全面支持多线程的处理方式。所以说掌握多线程的编程方式，在某些场合一定能挖掘出iPhone的更大潜力 从例子入手 先从一个例程入手，具体的代码参考了这里。还有例程可以下载。多线程程序的控制模型可以参考这里，一般情况下都是使用 管理者/工人模型, 这里，我们使用iPhone SDK中的 NSThread 来实现它。 首先创建一个新的 View-based application 工程，名字为 &quot;TutorialProject&quot; 。界面如下图所示，使用UILabel实现两部分的Part(Thread Part和Test Part)，Thread Part中包含一个UIProgressView和一个UIButton；而Test Part包含一个值和一个UISlider。如图： 阅读全文 14&nbsp;SQLite在多线程环境下的应用先说下初衷吧，实际上我经常看到有人抱怨SQLite不支持多线程。而在iOS开发时，为了不阻塞主线程，数据库访问必须移到子线程中。为了解决这个矛盾，很有必要对此一探究竟。 关于这个问题，最权威的解答当然是SQLite官网上的&ldquo;Is SQLite threadsafe?&rdquo;这个问答。 简单来说，从3.3.1版本开始，它就是线程安全的了。而iOS的SQLite版本没有低于这个版本的： 3.4.0 - iPhone OS 2.2.1 阅读全文 15&nbsp;关于iPhone多线程编程的教程iPhone多线程编程的教程是本文要介绍的内容，相信大家也都接触过多线程的使用，那么本文也可以作为一个参考来进行学习。不多说，我们来看内容中详细讲解多线程编程。 iphone中多线程编程：线程的创建 多线程在各种编程语言中都是难点，很多语言中实现起来很麻烦，objective-c虽然源于c,但其多线程编程却相当简单，可以与java相媲美。 一、线程创建与启动 阅读全文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]禅与 Objective-C 编程艺术]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F02%2F16%2F17.2.16_%E7%A6%85%E4%B8%8E%20Objective-C%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[原文：https://github.com/oa414/objc-zen-book-cn 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译） 原文 https://github.com/objc-zen/objc-zen-book Gitbook 链接(包含 PDF, mobi, epub 格式): http://yourtion.gitbooks.io/objc-zen-book-cn/ (感谢 yourtion 整理 ) 前言 Swift 贡献给社区 作者 关于中文翻译 条件语句 尤达表达式 nil 和 BOOL 检查 黄金大道 复杂的表达式 三元运算符 错误处理 Case语句 枚举类型 命名 通用的约定 常量 方法 字面值 类 类名 Initializer 和 dealloc Designated 和 Secondary 初始化方法 Designated Initializer Secondary Initializer 参考 instancetype 参考 初始化模式 类簇 （class cluster) 单例 属性 Init 和 Dealloc 点符号 属性定义 私有属性 可变对象 懒加载 (Lazy Loading) 方法 参数断言 私有方法 相等性 Categories Protocols NSNotification 美化代码 空格 换行 括号 代码组织 利用代码块 Pragma Pragma Mark 忽略没用使用变量的编译警告 明确编译器警告和错误 字符串文档 注释 头文档 对象间的通讯 Block 深入 Block self 的循环引用 委托和数据源 继承 多重委托 面向切面编程 参考资料 其他的 Objective-C 风格指南 前言我们在 2013 年 11 月份开始写这本书，最初的目标是提供一份如何编写干净漂亮的 Objective-C 代码的指南：现在虽然有很多指南，但是它们都是有一些问题的。我们不想介绍一些死板的规定，我们想提供一个在开发者们之间写更一致的代码的途径。随时间的推移，这本书开始转向介绍如何设计和构建优秀的代码。 这本书的观点是代码不仅是可以编译的，同时应该是 “有效” 的。好的代码有一些特性：简明，自我解释，优秀的组织，良好的文档，良好的命名，优秀的设计以及可以被久经考验。 本书的一个理念是是代码的清晰性优先于性能，同时阐述为什么应该这么做。 虽然所有的代码都是 Objective-C 写的，但是一些主题是通用的，并且独立于编程语言。 Swift在 2014 年 6 月 6 日，苹果发布了面向 iOS 和 Mac 开发的新语言： Swift。这个新语言与 Objective-C 截然不同。所以，我们改变了写这本书的计划。我们决定发布这本书当前的状态，而不是继续书写我们原来计划写下去的主题。 Objective-C 没有消失，但是现在用一个慢慢失去关注的语言来继续写这本书并不是一个明智的选择。 贡献给社区我们将这本书免费发布并且贡献给社区，因为我们希望提供给读者一些有价值的内容。如果你能学到至少一条最佳实践，我们的目的就达到了。 我们已经非常用心地打磨了这些文字，但是仍然可能有一些拼写或者其他错误。我们非常希望读者给我们一个反馈或者建议，以来改善本书。所以如果有什么问题的话，请联系我们。我们非常欢迎各种 pull-request。 作者Luca Bernardi http://lucabernardi.com @luka_bernardi https://github.com/lukabernardi Alberto De Bortoli http://albertodebortoli.com @albertodebo http://github.com/albertodebortoli 关于中文翻译译者 林翔宇 http://www.linxiangyu.org/ linxiangyu@nupter.org https://github.com/oa414 庞博 bopang@sohu-inc.com https://github.com/heistings Kevin.Xiao kevinxiao1919@gmail.com https://github.com/KevinHM 翻译已得到原作者许可，并且会在更加完善后申请合并到原文仓库。 部分译文表达可能存在不妥之处，非常欢迎各种修订建议和校对。 请直接 fork 本仓库，在 README.md 文件中修改，并申请 pull request 到 https://github.com/oa414/objc-zen-book-cn/。 条件语句条件语句体应该总是被大括号包围。尽管有时候你可以不使用大括号（比如，条件语句体只有一行内容），但是这样做会带来问题隐患。比如，增加一行代码时，你可能会误以为它是 if 语句体里面的。此外，更危险的是，如果把 if 后面的那行代码注释掉，之后的一行代码会成为 if 语句里的代码。 推荐: 123if (!error) &#123; return success;&#125; 不推荐: 12if (!error) return success; 和 1if (!error) return success; 在 2014年2月 苹果的 SSL/TLS 实现里面发现了知名的 goto fail 错误。 代码在这里： 123456789101112131415161718192021static OSStatusSSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams, uint8_t *signature, UInt16 signatureLen)&#123; OSStatus err; ... if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0) goto fail; if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0) goto fail; goto fail; if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0) goto fail; ...fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); return err;&#125; 显而易见，这里有没有括号包围的2行连续的 goto fail; 。我们当然不希望写出上面的代码导致错误。 此外，在其他条件语句里面也应该按照这种风格统一，这样更便于检查。 尤达表达式不要使用尤达表达式。尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是 “天空是不是蓝的” 或者 “这个男人是不是高个子的” （译者注：名字起源于星球大战中尤达大师的讲话方式，总是用倒装的语序） 推荐:1if ([myValue isEqual:@42]) &#123; ... 不推荐:1if ([@42 isEqual:myValue]) &#123; ... nil 和 BOOL 检查类似于 Yoda 表达式，nil 检查的方式也是存在争议的。一些 notous 库像这样检查对象是否为 nil： 1if (nil == myValue) &#123; ... 或许有人会提出这是错的，因为在 nil 作为一个常量的情况下，这样做就像 Yoda 表达式了。 但是一些程序员这么做的原因是为了避免调试的困难，看下面的代码： 1if (myValue == nil) &#123; ... 如果程序员敲错成这样： 1if (myValue = nil) &#123; ... 这是合法的语句，但是即使你是一个丰富经验的程序员，即使盯着眼睛瞧上好多遍也很难调试出错误。但是如果把 nil 放在左边，因为它不能被赋值，所以就不会发生这样的错误。 如果程序员这样做，他/她就可以轻松检查出可能的原因，比一遍遍检查敲下的代码要好很多。 为了避免这些奇怪的问题，可以用感叹号来作为运算符。因为 nil 是 解释到 NO，所以没必要在条件语句里面把它和其他值比较。同时，不要直接把它和 YES 比较，因为 YES 的定义是 1， 而 BOOL 是 8 bit的，实际上是 char 类型。 推荐:123if (someObject) &#123; ...if (![someObject boolValue]) &#123; ...if (!someObject) &#123; ... 不推荐:123if (someObject == YES) &#123; ... // Wrongif (myRawValue == YES) &#123; ... // Never do this.if ([someObject boolValue] == NO) &#123; ... 同时这样也能提高一致性，以及提升可读性。 黄金大道在使用条件语句编程时，代码的左边距应该是一条“黄金”或者“快乐”的大道。 也就是说，不要嵌套 if 语句。使用多个 return 可以避免增加循环的复杂度，并提高代码的可读性。因为方法的重要部分没有嵌套在分支里面，并且你可以很清楚地找到相关的代码。 推荐: 1234567- (void)someMethod &#123; if (![someOther boolValue]) &#123; return; &#125; //Do something important&#125; 不推荐: 12345- (void)someMethod &#123; if ([someOther boolValue]) &#123; //Do something important &#125;&#125; 复杂的表达式当你有一个复杂的 if 子句的时候，你应该把它们提取出来赋给一个 BOOL 变量，这样可以让逻辑更清楚，而且让每个子句的意义体现出来。 1234567BOOL nameContainsSwift = [sessionName containsString:@&quot;Swift&quot;];BOOL isCurrentYear = [sessionDateCompontents year] == 2014;BOOL isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear;if (isSwiftSession) &#123; // Do something very cool&#125; 三元运算符三元运算符 ? 应该只用在它能让代码更加清楚的地方。 一个条件语句的所有的变量应该是已经被求值了的。类似 if 语句，计算多个条件子句通常会让语句更加难以理解。或者可以把它们重构到实例变量里面。 推荐:1result = a &gt; b ? x : y; 不推荐:1result = a &gt; b ? x = c &gt; d ? c : d : y; 当三元运算符的第二个参数（if 分支）返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧： 推荐:1result = object ? : [self createObject]; 不推荐:1result = object ? object : [self createObject]; 错误处理有些方法通过参数返回 error 的引用，使用这样的方法时应当检查方法的返回值，而非 error 的引用。 推荐:1234NSError *error = nil;if (![self trySomethingWithError:&amp;error]) &#123; // Handle Error&#125; 此外，一些苹果的 API 在成功的情况下会对 error 参数（如果它非 NULL）写入垃圾值（garbage values），所以如果检查 error 的值可能导致错误 （甚至崩溃）。 Case语句除非编译器强制要求，括号在 case 语句里面是不必要的。但是当一个 case 包含了多行语句的时候，需要加上括号。 12345678910111213141516switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break;&#125; 有时候可以使用 fall-through 在不同的 case 里面执行同一段代码。一个 fall-through 是指移除 case 语句的 “break” 然后让下面的 case 继续执行。 123456789switch (condition) &#123; case 1: case 2: // code executed for values 1 and 2 break; default: // ... break;&#125; 当在 switch 语句里面使用一个可枚举的变量的时候，default 是不必要的。比如： 1234567891011switch (menuType) &#123; case ZOCEnumNone: // ... break; case ZOCEnumValue1: // ... break; case ZOCEnumValue2: // ... break;&#125; 此外，为了避免使用默认的 case，如果新的值加入到 enum，程序员会马上收到一个 warning 通知 Enumeration value &#39;ZOCEnumValue3&#39; not handled in switch.（枚举类型 &#39;ZOCEnumValue3&#39; 没有被 switch 处理） 枚举类型当使用 enum 的时候，建议使用新的固定的基础类型定义，因为它有更强大的类型检查和代码补全。 SDK 现在有一个 宏来鼓励和促进使用固定类型定义 - NS_ENUM() 例子: 123456typedef NS_ENUM(NSUInteger, ZOCMachineState) &#123; ZOCMachineStateNone, ZOCMachineStateIdle, ZOCMachineStateRunning, ZOCMachineStatePaused&#125;; 命名通用的约定尽可能遵守 Apple 的命名约定，尤其是和 内存管理规则 (NARC) 相关的地方。 推荐使用长的、描述性的方法和变量名。 推荐:1UIButton *settingsButton; 不推荐:1UIButton *setBut; 常量常量应该以驼峰法命名，并以相关类名作为前缀。 推荐:1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐:1static const NSTimeInterval fadeOutTime = 0.4; 推荐使用常量来代替字符串字面值和数字，这样能够方便复用，而且可以快速修改而不需要查找和替换。常量应该用 static 声明为静态常量，而不要用 #define，除非它明确的作为一个宏来使用。 推荐: 12static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐: 12#define CompanyName @&quot;Apple Inc.&quot;#define magicNumber 42 常量应该在头文件中以这样的形式暴露给外部： 1extern NSString *const ZOCCacheControllerDidClearCacheNotification; 并在实现文件中为它赋值。 只有公有的常量才需要添加命名空间作为前缀。尽管实现文件中私有常量的命名可以遵循另外一种模式，你仍旧可以遵循这个规则。 方法方法名与方法类型 (-/+ 符号)之间应该以空格间隔。方法段之间也应该以空格间隔（以符合 Apple 风格）。参数前应该总是有一个描述性的关键词。 尽可能少用 “and” 这个词。它不应该用来阐明有多个参数，比如下面的 initWithWidth:height: 这个例子： 推荐:1234- (void)setExampleText:(NSString *)text image:(UIImage *)image;- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;- (id)viewWithTag:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐: 12345- (void)setT:(NSString *)text i:(UIImage *)image;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;- (id)taggedView:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; // Never do this. 字面值使用字面值来创建不可变的 NSString, NSDictionary, NSArray, 和 NSNumber 对象。注意不要将 nil 传进 NSArray 和 NSDictionary 里，因为这样会导致崩溃。 例子： 1234NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 不要这样: 1234NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 如果要用到这些类的可变副本，我们推荐使用 NSMutableArray, NSMutableString 这样的类。 应该避免下面这样: 1NSMutableArray *aMutableArray = [@[] mutableCopy]; 上面这种书写方式的效率和可读性的都存在问题。 效率方面，一个不必要的不可变对象被创建后立马被废弃了；虽然这并不会让你的 App 变慢（除非这个方法被频繁调用），但是确实没必要为了少打几个字而这样做。 可读性方面，存在两个问题：第一个问题是当你浏览代码并看见 @[] 的时候，你首先联想到的是 NSArray 实例，但是在这种情形下你需要停下来深思熟虑的检查；另一个问题是，一些新手以他的水平看到你的代码后可能会对这是一个可变对象还是一个不可变对象产生分歧。他/她可能不熟悉可变拷贝构造的含义（这并不是说这个知识不重要）。当然，不存在绝对的错误，我们只是讨论代码的可用性（包括可读性)。 类类名类名应该以三个大写字母作为前缀（双字母前缀为 Apple 的类预留）。尽管这个规范看起来有些古怪，但是这样做可以减少 Objective-C 没有命名空间所带来的问题。 一些开发者在定义模型对象时并不遵循这个规范（对于 Core Data 对象，我们更应该遵循这个规范）。我们建议在定义 Core Data 对象时严格遵循这个约定，因为最终你可能需要把你的 Managed Object Model（托管对象模型）与其他（第三方库）的 MOMs（Managed Object Model）合并。 你可能注意到了，这本书里类的前缀（不仅仅是类，也包括公开的常量、Protocol 等的前缀）是ZOC。 另一个好的类的命名规范：当你创建一个子类的时候，你应该把说明性的部分放在前缀和父类名的在中间。 举个例子：如果你有一个 ZOCNetworkClient 类，子类的名字会是ZOCTwitterNetworkClient (注意 “Twitter” 在 “ZOC” 和 “NetworkClient” 之间); 按照这个约定， 一个UIViewController 的子类会是 ZOCTimelineViewController. Initializer 和 dealloc推荐的代码组织方式是将 dealloc 方法放在实现文件的最前面（直接在 @synthesize 以及 @dynamic 之后），init 应该跟在 dealloc 方法后面。 如果有多个初始化方法， 指定初始化方法 (designated initializer) 应该放在最前面，间接初始化方法 (secondary initializer) 跟在后面，这样更有逻辑性。如今有了 ARC，dealloc 方法几乎不需要实现，不过把 init 和 dealloc 放在一起可以从视觉上强调它们是一对的。通常，在 init 方法中做的事情需要在 dealloc 方法中撤销。 init 方法应该是这样的结构： 12345678- (instancetype)init&#123; self = [super init]; // call the designated initializer if (self) &#123; // Custom initialization &#125; return self;&#125; 为什么设置 self 为 [super init] 的返回值，以及中间发生了什么呢？这是一个十分有趣的话题。 我们退一步讲：我们常常写 [[NSObject alloc] init] 这样的代码，从而淡化了 alloc 和 init 的区别。Objective-C 的这个特性叫做 两步创建 。 这意味着申请分配内存和初始化被分离成两步，alloc 和 init。 alloc 负责创建对象，这个过程包括分配足够的内存来保存对象，写入 isa 指针，初始化引用计数，以及重置所有实例变量。 init 负责初始化对象，这意味着使对象处于可用状态。这通常意味着为对象的实例变量赋予合理有用的值。 alloc 方法将返回一个有效的未初始化的对象实例。每一个对这个实例发送的消息会被转换成一次 objc_msgSend() 函数的调用，形参 self 的实参是 alloc 返回的指针；这样 self 在所有方法的作用域内都能够被访问。 按照惯例，为了完成两步创建，新创建的实例第一个被调用的方法将是 init 方法。注意，NSObject 在实现 init 时，只是简单的返回了 self。 关于 init 的约定还有一个重要部分：这个方法可以（并且应该）通过返回 nil 来告诉调用者，初始化失败了；初始化可能会因为各种原因失败，比如一个输入的格式错误了，或者另一个需要的对象初始化失败了。这样我们就能理解为什么总是需要调用 self = [super init]。如果你的父类说初始化自己的时候失败了，那么你必须假定你正处于一个不稳定的状态，因此在你的实现里不要继续你自己的初始化并且也返回 nil。如果不这样做，你可能会操作一个不可用的对象，它的行为是不可预测的，最终可能会导致你的程序崩溃。 init 方法在被调用的时候可以通过重新给 self 重新赋值来返回另一个实例，而非调用的那个实例。例如类簇，还有一些 Cocoa 类为相等的（不可变的）对象返回同一个实例。 Designated 和 Secondary 初始化方法Objective-C 有指定初始化方法(designated initializer)和间接(secondary initializer)初始化方法的观念。designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化的初始化方法。 123456789101112131415161718192021222324252627@implementation ZOCEvent- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date location:(CLLocation *)location&#123; self = [super init]; if (self) &#123; _title = title; _date = date; _location = location; &#125; return self;&#125;- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date&#123; return [self initWithTitle:title date:date location:nil];&#125;- (instancetype)initWithTitle:(NSString *)title&#123; return [self initWithTitle:title date:[NSDate date] location:nil];&#125;@end initWithTitle:date:location: 就是 designated 初始化方法，另外的两个是 secondary 初始化方法。因为它们仅仅是调用类实现的 designated 初始化方法 Designated Initializer一个类应该有且只有一个 designated 初始化方法，其他的初始化方法应该调用这个 designated 的初始化方法（虽然这个情况有一个例外） 这个分歧没有要求那个初始化函数需要被调用。 在类继承中调用任何 designated 初始化方法都是合法的，而且应该保证 所有的 designated initializer 在类继承中是从祖先（通常是 NSObject）到你的类向下调用的。 实际上这意味着第一个执行的初始化代码是最远的祖先，然后从顶向下的类继承，所有类都有机会执行他们特定初始化代码。这样，你在做特定初始化工作前，所有从超类继承的东西都是不可用的状态。 虽然这没有明确的规定，但是所有 Apple 的框架都保证遵守这个约定，你的类也应该这样做。 当定义一个新类的时候有三个不同的方式： 不需要重载任何初始化函数 重载 designated initializer 定义一个新的 designated initializer 第一个方案是最简单的：你不需要增加类的任何初始化逻辑，只需要依照父类的designated initializer。 当你希望提供额外的初始化逻辑的时候，你可以重载 designated initializer。你只需要重载直接超类的 designated initializer 并且确认你的实现调用了超类的方法。 一个典型的例子是你创造UIViewController子类的时候重载initWithNibName:bundle:方法。 12345678910111213@implementation ZOCViewController- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; // call to the superclass designated initializer self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; // Custom initialization （自定义的初始化过程） &#125; return self;&#125;@end 在 UIViewController 子类的例子里面如果重载 init 会是一个错误，这个情况下调用者会尝试调用 initWithNib:bundle 初始化你的类，你的类实现不会被调用。这同样违背了它应该是合法调用任何 designated initializer 的规则。 在你希望提供你自己的初始化函数的时候，你应该遵守这三个步骤来保证获得正确的行为： 定义你的 designated initializer，确保调用了直接超类的 designated initializer。 重载直接超类的 designated initializer。调用你的新的 designated initializer。 为新的 designated initializer 写文档。 很多开发者忽略了后两步，这不仅仅是一个粗心的问题，而且这样违反了框架的规则，可能导致不确定的行为和bug。让我们看看正确的实现的例子： 1234567891011121314151617181920@implementation ZOCNewsViewController- (id)initWithNews:(ZOCNews *)news&#123; // call to the immediate superclass&apos;s designated initializer （调用直接超类的 designated initializer） self = [super initWithNibName:nil bundle:nil]; if (self) &#123; _news = news; &#125; return self;&#125;// Override the immediate superclass&apos;s designated initializer （重载直接父类的 designated initializer）- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; // call the new designated initializer return [self initWithNews:nil];&#125;@end 如果你没重载 initWithNibName:bundle: ，而且调用者决定用这个方法初始化你的类(这是完全合法的)。 initWithNews: 永远不会被调用，所以导致了不正确的初始化流程，你的类的特定初始化逻辑没有被执行。 即使可以推断那个方法是 designated initializer，也最好清晰地明确它（未来的你或者其他开发者在改代码的时候会感谢你的）。 你应该考虑来用这两个策略（不是互斥的）：第一个是你在文档中明确哪一个初始化方法是 designated 的，你可以用编译器的指令 __attribute__((objc_designated_initializer)) 来标记你的意图。 用这个编译指令的时候，编译器会来帮你。如果你的新的 designated initializer 没有调用超类的 designated initializer，那么编译器会发出警告。 然而，当没有调用类的 designated initializer 的时候（并且依次提供必要的参数），并且调用其他父类中的 designated initialize 的时候，会变成一个不可用的状态。参考之前的例子，当实例化一个 ZOCNewsViewController 展示一个新闻而那条新闻没有展示的话，就会毫无意义。这个情况下你应该只需要让其他的 designated initializer 失效，来强制调用一个非常特别的 designated initializer。通过使用另外一个编译器指令 __attribute__((unavailable(&quot;Invoke the designated initializer&quot;))) 来修饰一个方法，通过这个属性，会让你在试图调用这个方法的时候产生一个编译错误。 这是之前的例子相关的实现的头文件(这里使用宏来让代码没有那么啰嗦) 12345678@interface ZOCNewsViewController : UIViewController- (instancetype)initWithNews:(ZOCNews *)news ZOC_DESIGNATED_INITIALIZER;- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil ZOC_UNAVAILABLE_INSTEAD(initWithNews:);- (instancetype)init ZOC_UNAVAILABLE_INSTEAD(initWithNews:);@end 上述的一个推论是：你应该永远不从 designated initializer 里面调用一个 secondary initializer （如果secondary initializer 遵守约定，它会调用 designated initializer）。如果这样，调用很可能会调用一个子类重写的 init 方法并且陷入无限递归之中。 不过一个例外是一个对象是否遵守 NSCoding 协议，并且它通过方法 initWithCoder: 初始化。我们应该看超类是否符合 NSCoding 协议来区别对待。符合的时候，如果你只是调用 [super initWithCoder:] ，你可能需要在 designated initializer 里面写一些通用的初始化代码，处理这种情况的一个好方法是把这些代码放在私有方法里面(比如 p_commonInit )。当你的超类不符合 NSCoding 协议的时候，推荐把 initWithCoder: 作为 secondary initializer 来对待，并且调用 self 的 designated initializer。 注意这违反了 Apple 写在 Archives and Serializations Programming Guide 上面的规定： the object should first invoke its superclass’s designated initializer to initialize inherited state（对象总是应该首先调用超类的 designated initializer 来初始化继承的状态） 如果你的类不是 NSObject 的直接子类，这样做的话，会导致不可预测的行为。 Secondary Initializer正如之前的描述，secondary initializer 是一种提供默认值、行为到 designated initializer的方法。也就是说，在这样的方法里面你不应该有初始化实例变量的操作，并且你应该一直假设这个方法不会得到调用。我们保证的是唯一被调用的方法是 designated initializer。这意味着你的 secondary initializer 总是应该调用 Designated initializer 或者你自定义(上面的第三种情况：自定义Designated initializer)的 self的 designated initializer。有时候，因为错误，可能打成了 super，这样会导致不符合上面提及的初始化顺序（在这个特别的例子里面，是跳过当前类的初始化） 参考 https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Initialization/Initialization.html https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/MultipleInitializers.html https://blog.twitter.com/2014/how-to-objective-c-initializer-patterns instancetype我们经常忽略 Cocoa 充满了约定，并且这些约定可以帮助编译器变得更加聪明。无论编译器是否遭遇 alloc 或者 init 方法，他会知道，即使返回类型都是 id ，这些方法总是返回接受到的类类型的实例。因此，它允许编译器进行类型检查。（比如，检查方法返回的类型是否合法）。Clang的这个好处来自于 related result type， 意味着： messages sent to one of alloc and init methods will have the same static type as the instance of the receiver class （发送到 alloc 或者 init 方法的消息会有同样的静态类型检查是否为接受类的实例。） 更多的关于这个自动定义相关返回类型的约定请查看 Clang Language Extensions guide 的appropriate section) 一个相关的返回类型可以明确地规定用 instancetype 关键字作为返回类型，并且它可以在一些工厂方法或者构造器方法的场景下很有用。它可以提示编译器正确地检查类型，并且更加重要的是，这同时适用于它的子类。 123@interface ZOCPerson+ (instancetype)personWithName:(NSString *)name;@end 虽然如此，根据 clang 的定义，id 可以被编译器提升到 instancetype 。在 alloc 或者 init 中，我们强烈建议对所有返回类的实例的类方法和实例方法使用 instancetype 类型。 在你的 API 中要构成习惯以及保持始终如一的，此外，通过对你代码的小调整你可以提高可读性：在简单的浏览的时候你可以区分哪些方法是返回你类的实例的。你以后会感谢这些注意过的小细节的。 参考 http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/ http://tewha.net/2013/01/when-is-id-promoted-to-instancetype/ http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types http://nshipster.com/instancetype/ 初始化模式类簇 （class cluster)类簇在Apple的文档中这样描述： an architecture that groups a number of private, concrete subclasses under a public, abstract superclass. （一个在共有的抽象超类下设置一组私有子类的架构） 如果这个描述听起来很熟悉，说明你的直觉是对的。 Class cluster 是 Apple 对抽象工厂设计模式的称呼。 class cluster 的想法很简单: 使用信息进行(类的)初始化处理期间，会使用一个抽象类（通常作为初始化方法的参数或者判定环境的可用性参数）来完成特定的逻辑或者实例化一个具体的子类。而这个”Public Facing（面向公众的）”类，必须非常清楚他的私有子类，以便在面对具体任务的时候有能力返回一个恰当的私有子类实例。对调用者来说只需知道对象的各种API的作用即可。这个模式隐藏了他背后复杂的初始化逻辑，调用者也不需要关心背后的实现。 Class clusters 在 Apple 的Framework 中广泛使用：一些明显的例子比如 NSNumber 可以返回不同类型给你的子类，取决于 数字类型如何提供 (Integer, Float, etc…) 或者 NSArray 返回不同的最优存储策略的子类。 这个模式的精妙的地方在于，调用者可以完全不管子类，事实上，这可以用在设计一个库，可以用来交换实际的返回的类，而不用去管相关的细节，因为它们都遵从抽象超类的方法。 我们的经验是使用类簇可以帮助移除很多条件语句。 一个经典的例子是如果你有为 iPad 和 iPhone 写的一样的 UIViewController 子类，但是在不同的设备上有不同的行为。 比较基础的实现是用条件语句检查设备，然后执行不同的逻辑。虽然刚开始可能不错，但是随着代码的增长，运行逻辑也会趋于复杂。一个更好的实现的设计是创建一个抽象而且宽泛的 view controller 来包含所有的共享逻辑，并且对于不同设备有两个特别的子例。 通用的 view controller 会检查当前设备并且返回适当的子类。 12345678910111213141516171819@implementation ZOCKintsugiPhotoViewController- (id)initWithPhotos:(NSArray *)photos&#123; if ([self isMemberOfClass:ZOCKintsugiPhotoViewController.class]) &#123; self = nil; if ([UIDevice isPad]) &#123; self = [[ZOCKintsugiPhotoViewController_iPad alloc] initWithPhotos:photos]; &#125; else &#123; self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos]; &#125; return self; &#125; return [super initWithNibName:nil bundle:nil];&#125;@end 这个子例程展示了如何创建一个类簇。 使用[self isMemberOfClass:ZOCKintsugiPhotoViewController.class]防止子类中重载初始化方法，避免无限递归。当[[ZOCKintsugiPhotoViewController alloc] initWithPhotos:photos]被调用时，上面条件表达式的结果将会是True。 self = nil的目的是移除ZOCKintsugiPhotoViewController实例上的所有引用，实例(抽象类的实例)本身将会解除分配（ 当然ARC也好MRC也好dealloc都会发生在Main Runloop这一次的结束时）。 接下来的逻辑就是判断哪一个私有子类将被初始化。我们假设在iPhone上运行这段代码并且ZOCKintsugiPhotoViewController_iPhone没有重载initWithPhotos:方法。这种情况下，当执行self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];,ZOCKintsugiPhotoViewController将会被调用，第一次检查将会在这里发生，鉴于ZOCKintsugiPhotoViewController_iPhone不完全是ZOCKintsugiPhotoViewController，表达式[self isMemberOfClass:ZOCKintsugiPhotoViewController.class]将会是False,于是就会调用[super initWithNibName:nil bundle:nil]，于是就会进入ZOCKintsugiPhotoViewController的初始化过程，这时候因为调用者就是ZOCKintsugiPhotoViewController本身，这一次的检查必定为True,接下来就会进行正确的初始化过程。(NOTE：这里必须是完全遵循Designated initializer 以及Secondary initializer的设计规范的前提下才会其效果的!不明白这个规范的可以后退一步熟悉这种规范在回头来看这个说明) NOTE: 这里的意思是，代码是在iPhone上调试的，程序员使用了self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];来初始化某个view controller的对象，当代码运行在iPad上时，这个初始化过程也是正确的，因为无论程序员的代码中使用self = [[ZOCKintsugiPhotoViewController_iPhone alloc] initWithPhotos:photos];来初始化viewController(iPhone上编写运行在iPad上)，还是使用self = [[ZOCKintsugiPhotoViewController_iPad alloc] initWithPhotos:photos];来初始化viewController(iPad上编写，运行在iPhone上)，都会因为ZOCKintsugiPhotoViewController的initWithPhotos:方法的存在而变得通用起来。 单例如果可能，请尽量避免使用单例而是依赖注入。然而，如果一定要用，请使用一个线程安全的模式来创建共享的实例。对于 GCD，用 dispatch_once() 函数就可以咯。 123456789+ (instancetype)sharedInstance&#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 使用 dispatch_once()，来控制代码同步，取代了原来的约定俗成的用法。 12345678910+ (instancetype)sharedInstance&#123; static id sharedInstance; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[MyClass alloc] init]; &#125; &#125; return sharedInstance;&#125; dispatch_once() 的优点是，它更快，而且语法上更干净，因为dispatch_once()的意思就是 “把一些东西执行一次”，就像我们做的一样。 这样同时可以避免 possible and sometimes prolific crashes. 经典的单例对象是：一个设备的GPS以及它的加速度传感器(也称动作感应器)。虽然单例对象可以子类化，但这种方式能够有用的情况非常少见。必须有证据表明，给定类的接口趋向于作为单例来使用。所以，单例通常公开一个sharedInstance的类方法就已经足够了，没有任何的可写属性需要被暴露出来。 尝试着把单例作为一个对象的容器，在代码或者应用层面上共享，是一个糟糕和丑陋的设计。 NOTE：单例模式应该运用于类及类的接口趋向于作为单例来使用的情况 （译者注） 属性属性应该尽可能描述性地命名，避免缩写，并且是小写字母开头的驼峰命名。我们的工具可以很方便地帮我们自动补全所有东西（嗯。。几乎所有的，Xcode 的Derived Data 会索引这些命名）。所以没理由少打几个字符了，并且最好尽可能在你源码里表达更多东西。 例子 :1NSString *text; 不要这样 :12NSString* text;NSString * text; （注意：这个习惯和常量不同，这是主要从常用和可读性考虑。 C++ 的开发者偏好从变量名中分离类型，作为类型它应该是NSString* （对于从堆中分配的对象，对于C++是能从栈上分配的）格式。） 使用属性的自动同步 (synthesize) 而不是手动的 @synthesize 语句，除非你的属性是 protocol 的一部分而不是一个完整的类。如果 Xcode 可以自动同步这些变量，就让它来做吧。否则只会让你抛开 Xcode 的优点，维护更冗长的代码。 你应该总是使用 setter 和 getter 方法访问属性，除了 init 和 dealloc 方法。通常，使用属性让你增加了在当前作用域之外的代码块的可能所以可能带来更多副作用。 你总应该用 getter 和 setter ，因为： 使用 setter 会遵守定义的内存管理语义(strong, weak, copy etc…) ，这个在 ARC 之前就是相关的内容。举个例子，copy 属性定义了每个时候你用 setter 并且传送数据的时候，它会复制数据而不用额外的操作。 KVO 通知(willChangeValueForKey, didChangeValueForKey) 会被自动执行。 更容易debug：你可以设置一个断点在属性声明上并且断点会在每次 getter / setter 方法调用的时候执行，或者你可以在自己的自定义 setter/getter 设置断点。 允许在一个单独的地方为设置值添加额外的逻辑。 你应该倾向于用 getter： 它是对未来的变化有扩展能力的（比如，属性是自动生成的）。 它允许子类化。 更简单的debug（比如，允许拿出一个断点在 getter 方法里面，并且看谁访问了特别的 getter 它让意图更加清晰和明确：通过访问 ivar _anIvar 你可以明确的访问 self-&gt;_anIvar.这可能导致问题。在 block 里面访问 ivar （你捕捉并且 retain 了 self，即使你没有明确的看到 self 关键词）。 它自动产生KVO 通知。 在消息发送的时候增加的开销是微不足道的。更多关于性能问题的介绍你可以看 Should I Use a Property or an Instance Variable?。 Init 和 Dealloc有一个例外：永远不要在 init 方法（以及其他初始化方法）里面用 getter 和 setter 方法，你应当直接访问实例变量。这样做是为了防止有子类时，出现这样的情况：它的子类最终重载了其 setter 或者 getter 方法，因此导致该子类去调用其他的方法、访问那些处于不稳定状态，或者称为没有初始化完成的属性或者 ivar 。记住一个对象仅仅在 init 返回的时候，才会被认为是达到了初始化完成的状态。 同样在 dealloc 方法中（在 dealloc 方法中，一个对象可以在一个 不确定的状态中）这是同样需要被注意的。 Advanced Memory Management Programming Guide under the self-explanatory section “Don’t Use Accessor Methods in Initializer Methods and dealloc”; Migrating to Modern Objective-C at WWDC 2012 at slide 27; in a pull request form Dave DeLong’s. 此外，在 init 中使用 setter 不会很好执行 UIAppearence 代理（参见 UIAppearance for Custom Views 看更多相关信息)。 点符号当使用 setter getter 方法的时候尽量使用点符号。应该总是用点符号来访问以及设置属性。 例子: 12view.backgroundColor = [UIColor orangeColor];[UIApplication sharedApplication].delegate; 不要这样: 12[view setBackgroundColor:[UIColor orangeColor]];UIApplication.sharedApplication.delegate; 使用点符号会让表达更加清晰并且帮助区分属性访问和方法调用 属性定义推荐按照下面的格式来定义属性 1@property (nonatomic, readwrite, copy) NSString *name; 属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。(译者注：习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作) 你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。 属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去） 为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly 并且在类扩展中重新定义通用的属性为 readwrite 的。 123456789101112//.h文件中@interface MyClass : NSObject@property (nonatomic, readonly, strong) NSObject *object;@end//.m文件中@interface MyClass ()@property (nonatomic, readwrite, strong) NSObject *object;@end@implementation MyClass//Do Something cool@end 描述BOOL属性的词如果是形容词，那么setter不应该带is前缀，但它对应的 getter 访问器应该带上这个前缀，如： 1@property (assign, getter=isEditable) BOOL editable; 文字和例子引用自 Cocoa Naming Guidelines。 在实现文件中应避免使用@synthesize,因为Xcode已经自动为你添加了。 私有属性私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。 例子: 123@interface ZOCViewController ()@property (nonatomic, strong) UIView *bannerView;@end 可变对象任何可以用一个可变的对象设置的（(比如 NSString,NSArray,NSURLRequest)）属性的内存管理类型必须是 copy 的。 这是为了确保防止在不明确的情况下修改被封装好的对象的值(译者注：比如执行 array(定义为 copy 的 NSArray 实例) = mutableArray，copy 属性会让 array 的 setter 方法为 array = [mutableArray copy], [mutableArray copy] 返回的是不可变的 NSArray 实例，就保证了正确性。用其他属性修饰符修饰，容易在直接赋值的时候，array 指向的是 NSMuatbleArray 的实例，在之后可以随意改变它的值，就容易出错)。 你应该同时避免暴露在公开的接口中可变的对象，因为这允许你的类的使用者改变类自己的内部表示并且破坏类的封装。你可以提供可以只读的属性来返回你对象的不可变的副本。 1234567/* .h */@property (nonatomic, readonly) NSArray *elements/* .m */- (NSArray *)elements &#123; return [self.mutableElements copy];&#125; 懒加载（Lazy Loading）当实例化一个对象需要耗费很多资源，或者配置一次就要调用很多配置相关的方法而你又不想弄乱这些方法时，我们需要重写 getter 方法以延迟实例化，而不是在 init 方法里给对象分配内存。通常这种操作使用下面这样的模板： 12345678910- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;];//毫秒是SSS，而非SSSSS &#125; return _dateFormatter;&#125; 即使这样做在某些情况下很不错，但是在实际这样做之前应当深思熟虑。事实上，这样的做法是可以避免的。下面是使用延迟实例化的争议。 getter 方法应该避免副作用。看到 getter 方法的时候，你不会想到会因此创建一个对象或导致副作用，实际上如果调用 getter 方法而不使用其返回值编译器会报警告 “Getter 不应该仅因它产生的副作用而被调用”。 副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。（译者注） 你在第一次访问的时候改变了初始化的消耗，产生了副作用，这会让优化性能变得困难（以及测试） 这个初始化可能是不确定的：比如你期望属性第一次被一个方法访问，但是你改变了类的实现，访问器在你预期之前就得到了调用，这样可以导致问题，特别是初始化逻辑可能依赖于类的其他不同状态的时候。总的来说最好明确依赖关系。 这个行为不是 KVO 友好的。如果 getter 改变了引用，他应该通过一个 KVO 通知来通知改变。当访问 getter 的时候收到一个改变的通知很奇怪。 方法参数断言你的方法可能要求一些参数来满足特定的条件（比如不能为nil），在这种情况下最好使用 NSParameterAssert() 来断言条件是否成立或是抛出一个异常。 私有方法永远不要在你的私有方法前加上 _ 前缀。这个前缀是 Apple 保留的。不要冒重载苹果的私有方法的险。 相等性当你要实现相等性的时候记住这个约定：你需要同时实现isEqual 和 hash方法。如果两个对象是被isEqual认为相等的，它们的 hash 方法需要返回一样的值。但是如果 hash 返回一样的值，并不能确保他们相等。 这个约定当对象被存储在集合中（如 NSDictionary 和 NSSet 在底层使用 hash 表数据的数据结构）的时候，用来查找这些对象的。 123456789101112131415161718192021@implementation ZOCPerson- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; &#125; // check objects properties (name and birthday) for equality （检查对象属性（名字和生日）的相等性 ... return propertiesMatch;&#125;- (NSUInteger)hash &#123; return [self.name hash] ^ [self.birthday hash];&#125;@end 一定要注意 hash 方法不能返回一个常量。这是一个典型的错误并且会导致严重的问题，因为实际上hash方法的返回值会作为对象在 hash 散列表中的 key,这会导致 hash 表 100% 的碰撞。 你总是应该用 isEqualTo&lt;#class-name-without-prefix#&gt;: 这样的格式实现一个相等性检查方法。如果你这样做，会优先调用这个方法来避免上面的类型检查。 一个完整的 isEqual 方法应该是这样的： 1234567891011121314151617181920212223242526- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; &#125; return [self isEqualToPerson:(ZOCPerson *)object];&#125;- (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;&#125; 译者注：一般而言我们会直接调用自定义的isEqualTo__ClassName__:方法，对类的实例判等。 像相等性的开篇已经提到的那样，这里应该复写isEqual:方法，因为NSObject的isEqual:方法显然不会考虑我们自定义类的类型判断及属性的相等性。当我们自定义的类的对象处在无序集合中被查找时，会自动调用isEqual:。同样的该类的hash方法，也会在集合查找对象的时候被使用，我们也可以通过复写hash方法以达到用自己的标准来判定对象是否hash等同。 我们实现的hash方法应该建立在系统提供的各种对象的hash方法之上（像开篇的例程那样）。不推荐自己去实现某种hash算法来替代系统提供的hash算法，这一般而言会大大影响性能或者准确性，系统提供的hash算法已经经过无数次修缮，足以满足你的要求。 一个对象实例的 hash 计算结果应该是确定的。当它被加入到一个容器对象（比如 NSArray, NSSet, 或者 NSDictionary）的时候这是很重要的，否则行为会无法预测（所有的容器对象使用对象的 hash 来查找或者实施特别的行为，如确定唯一性）这也就是说，应该用不可变的属性来计算 hash 值，或者，最好保证对象是不可变的。 Categories虽然我们知道这样写很丑, 但是我们应该要在我们的 category 方法前加上自己的小写前缀以及下划线，比如- (id)zoc_myCategoryMethod。 这种实践同样被苹果推荐。 这是非常必要的。因为如果在扩展的 category 或者其他 category 里面已经使用了同样的方法名，会导致不可预计的后果。实际上，实际被调用的是最后被加载的那个 category 中方法的实现(译者注：如果导入的多个 category 中有一些同名的方法导入到类里时，最终调用哪个是由编译时的加载顺序来决定的，最后一个加载进来的方法会覆盖之前的方法)。 如果想要确认你的分类方法没有覆盖其他实现的话，可以把环境变量 OBJC_PRINT_REPLACED_METHODS 设置为 YES，这样那些被取代的方法名字会打印到 Console 中。现在 LLVM 5.1 不会为此发出任何警告和错误提示，所以自己小心不要在分类中重载方法。 一个好的实践是在 category 名中使用前缀。 例子 123@interface NSDate (ZOCTimeExtensions)- (NSString *)zoc_timeAgoShort;@end 不要这样 123@interface NSDate (ZOCTimeExtensions)- (NSString *)timeAgoShort;@end 分类可以用来在头文件中定义一组功能相似的方法。这是在 Apple的 Framework 也很常见的一个实践（下面例子的取自NSDate 头文件）。我们也强烈建议在自己的代码中这样使用。 我们的经验是，创建一组分类对以后的重构十分有帮助。一个类的接口增加的时候，可能意味着你的类做了太多事情，违背了类的单一功能原则。 之前创造的方法分组可以用来更好地进行不同功能的表示，并且把类打破在更多自我包含的组成部分里。 12345678910111213141516@interface NSDate : NSObject &lt;NSCopying, NSSecureCoding&gt;@property (readonly) NSTimeInterval timeIntervalSinceReferenceDate;@end@interface NSDate (NSDateCreation)+ (instancetype)date;+ (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;+ (instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;+ (instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;+ (instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;// ...@end Protocols在 Objective-C 的世界里面经常错过的一个东西是抽象接口。接口（interface）这个词通常指一个类的 .h 文件，但是它在 Java 程序员眼里有另外的含义： 一系列不依赖具体实现的方法的定义。(译者注：在OC中，类的接口对应在.m文件中都会有具体的实现，但Java中接口更接近于OC中的抽象接口或者说协议(protocol)) 在 Objective-C 里是通过 protocol 来实现抽象接口的。因为历史原因，protocol （使用方法类似java的接口）并没有大量地在Objective-C的代码中使用也没有在社区中普及(指的是那种像Java程序员使用接口那样来使用protocol的方式)。一个主要原因是大多数的 Apple 开发的代码没有采用这种的方式，而几乎所有的开发者都是遵从 Apple 的模式以及指南。Apple 几乎只是在委托模式下使用 protocol。 但是抽象接口的概念很强大，在计算机科学的历史中颇有渊源，没有理由不在 Objective-C 中使用。 这里通过一个具体的例子来解释 protocol 的强大力量（用作抽象接口）：把非常糟糕的设计的架构改造为一个良好的可复用的代码。 这个例子是在实现一个 RSS 阅读器（它可是经常在技术面试中作为一个测试题呢）。 要求很简单：在TableView中展示一个远程的RSS订阅。 一个幼稚的方法是创建一个 UITableViewController 的子类，并且把所有的检索订阅数据，解析以及展示的逻辑放在一起，或者说是一个 MVC (Massive View Controller)。这可以跑起来，但是它的设计非常糟糕，不过它足够过一些要求不高的面试了。 最小的步骤是遵从单一功能原则，创建至少两个组成部分来完成这个任务： 一个 feed 解析器来解析搜集到的结果 一个 feed 阅读器来显示结果 这些类的接口可以是这样的： 123456789101112@interface ZOCFeedParser : NSObject@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;@property (nonatomic, strong) NSURL *url;- (id)initWithURL:(NSURL *)url;- (BOOL)start;- (void)stop;@end 123456@interface ZOCTableViewController : UITableViewController- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end ZOCFeedParser 用 NSURL 进行初始化，来获取 RSS 订阅（在这之下可能会使用 NSXMLParser 和 NSXMLParserDelegate 创建有意义的数据），ZOCTableViewController 会用这个 parser 来进行初始化。 我们希望它显示 parser 接受到的值并且我们用下面的 protocol 实现委托： 123456789@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item;- (void)feedParserDidFinish:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;@end 我要说，这是一个处理RSS业务的完全合理而恰当的protocol。这个ViewController在Public接口中将遵循这个protocol： 1@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt; 最后创建的代码是这样子的： 123456NSURL *feedURL = [NSURL URLWithString:@&quot;http://www.bbc.co.uk/feed.rss&quot;];ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];feedParser.delegate = tableViewController; 到目前你可能觉得你的代码还是不错的，但是有多少代码是可以有效复用的呢？view controller 只能处理 ZOCFeedParser 类型的对象： 从这点来看我们只是把代码分离成了两个组成部分，而没有做任何其他有价值的事情。 view controller 的职责应该是“显示某些东西提供的内容”，但是如果我们只允许传递ZOCFeedParser的话，就不是这样的了。这就体现了需要传递给 view controller 一个更泛型的对象的需求。 我们使用 ZOCFeedParserProtocol 这个 protocol (在 ZOCFeedParserProtocol.h 文件里面，同时文件里也有 ZOCFeedParserDelegate )。 12345678910111213141516171819@protocol ZOCFeedParserProtocol &lt;NSObject&gt;@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;@property (nonatomic, strong) NSURL *url;- (BOOL)start;- (void)stop;@end@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item;- (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;@end 注意这个代理 protocol 现在处理响应我们新的 protocol， 而且 ZOCFeedParser 的接口文件更加精炼了： 123456@interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt;- (id)initWithURL:(NSURL *)url;@end 因为 ZOCFeedParser 实现了 ZOCFeedParserProtocol，它需要实现所有的required方法。从这点来看 viewController能接受任何遵循该协议的对象，只要确保所有的对象都会响应start和stop方法并通过delegate属性提供信息(译者注：因为protocol默认情况下所有的方法定义都是required的)。对指定的对象而言，这就是viewController所要知道的一切,且不需要知道其实现的细节。 123456@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;@end 上面的代码片段的改变看起来不多，但是有了一个巨大的提升。view controller 将基于协议而不是具体的实现来工作。这带来了以下的优点： view controller 现在可以接收通过delegate属性提供信息的任意对象：可以是 RSS 远程解析器，或者本地解析器，或是一个读取其他远程或者本地数据的服务 ZOCFeedParser 和 ZOCFeedParserDelegate 可以被其他组成部分复用 ZOCViewController （UI逻辑部分）可以被复用 测试更简单了，因为可以用 mock 对象来达到 protocol 预期的效果 当实现一个 protocol 你总应该坚持 里氏替换原则。这个原则是：你应该可以取代任意接口（也就是Objective-C里的”protocol”）实现，而不用改变客户端或者相关实现。 此外，这也意味着protocol不该关心类的实现细节；设计protocol的抽象表述时应非常用心，并且要牢记它和它背后的实现是不相干的，真正重要的是协议（这个暴露给使用者的抽象表述）。 任何在未来可复用的设计，无形当中可以提高代码质量，这也应该一直是程序员的追求。是否这样设计代码，就是大师和菜鸟的区别。 最后的代码可以在这里 找到。 NSNotification当你定义你自己的 NSNotification 的时候你应该把你的通知的名字定义为一个字符串常量，就像你暴露给其他类的其他字符串常量一样。你应该在公开的接口文件中将其声明为 extern 的， 并且在对应的实现文件里面定义。 因为你在头文件中暴露了符号，所以你应该按照统一的命名空间前缀法则，用类名前缀作为这个通知名字的前缀。 同时，用一个 Did/Will 这样的动词以及用 “Notifications” 后缀来命名这个通知也是一个好的实践。 12345// Foo.hextern NSString * const ZOCFooDidBecomeBarNotification// Foo.mNSString * const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;; 美化代码空格 缩进使用 4 个空格。 永远不要使用 tab, 确保你在 Xcode 的设置里面是这样设置的。 方法的大括号和其他的大括号(if/else/switch/while 等) 总是在同一行开始，在新起一行结束。 推荐: 123456if (user.isHappy) &#123; //Do something&#125;else &#123; //Do something else&#125; 不推荐: 123456if (user.isHappy)&#123; //Do something&#125; else &#123; //Do something else&#125; 方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空格应该用来分离功能，但是通常不同的功能应该用新的方法来定义。 优先使用 auto-synthesis。但是如果必要的话， @synthesize and @dynamic 在实现文件中的声明应该新起一行。 应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。 推荐: 1234567[UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; 不推荐: 12345[UIView animateWithDuration:1.0 animations:^&#123; // something&#125; completion:^(BOOL finished) &#123; // something&#125;]; 如果自动对齐让可读性变得糟糕，那么应该在之前把 block 定义为变量，或者重新考虑你的代码签名设计。 换行本指南关注代码显示效果以及在线浏览的可读性，所以换行是一个重要的主题。 举个例子： 1self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 一个像上面的长行的代码在第二行以一个间隔（2个空格）延续 12self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 括号在以下的地方使用 Egyptian风格 括号 （译者注：又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格。关于为什么叫做 Egyptian Brackets，可以参考 http://blog.codinghorror.com/new-programming-jargon/ ) 控制语句 (if-else, for, switch) 非 Egyptian 括号可以用在： 类的实现（如果存在) 方法的实现 代码组织来自 Mattt Thompson code organization is a matter of hygiene (代码组织是卫生问题) 我们十分赞成这句话。清晰地组织代码和规范地进行定义, 是你对自己以及其他阅读代码的人的尊重。 利用代码块一个 GCC 非常模糊的特性，以及 Clang 也有的特性是，代码块如果在闭合的圆括号内的话，会返回最后语句的值 1234NSURL *url = (&#123; NSString *urlString = [NSString stringWithFormat:@&quot;%@/%@&quot;, baseURLString, endpoint]; [NSURL URLWithString:urlString];&#125;); PragmaPragma Mark#pragma mark - 是一个在类内部组织代码并且帮助你分组方法实现的好办法。 我们建议使用 #pragma mark - 来分离: 不同功能组的方法 protocols 的实现 对父类方法的重写 1234567891011121314151617181920212223242526272829303132333435363738- (void)dealloc &#123; /* ... */ &#125;- (instancetype)init &#123; /* ... */ &#125;#pragma mark - View Lifecycle （View 的生命周期）- (void)viewDidLoad &#123; /* ... */ &#125;- (void)viewWillAppear:(BOOL)animated &#123; /* ... */ &#125;- (void)didReceiveMemoryWarning &#123; /* ... */ &#125;#pragma mark - Custom Accessors （自定义访问器）- (void)setCustomProperty:(id)value &#123; /* ... */ &#125;- (id)customProperty &#123; /* ... */ &#125;#pragma mark - IBActions - (IBAction)submitData:(id)sender &#123; /* ... */ &#125;#pragma mark - Public- (void)publicMethod &#123; /* ... */ &#125;#pragma mark - Private- (void)zoc_privateMethod &#123; /* ... */ &#125;#pragma mark - UITableViewDataSource- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; /* ... */ &#125;#pragma mark - ZOCSuperclass// ... 重载来自 ZOCSuperclass 的方法#pragma mark - NSObject- (NSString *)description &#123; /* ... */ &#125; 上面的标记能明显分离和组织代码。你还可以用 cmd+Click 来快速跳转到符号定义地方。但是小心，即使 paragma mark 是一门手艺，但是它不是让你类里面方法数量增加的一个理由：类里面有太多方法说明类做了太多事情，需要考虑重构了。 关于 pragma在 http://raptureinvenice.com/pragmas-arent-just-for-marks/ 有很好的关于 pragma 的讨论了，在这边我们再做部分说明。 大多数 iOS 开发者平时并没有和很多编译器选项打交道。一些选项是对控制严格检查（或者不检查）你的代码或者错误的。有时候，你想要用 pragma 直接产生一个异常，临时打断编译器的行为。 当你使用ARC的时候，编译器帮你插入了内存管理相关的调用。但是这样可能产生一些烦人的事情。比如你使用 NSSelectorFromString 来动态地产生一个 selector 调用的时候，ARC不知道这个方法是哪个并且不知道应该用那种内存管理方法，你会被提示 performSelector may cause a leak because its selector is unknown（执行 selector 可能导致泄漏，因为这个 selector 是未知的）. 如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告 123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;[myObj performSelector:mySelector withObject:name];#pragma clang diagnostic pop 注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。 全部的选项可以在 The Clang User’s Manual 找到并且学习。 忽略没用使用变量的编译警告告诉你申明的变量它将不会被使用，这种做法很有用。大多数情况下，你希望移除这些引用来（稍微地）提高性能，但是有时候你希望保留它们。为什么？或许它们以后有用，或者有些特性只是暂时移除。无论如何，一个消除这些警告的好方法是用相关语句进行注解，使用 #pragma unused(): 1234567- (NSInteger)giveMeFive&#123; NSString *foo; #pragma unused (foo) return 5;&#125; 现在你的代码不用任何编译警告了。注意你的 pragma 需要标记到问题代码之下。 明确编译器警告和错误编译器是一个机器人，它会标记你代码中被 Clang 规则定义为错误的地方。但是，你总是比 Clang 更聪明。通常，你会发现一些讨厌的代码会导致这个问题，但是暂时却解决不了。你可以这样明确一个错误： 12345- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor&#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor);&#125; 类似的，你可以这样标明一个警告 12345678910- (float)divide:(float)dividend by:(float)divisor&#123; #warning Dude, don&apos;t compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125;&#125; 字符串文档所有重要的方法，接口，分类以及协议定义应该有伴随的注释来解释它们的用途以及如何使用。更多的例子可以看 Google 代码风格指南中的 File and Declaration Comments。 简而言之：有长的和短的两种字符串文档。 短文档适用于单行的文件，包括注释斜杠。它适合简短的函数，特别是（但不仅仅是）非 public 的 API： 1// Return a user-readable form of a Frobnozz, html-escaped. 文本应该用一个动词 (“return”) 而不是 “returns” 这样的描述。 如果描述超过一行，应改用长字符串文档： 以/**开始 换行写一句总结的话，以?或者!或者.结尾。 空一行 在与第一行对齐的位置开始写剩下的注释 最后用*/结束。 1234567/** This comment serves to demonstrate the format of a docstring. Note that the summary line is always at most one line long, and after the opening block comment, and each line of text is preceded by a single space.*/ 一个函数必须有一个字符串文档，除非它符合下面的所有条件： 非公开 很短 显而易见 字符串文档应该描述函数的调用符号和语义，而不是它如何实现。 注释当它需要的时候，注释应该用来解释特定的代码做了什么。所有的注释必须被持续维护或者干脆就删掉。 块注释应该被避免，代码本身应该尽可能就像文档一样表示意图，只需要很少的打断注释。 例外： 这不能适用于用来产生文档的注释 头文档一个类的文档应该只在 .h 文件里用 Doxygen/AppleDoc 的语法书写。 方法和属性都应该提供文档。 例子: 12345678910/** * Designated initializer. * * @param store The store for CRUD operations. * @param searchService The search service used to query the store. * * @return A ZOCCRUDOperationsStore object. */- (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService; 对象间的通讯对象之间需要通信，这也是所有软件的基础。再非凡的软件也需要通过对象通信来完成复杂的目标。本章将深入讨论一些设计概念，以及如何依据这些概念来设计出良好的架构。 BlockBlock 是 Objective-C 版本的 lambda 或者 closure（闭包）。 使用 block 定义异步接口: 12- (void)downloadObjectsAtPath:(NSString *)path completion:(void(^)(NSArray *objects, NSError *error))completion; 当你定义一个类似上面的接口的时候，尽量使用一个单独的 block 作为接口的最后一个参数。把需要提供的数据和错误信息整合到一个单独 block 中，比分别提供成功和失败的 block 要好。 以下是你应该这样做的原因： 通常这成功处理和失败处理会共享一些代码（比如让一个进度条或者提示消失）； Apple 也是这样做的，与平台一致能够带来一些潜在的好处； block 通常会有多行代码，如果不作为最后一个参数放在后面的话，会打破调用点； 使用多个 block 作为参数可能会让调用看起来显得很笨拙，并且增加了复杂性。 看上面的方法，完成处理的 block 的参数很常见：第一个参数是调用者希望获取的数据，第二个是错误相关的信息。这里需要遵循以下两点： 若 objects 不为 nil，则 error 必须为 nil 若 objects 为 nil，则 error 必须不为 nil 因为调用者更关心的是实际的数据，就像这样： 123456789- (void)downloadObjectsAtPath:(NSString *)path completion:(void(^)(NSArray *objects, NSError *error))completion &#123; if (objects) &#123; // do something with the data &#125; else &#123; // some error occurred, &apos;error&apos; variable should not be nil by contract &#125;&#125; 此外，Apple 提供的一些同步接口在成功状态下向 error 参数（如果非 NULL) 写入了垃圾值，所以检查 error 的值可能出现问题。 深入 Block一些关键点： block 是在栈上创建的 block 可以复制到堆上 Block会捕获栈上的变量(或指针)，将其复制为自己私有的const(变量)。 (如果在Block中修改Block块外的)栈上的变量和指针，那么这些变量和指针必须用__block关键字申明(译者注：否则就会跟上面的情况一样只是捕获他们的瞬时值)。 如果 block 没有在其他地方被保持，那么它会随着栈生存并且当栈帧（stack frame）返回的时候消失。仅存在于栈上时，block对对象访问的内存管理和生命周期没有任何影响。 如果 block 需要在栈帧返回的时候存在，它们需要明确地被复制到堆上，这样，block 会像其他 Cocoa 对象一样增加引用计数。当它们被复制的时候，它会带着它们的捕获作用域一起，retain 他们所有引用的对象。 如果一个 block引用了一个栈变量或指针，那么这个block初始化的时候会拥有这个变量或指针的const副本，所以(被捕获之后再在栈中改变这个变量或指针的值)是不起作用的。(译者注：所以这时候我们在block中对这种变量进行赋值会编译报错:Variable is not assignable(missing __block type specifier)，因为他们是副本而且是const的.具体见下面的例程)。 当一个 block 被复制后，__block 声明的栈变量的引用被复制到了堆里，复制完成之后，无论是栈上的block还是刚刚产生在堆上的block(栈上block的副本)都会引用该变量在堆上的副本。 (下面代码是译者加的) 12345678910...CGFloat blockInt = 10;void (^playblock)(void) = ^&#123; NSLog(@&quot;blockInt = %zd&quot;, blockInt);&#125;;blockInt ++;playblock();...//结果为:blockInt = 10 用 LLDB 来展示 block 是这样子的： 最重要的事情是 __block 声明的变量和指针在 block 里面是作为显示操作真实值/对象的结构来对待的。 block 在 Objective-C 的 runtime(运行时) 里面被当作一等公民对待：他们有一个 isa 指针，一个类也是用 isa 指针在Objective-C 运行时来访问方法和存储数据的。在非 ARC 环境肯定会把它搞得很糟糕，并且悬挂指针会导致 crash。__block 仅仅对 block 内的变量起作用，它只是简单地告诉 block： 嗨，这个指针或者原始的类型依赖它们在的栈。请用一个栈上的新变量来引用它。我是说，请对它进行双重解引用，不要 retain 它。谢谢，哥们。 如果在定义之后但是 block 没有被调用前，对象被释放了，那么 block 的执行会导致 crash。 __block 变量不会在 block 中被持有，最后… 指针、引用、解引用以及引用计数变得一团糟。 self 的循环引用当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 weak 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify 这里有更为详细的说明） 此外，把持有 block 的属性设置为 nil (比如 self.completionBlock = nil) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。 例子: 1234__weak __typeof(self) weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data];&#125;]; 不要这样: 123[self executeBlock:^(NSData *data, NSError *error) &#123; [self doSomethingWithData:data];&#125;]; 多个语句的例子: 12345678__weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; __strong __typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomethingWithData:data]; [strongSelf doSomethingWithData:data]; &#125;&#125;]; 不要这样: 12345__weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data]; [weakSelf doSomethingWithData:data];&#125;]; 你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。 12__weak __typeof(self)weakSelf = self;__strong __typeof(weakSelf)strongSelf = weakSelf; 这里我们来讨论下 block 里面的 self 的 __weak 和 __strong 限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。 直接在 block 里面使用关键词 self 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。 方案 1. 直接在 block 里面使用关键词 self 如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 copied 但是为了简单我们可以忽略这个）。一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的. 12345678dispatch_block_t completionBlock = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:completionHandler]; 没啥大不了。但是如果通过一个属性中的 self 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？ 12345678self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; 这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告： 1Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用） 所以 __weak 就有用武之地了。 方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。 123456789__weak typeof(self) weakSelf = self;self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, weakSelf);&#125;;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; 这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。 考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。 下面的更有意思。 方案 3. 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用 你可能会想，首先，这是避免 retain cycle 警告的一个技巧。 这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain. Apple 文档 中表示 “为了 non-trivial cycles ，你应该这样” ： 1234567891011121314MyViewController *myController = [[MyViewController alloc] init...];// ...MyViewController * __weak weakMyController = myController;myController.completionHandler = ^(NSInteger result) &#123; MyViewController *strongMyController = weakMyController; if (strongMyController) &#123; // ... [strongMyController dismissViewControllerAnimated:YES completion:nil]; // ... &#125; else &#123; // Probably nothing... &#125;&#125;; 首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为 assign 或者 unsafe_unretained 的，来允许对象在 block 被传递之后被销毁。 我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 __weak/__strong 总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。 还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。 虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 一 些 的 在线 参考, Matt Galloway 的 (Effective Objective-C 2.0 和 Pro Multithreading and Memory Management for iOS and OS X ，大多数开发者始终没有弄清楚概念。 在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子： 方案 1. 直接在 block 里面使用关键词 self 如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain 方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。 block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成nil)。 123456__weak typeof(self) weakSelf = self;dispatch_block_t block = ^&#123; [weakSelf doSomething]; // weakSelf != nil // preemption, weakSelf turned nil [weakSelf doSomethingElse]; // weakSelf == nil&#125;; 方案 3. 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。 不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。 12345678910111213__weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; __strong typeof(self) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; // strongSelf != nil // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的) [strongSelf doSomethingElse]; // strongSelf != nil &#125; else &#123; // Probably nothing... return; &#125;&#125;; 在ARC条件中，如果尝试用 -&gt; 符号访问一个实例变量，编译器会给出非常清晰的错误信息： 1Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 __weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性) 可以用下面的代码展示 1234__weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; id localVal = weakSelf-&gt;someIVar;&#125;; 在最后 方案 1: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。 方案 2: 当 block 被声明为一个 property 的时候使用。 方案 3: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。 委托和数据源委托模式 是 Apple 的框架里面使用广泛的模式，同时它是四人帮的书“设计模式”中的重要模式之一。委托代理模式是单向的，消息的发送方（委托方）需要知道接收方（代理方）是谁，反过来就没有必要了。对象之间耦合较松，发送方仅需知道它的代理方是否遵守相关 protocol 即可。 本质上，委托代理模式仅需要代理方提供一些回调方法，即代理方需要实现一系列空返回值的方法。 不幸的是 Apple 的 API 并没有遵守这个原则，开发者也效仿 Apple 进入了一个误区。典型的例子就是 UITableViewDelegate 协议。 它的一些方法返回 void 类型，就像我们所说的回调： 12- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath; 但是其他的就不是那么回事： 12- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender; 当委托者询问代理者一些信息的时候，这就暗示着信息是从代理者流向委托者而非相反的过程。 这(译者注：委托者 ==Data==&gt; 代理者)是概念性的不同，须用另一个新的名字来描述这种模式：数据源模式。 可能有人会说 Apple 有一个 UITableViewDataSouce protocol 来做这个（虽然使用委托模式的名字），但是实际上它的方法是用来提供真实的数据应该如何被展示的信息的。 12- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 此外，以上两个方法 Apple 混合了展示层和数据层，这显的非常糟糕，但是很少的开发者感到糟糕。而且我们在这里把空返回值和非空返回值的方法都天真地叫做委托方法。 为了分离概念，我们应该这样做： 委托模式(delegate pattern)：事件发生的时候，委托者需要通知代理者。 数据源模式(datasource pattern): 委托者需要从数据源对象拉取数据。 这个是实际的例子： 1234567891011121314151617@class ZOCSignUpViewController;@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;@end@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;@end@interface ZOCSignUpViewController : UIViewController@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDelegate&gt; delegate;@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDataSource&gt; dataSource;@end 代理方法必须以调用者(即委托者)作为第一个参数，就像上面的例子一样。否则代理者无法区分不同的委托者实例。换句话说，调用者(委托者)没有被传递给代理，那就没有方法让代理处理两个不同的委托者，所以下面这种写法人神共怒： 1- (void)calculatorDidCalculateValue:(CGFloat)value; 默认情况下，代理者需要实现 protocol 的方法。可以用@required 和 @optional 关键字来标记方法是否是必要的还是可选的(默认是 @required: 必需的)。 123456@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;@required- (void)signUpViewController:(ZOCSignUpViewController *)controller didProvideSignUpInfo:(NSDictionary *)dict;@optional- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;@end 对于可选的方法，委托者必须在发送消息前检查代理是否确实实现了特定的方法（否则会 crash）： 123if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123; [self.delegate signUpViewControllerDidPressSignUpButton:self];&#125; 继承有时候你可能需要重载代理方法。考虑有两个 UIViewController 子类的情况：UIViewControllerA 和 UIViewControllerB，有下面的类继承关系。 UIViewControllerB &lt; UIViewControllerA &lt; UIViewController UIViewControllerA 遵从 UITableViewDelegate 并且实现了 - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath. 你可能会想要在 UIViewControllerB 中提供一个不同的实现，这个实现可能是这样子的： 12345678- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat retVal = 0; if ([super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123; retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath]; &#125; return retVal + 10.0f;&#125; 但是如果超类(UIViewControllerA)没有实现这个方法呢？此时调用[super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]方法，将使用 NSObject 的实现，在 self 上下文深入查找并且明确 self 实现了这个方法（因为 UITableViewControllerA 遵从 UITableViewDelegate），但是应用将在下一行发生崩溃，并提示如下错误信息： 123*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[UIViewControllerB tableView:heightForRowAtIndexPath:]: unrecognized selector sent to instance 0x8d82820&apos;*** 由于未捕获异常 `NSInvalidArgumentException(无效的参数异常)`导致应用终止，理由是：向实例 ox8d82820 发送了无法识别的 selector `- [UIViewControllerB tableView:heightForRowAtIndexPath:]` 这种情况下我们需要来询问特定的类实例是否可以响应对应的 selector。下面的代码提供了一个小技巧： 12345678- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat retVal = 0; if ([[UIViewControllerA class] instancesRespondToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123; retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath]; &#125; return retVal + 10.0f;&#125; 就像上面丑陋的代码，通常它会是更好的设计架构的方式，因为这种方式代理方法不需要被重写。 多重委托多重委托是一个非常基础的概念，但是，大多数开发者对此非常不熟悉而使用 NSNotifications。就像你可能注意到的，委托和数据源是对象之间的通讯模式，但是只涉及两个对象：委托者和委托。 数据源模式强制一对一的关系，当发送者请求信息时有且只能有一个对象来响应。对于代理模式而言这会有些不同，我们有足够的理由要去实现很多代理者等待(唯一委托者的)回调的场景。 一些情况下至少有两个对象对特定委托者的回调感兴趣，而后者(即委托者)需要知道他的所有代理。这种方法在分布式系统下更为适用并且广泛使用于大型软件的复杂信息流程中。 多重委托可以用很多方式实现，但读者更在乎找到适合自己的个人实现。Luca Bernardi 在他的 LBDelegateMatrioska中提供了上述范式的一个非常简洁的实现。 这里给出一个基本的实现,方便你更好地理解这个概念。即使在Cocoa中也有一些在数据结构中保存 weak 引用来避免 引用循环的方法， 这里我们使用一个类来保留代理对象的 weak 引用(就像单一代理那样): 12345678910@interface ZOCWeakObject : NSObject@property (nonatomic, readonly, weak) id object;//译者注：这里原文并没有很好地实践自己在本书之前章节所讨论的关于property属性修饰符的//人体工程学法则: 从左到右： 原子性 ===》 读写权限 (别名) ===》 内存管理权限符+ (instancetype)weakObjectWithObject:(id)object;- (instancetype)initWithObject:(id)object;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ZOCWeakObject ()@property (nonatomic, weak) id object;@end@implementation ZOCWeakObject+ (instancetype)weakObjectWithObject:(id)object &#123; return [[[self class] alloc] initWithObject:object];&#125;- (instancetype)initWithObject:(id)object &#123; if ((self = [super init])) &#123; _object = object; &#125; return self;&#125;- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[object class]]) &#123; return NO; &#125; return [self isEqualToWeakObject:(ZOCWeakObject *)object];&#125;- (BOOL)isEqualToWeakObject:(ZOCWeakObject *)object &#123; if (!object) &#123; return NO; &#125; BOOL objectsMatch = [self.object isEqual:object.object]; return objectsMatch;&#125;- (NSUInteger)hash &#123; return [self.object hash];&#125;@end 使用 weak 对象来实现多重代理的简单组件： 12345678910111213@protocol ZOCServiceDelegate &lt;NSObject&gt;@optional- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries;@end@interface ZOCGeneralService : NSObject- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;@end@interface ZOCGeneralService ()@property (nonatomic, strong) NSMutableSet *delegates;@end 12345678910111213141516171819202122232425@implementation ZOCGeneralService- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123; if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123; [self.delegates addObject:[[ZOCWeakObject alloc] initWithObject:delegate]]; &#125;&#125;- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123; if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123; [self.delegates removeObject:[[ZOCWeakObject alloc] initWithObject:delegate]]; &#125;&#125;- (void)_notifyDelegates &#123; ... for (ZOCWeakObject *object in self.delegates) &#123; if (object.object) &#123; if ([object.object respondsToSelector:@selector(generalService:didRetrieveEntries:)]) &#123; [object.object generalService:self didRetrieveEntries:entries]; &#125; &#125; &#125;&#125;@end 在 registerDelegate: 和 deregisterDelegate: 方法的帮助下，连接/解除组件之间的联系很简单：在某些时间点上，如果代理不需要接收委托者的回调，仅仅需要’unsubscribe’. 当不同的 view 等待同一个回调来更新界面展示的时候，这很有用：如果 view 只是暂时隐藏（但是仍然存在），它仅仅需要取消对回调的订阅。 面向切面编程Aspect Oriented Programming (AOP，面向切面编程) 在 Objective-C 社区内没有那么有名，但是 AOP 在运行时可以有巨大威力。 但是因为没有事实上的标准，Apple 也没有开箱即用的提供，也显得不重要，开发者都不怎么考虑它。 引用 Aspect Oriented Programming 维基页面: An aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). (一个切面可以通过在多个 join points 中附加的行为来改变基础代码的行为(程序的非切面的部分) ) 在 Objective-C 的世界里，这意味着使用运行时的特性来为指定的方法追加 切面 。切面所附加的行为可以是这样的： 在类的特定方法调用前运行特定的代码 在类的特定方法调用后运行特定的代码 增加代码来替代原来的类的方法的实现 有很多方法可以达成这些目的，但是我们没有深入挖掘，不过它们主要都是利用了运行时。 Peter Steinberger 写了一个库，Aspects 完美地适配了 AOP 的思路。我们发现它值得信赖以及设计得非常优秀，所以我们就在这边作为一个简单的例子。 对于所有的 AOP库，这个库用运行时做了一些非常酷的魔法，可以替换或者增加一些方法（比 method swizzling 技术更有技巧性） Aspect 的 API 有趣并且非常强大： 12345678+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 比如，下面的代码会对于执行 MyClass 类的 myMethod: (实例或者类的方法) 执行块参数。 1234567[MyClass aspect_hookSelector:@selector(myMethod:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; ... &#125; error:nil]; 换一句话说：任意的 MyClass 类型的对象(或者是类型本身当这个 @selector 方法为类方法时)的 @selector 方法执行完后，就会执行这个代码中块参数所提供的代码。 我们为 MyClass 类的 myMethod: 方法增加了切面。 通常 AOP 被用来实现横向切面。统计与日志就是一个完美的例子。 下面的例子里面，我们会用AOP用来进行统计。统计是iOS项目里面一个热门的特性，有很多选择比如 Google Analytics, Flurry, MixPanel, 等等. 大部分统计框架都有教程来指导如何追踪特定的界面和事件，包括在每一个类里写几行代码。 在 Ray Wenderlich 的博客里有 文章 和一些示例代码，通过在你的 view controller 里面加入 Google Analytics 进行统计。 12345678- (void)logButtonPress:(UIButton *)button &#123; id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker send:[[GAIDictionaryBuilder createEventWithCategory:@&quot;UX&quot; action:@&quot;touch&quot; label:[button.titleLabel text] value:nil] build]];&#125; 上面的代码在按钮点击的时候发送了特定的上下文事件。但是当你想追踪屏幕的时候会变得很糟。 12345678- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker set:kGAIScreenName value:@&quot;Stopwatch&quot;]; [tracker send:[[GAIDictionaryBuilder createAppView] build]];&#125; 对于大部分有经验的iOS工程师，这看起来不是很好的代码。我们让 view controller 变得更糟糕了。因为我们加入了统计事件的代码，但是它不是 view controller 的职能。你可以反驳，因为你通常有特定的对象来负责统计追踪，并且你将代码注入了 view controller ，但是无论你隐藏逻辑，问题仍然存在 ：你最后还是在viewDidAppear: 后插入了代码。 我们可以在类的 viewDidAppear: 方法上使用 AOP 来追踪屏幕，并且我们可以使用同样的方法在其他我们感兴趣的方法上添加事件追踪。比如当用户点击某个按钮时(比如:一般调用对应的 IBAction). 方法很简洁且不具侵入性： view controller 不会被不属于它的代码污染 为所有加入到我们代码的切面指定一个 SPOC 文件 (single point of customization)提供了可能 SPOC 应该在 App 刚开始启动的时候用来添加切面 如果SPOC文件异常,至少有一个 selector 或者 类 识别不出来，应用将会在启动时崩溃(对我们来说这很酷). 公司负责统计的团队通常会提供统计文档，罗列出需要追踪的事件。这个文档可以很容易映射到一个 SPOC 文件。 追踪逻辑抽象化之后，扩展到很多其他统计框架会很方便 对于屏幕视图，对于需要定义 selector 的方法，只需要在 SPOC 文件修改相关的类（相关的切面会加入到 viewDidAppear: 方法）。如果要同时发送屏幕视图和事件，需要（依靠统计提供方）提供一个追踪的标示或者可能还需要提供其他的元信息。 我们可能希望一个 SPOC 文件类似下面的（同样的一个 .plist 文件会适配） 12345678910111213141516171819202122232425262728293031323334NSDictionary *analyticsConfiguration()&#123; return @&#123; @&quot;trackedScreens&quot; : @[ @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;label&quot; : @&quot;Main screen&quot; &#125; ], @&quot;trackedEvents&quot; : @[ @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginViewFetchedUserInfo:user:&quot;, @&quot;label&quot; : @&quot;Login with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginViewShowingLoggedOutUser:&quot;, @&quot;label&quot; : @&quot;Logout with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginView:handleError:&quot;, @&quot;label&quot; : @&quot;Login error with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;shareButtonPressed:&quot;, @&quot;label&quot; : @&quot;Share button&quot; &#125; ] &#125;;&#125; 提及的架构托管 在 Github 的EF Education First 中. 12345678910111213141516171819202122232425262728293031323334353637383940- (void)setupWithConfiguration:(NSDictionary *)configuration&#123; // screen views tracking for (NSDictionary *trackedScreen in configuration[@&quot;trackedScreens&quot;]) &#123; Class clazz = NSClassFromString(trackedScreen[@&quot;class&quot;]); [clazz aspect_hookSelector:@selector(viewDidAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSString *viewName = trackedScreen[@&quot;label&quot;]; [tracker trackScreenHitWithName:viewName]; &#125;); &#125; error:nil]; &#125; // events tracking for (NSDictionary *trackedEvents in configuration[@&quot;trackedEvents&quot;]) &#123; Class clazz = NSClassFromString(trackedEvents[@&quot;class&quot;]); SEL selektor = NSSelectorFromString(trackedEvents[@&quot;selector&quot;]); [clazz aspect_hookSelector:selektor withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UserActivityButtonPressedEvent *buttonPressEvent = \ [UserActivityButtonPressedEvent \ eventWithLabel:trackedEvents[@&quot;label&quot;]]; [tracker trackEvent:buttonPressEvent]; &#125;); &#125; error:nil]; &#125;&#125; 参考资料这里有一些和风格指南有关的苹果的文档： The Objective-C Programming Language Cocoa Fundamentals Guide Coding Guidelines for Cocoa iOS App Programming Guide Apple Objective-C conventions: 来自苹果的代码约定 其他： Objective-Clean: an attempt to write a standard for writing Objective-C code with Xcode integration; Uncrustify: source code beautifier. 其他的 Objective-C 风格指南这里有一些和风格指南有关的苹果的文档。如果有一些本书没有涉猎的地方，你或许能在这些之中找到详细说明。 来自 Apple 的： The Objective-C Programming Language Cocoa Fundamentals Guide Coding Guidelines for Cocoa iOS App Programming Guide 来自社区的： NYTimes Objective-C Style Guide Google GitHub Adium Sam Soffes CocoaDevCentral Luke Redpath Marcus Zarra Ray Wenderlich]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS 升级HTTPS通过ATS你所要知道的]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F01%2F14%2F17.1.14%20iOS%E5%8D%87%E7%BA%A7HTTPS%E9%80%9A%E8%BF%87ATS%E4%BD%A0%E6%89%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/2d72ef8dbf5a iOS 升级HTTPS通过ATS你所要知道的苹果强制升级的HTTPS不仅仅是在接口HTTP上加个S那么简单:它所有满足的是iOS9中新增App Transport Security（简称ATS）特性:那满足ATS我们需要做什么呢1.必须是苹果信任的CA证书机构颁发的证书2.后台传输协议必须满足: TLS1.2 (这很重要, 后面的自制证书满足这个条件是前提)3.签字算法只能是下面的一种: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA` 4.证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥。 目前有两种升级到HTTPS得方法:1.第三方认证的颁发CA证书(推荐)2.自己制作证书(这种不知道能不能满足苹果的审核) 一: 第三方认证的颁发CA证书 证书到底长什么样子呢? 取个栗子:大家请打开https://www.baidu.com然后看到 百度的证书分析 那些证书机构颁发的证书能用:苹果官方信任证书 收费SSL证书: 网上百度一大把, 收费还挺贵的,自己可以多找几个对比一下免费SSL证书: 除了收费的CA证书机构, 你还可以去腾讯云申请免费的SSL证书, 教程免费在腾讯云申请SSL证书的方法沃通(WoSign)免费的SSL证书最近被苹果封杀了, 能不能用大家可以看一下苹果的公告: 您的苹果手机轻点“设置”&gt;“通用”&gt;“关于本机”&gt;”证书信任设置”&gt;”进一步了解被信任的证书”去了解 检测你的接口是否满足苹果的ATS要求, 有以下两种方法: 1.腾讯云提供的检测页面检测 腾讯云的检测页面 2 终端输入 nsurl --ats-diagnostics --verbose 你的接口地址大家可以参考这篇文章,里面的说的很明白:关于iOS9中的App Transport Security相关说明及适配(更新于2016.7.1)里面会详细说明你的证书哪点不符合ATS要求当然下面自己制作证书去实现HTTPS的,检测不通过的,所以我觉得审核会被拒这种方法配置好了, 在手机端就什么都不用配置就可以请求了 二: 自己制作证书 苹果官方信任证书里说到有三种证书: `1 可信的根证书用于建立信任链，以验证由可信的根签署的其他证书，例如，与 Web 服务器建立安全连接。当 IT 管理员创建 iPhone、iPad 或 iPod touch 的配置描述文件时，无需提供这些可信的根证书。 2 始终询问的证书不受信任，但不受阻止。使用其中一个证书时，系统将提示您选择是否信任该证书。 3 已阻止的证书视为被盗用，将不再受信任。` 自制证书我觉得应该就是属于第二种情况, 所以这种方法我也不知道能不能通过苹果的审核, 只是提供一个方法给大家参考, 看到网上有人说可以,有人说不可以, 不到1月1号,自己没试过都不敢说大话这种方式拿到后台的接口用谷歌浏览器打开跟百度的证书是有区别的 自己制作证书 很明显没有绿锁, 当打开的时候会询问是否连接这个不受信任的连接才会进一步打开, 下面就来一步步的实现(包括怎么制作证书)iOS使用自签名证书实现HTTPS请求iOS Https协议 自签证书访问数据参考这个例子的时候,博主自带的Demo AFN框架请求不了数据, 我用了最新AFN版本的成功返回数据还可以参考一下iOS 10 适配 ATS app支持https通过App Store审核 我在利用原生的代码测试时遇到的问题 `@interface ViewController () &lt;NSURLSessionDelegate&gt; @end @implementation ViewController (void)viewDidLoad { } (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionDataTask task = [session dataTaskWithURL:[NSURL URLWithString:@”https://www.baidu.com“] completionHandler:^(NSData data, NSURLResponse response, NSError error) {NSLog(@”%@”, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);}];[task resume];} (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTaskdidReceiveResponse:(NSURLResponse )responsecompletionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler {NSLog(@”接收到服务器响应”);//注意：这里需要使用completionHandler回调告诉系统应该如何处理服务器返回的数据//默认是取消/**NSURLSessionResponseCancel = 0, 默认的处理方式，取消NSURLSessionResponseAllow = 1, 接收服务器返回的数据NSURLSessionResponseBecomeDownload = 2, 变成一个下载请求NSURLSessionResponseBecomeStream 变成一个流 /completionHandler(NSURLSessionResponseAllow);} (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTaskdidReceiveData:(NSData *)data {NSLog(@”获取到服务段数据”);NSLog(@”%@”,[self jsonToDictionary:data]);} (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )taskdidCompleteWithError:(nullable NSError *)error {NSLog(@”请求完成%@”, error);} (void)URLSession:(NSURLSession )session didReceiveChallenge:(NSURLAuthenticationChallenge )challengecompletionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential _Nullable credential))completionHandler {NSLog(@”证书认证”);if ([[[challenge protectionSpace] authenticationMethod] isEqualToString: NSURLAuthenticationMethodServerTrust]) {do{SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];NSCAssert(serverTrust != nil, @”serverTrust is nil”);if(nil == serverTrust)break; / failed //* 导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称/NSString cerPath = [[NSBundle mainBundle] pathForResource:@”ca” ofType:@”cer”];//自签名证书NSData* caCert = [NSData dataWithContentsOfFile:cerPath]; NSCAssert(caCert != nil, @”caCert is nil”);if(nil == caCert)break; / failed / SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);NSCAssert(caRef != nil, @”caRef is nil”);if(nil == caRef)break; / failed / //可以添加多张证书NSArray *caArray = @[(__bridge id)(caRef)]; NSCAssert(caArray != nil, @”caArray is nil”);if(nil == caArray)break; / failed / //将读取的证书设置为服务端帧数的根证书OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);NSCAssert(errSecSuccess == status, @”SecTrustSetAnchorCertificates failed”);if(!(errSecSuccess == status))break; / failed / SecTrustResultType result = -1;//通过本地导入的证书来验证服务器的证书是否可信status = SecTrustEvaluate(serverTrust, &amp;result);if(!(errSecSuccess == status))break; / failed /NSLog(@”stutas:%d”,(int)status);NSLog(@”Result: %d”, result); BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed);if (allowConnect) {NSLog(@”success”);}else {NSLog(@”error”);} / kSecTrustResultUnspecified and kSecTrustResultProceed are success /if(! allowConnect){break; / failed /} #if 0/ Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success // since the user will likely tap-through to see the dancing bunnies /if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError)break; / failed to trust cert (good in this case) / #endif // The only good exit pointNSLog(@”信任该证书”); NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];completionHandler(NSURLSessionAuthChallengeUseCredential,credential);return [[challenge sender] useCredential: credentialforAuthenticationChallenge: challenge]; }while(0);} // Bad dogNSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge,credential);return [[challenge sender] cancelAuthenticationChallenge: challenge];} (NSDictionary )jsonToDictionary:(NSData )jsonData {NSError jsonError;NSDictionary resultDic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableLeaves error:&amp;jsonError];return resultDic;} @end 下面说说我在配置自己制作证书过程中遇到的问题:1.转换证书: 把后台给你的.crt证书转化为.cer后缀终端命令行openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 2.利用系统的方法来不到- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler { NSLog(@&quot;证书认证&quot;); }这个方法的时候, 是因为后台的传输协议还没升级到TLS1.2, 叫后台升级后就可以来到验证证书的这个方法了. 3.拖入证书读取不出证书数据参考: https的证书错误，错误码-1012问题及解决方案 SDWebImage: 项目中大家用到AFN请求网络数据, 升级验证SSL证书的方案相信你看完上面的参考文章已经没问题了, 我给出的代码, 自定义网络请求也没问题了, 还有就是SDWebImage框架的请求HTTPS的图片时,大家可以绕过证书验证去加载图片[imageView sd_setImageWithURL:[NSURL URLWithString:urlString] placeholderImage:self.placeholder options:SDWebImageAllowInvalidSSLCertificates]; 恩, 这就是这几天升级HTTPS觉得有帮助的参考和总结.希望帮到你]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F12%2F10%2F16.12.10%20_iOS%20%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F--%E8%A7%A3%E5%AF%86%20MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E4%BB%A5%E5%8F%8AVIPER%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[原文：http://www.cocoachina.com/ios/20160108/14916.html 本文由CocoaChina译者lynulzy（社区ID）翻译 作者：Bohdan Orlov 原文：iOS Architecture Patterns 在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？ 相信你会找到以上问题的答案，如果没找到请在评论中指出。 你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。 掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题： 谁应该来负责网络请求？Model 还是 Controller ？ 应该怎样向一个新的页面的 ViewModel 传入一个 Model ? 谁来创建一个 VIPER 模块，是 Router 还是 Presenter ? 为什么要关注架构设计？ 因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样： 这个类是一个UIViewController的子类 数据直接在UIViewController中存储 UIView类几乎不做任何事情 Model 仅仅是一个数据结构 单元测试覆盖不了任何用例 以上这些情况仍旧会出现，即使是你遵循了Apple的指导原则并且实现了其 MVC(模式，所以，大可不必惊慌。Apple所提出的 MVC 模式存在一些问题，我们之后会详述。 在此，我们可以定义一个好的架构应该具备的特点： 任务均衡分摊给具有清晰角色的实体 可测试性通常都来自与上一条（对于一个合适的架构是非常容易） 易用性和低成本维护 为什么采用分布式? 采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 单一功能原则 的前提下，将功能划分给不同的实体。 为什么需要易测性？ 其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少一周的时间才能再次分发给用户。 为什么需要易用性？ 这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。 MV(X）系列概要 当今我们已经有很架构设计模式方面的选择: MVC MVP MVVM VIPER 前三种设计模式都把一个应用中的实体分为以下三类： Models–负责主要的数据或者操作数据的数据访问层，可以想象 Perspn 和 PersonDataProvider 类。 Views–负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。 Controller/Presenter/ViewModel–负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，同时将更改的信息返回到View上。 将实体进行划分给我们带来了以下好处： 更好的理解它们之间的关系 复用（尤其是对于View和Model） 独立的测试 让我们开始了解MV(X)系列，之后再返回到VIPER模式。 MVC的过去 在我们探讨Apple的MVC模式之前，我们来看下传统的MVC模式。 传统的MVC 在这里，View并没有任何界限，仅仅是简单的在Controller中呈现出Model的变化。想象一下，就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。尽管在iOS平台上实现这这种MVC模式是没有任何难度的，但是它并不会为我们解决架构问题带来任何裨益。因为它本身也是，三个实体间相互都有通信，而且是紧密耦合的。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。 “传统的MVC架构不适用于当下的iOS开发” 苹果推荐的MVC–愿景 Cocoa MVC 由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。 理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，为View controller减负也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？ 苹果推荐的MVC–事实 Realistic Cocoa MVC Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们经常被混杂到View的生命周期中，因此很难说View和ViewController是分离的。尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，View的最大的任务就是向Controller传递用户动作事件。ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。 你可能会看见过很多次这样的代码： var&nbsp;userCell&nbsp;=&nbsp;tableView.dequeueReusableCellWithIdentifier("identifier")&nbsp;as&nbsp;UserCell userCell.configureWithUser(user) 这个cell,正是由View直接来调用Model，所以事实上MVC的原则已经违背了，但是这种情况是一直发生的甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，不向View传递一个Model对象，这样就会大大增加Controller的体积。 “Cocoa 的MVC被写成Massive View Controller 是不无道理的。” 直到进行单元测试的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难–你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。 我们看下一些简单的例子: import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{&nbsp;//&nbsp;View&nbsp;+&nbsp;Controller &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;person:&nbsp;Person! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVC let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;view&nbsp;=&nbsp;GreetingViewController() view.person&nbsp;=&nbsp;model; “MVC可以在一个正在显示的ViewController中实现” 这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。 事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作，因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。 “View和Controller的接口**并不适合单元测试。”** 以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征: 任务均摊–View和Model确实是分开的，但是View和Controller却是紧密耦合的 可测试性–由于糟糕的分散性，只能对Model进行测试 易用性–与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。 如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。 “就开发速度而言，Cocoa MVC是最好的架构选择方案。” MVP&nbsp;实现了Cocoa的MVC的愿景 Passive View variant of MVP 这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字叫做MVC，但是，这就是说苹果的MVC实际上就是MVP了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。 “假如告诉你UIViewController就是View呢？” 就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出： import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } protocol&nbsp;GreetingView:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String) } protocol&nbsp;GreetingViewPresenter&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person) &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting() } class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingViewPresenter&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;unowned&nbsp;let&nbsp;view:&nbsp;GreetingView &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person &nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view&nbsp;=&nbsp;view &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;presenter:&nbsp;GreetingViewPresenter! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.presenter.showGreeting() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVP let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;view&nbsp;=&nbsp;GreetingViewController() let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter(view:&nbsp;view,&nbsp;person:&nbsp;model) view.presenter&nbsp;=&nbsp;presenter 关于整合问题的重要说明 MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View涉及到Model，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下集中方案中。 我们来看下MVP模式下的三个特性的分析： 任务均摊–我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。 可测试性–非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单 易用性–在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰 “iOS 中的MVP意味着可测试性强、代码量大。” MVP–绑定和信号 还有一些其他形态的MVP–监控控制器的MVP。 这个变体包含了View和Model之间的直接绑定，但是Presenter仍然来管理来自View的动作事件，同时也能胜任对View的更新。 Supervising Presenter variant of the MVP 但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。 和传统的MVC一样，写这样的例子没有什么价值，故不再给出。 MVVM–最新且是最伟大的MV(X)系列的一员 MVVM架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。 从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。 MVVM 它和MVP模式看起来非常像: MVVM将ViewController视作View 在View和Model之间没有紧密的联系 此外，它还有像监管版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间而是在View和ViewModel之间。 那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。 绑定 我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。 如果我们自己不想自己实现，那么我们有两种选择: 基于KVO的绑定库如 RZDataBinding 和 SwiftBond 完全的函数响应式编程，比如像ReactiveCocoa、RxSwift或者 PromiseKit 事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。 但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下函数调用栈： Reactive Debugging 在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。 import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } protocol&nbsp;GreetingViewModelProtocol:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{&nbsp;get&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())?&nbsp;{&nbsp;get&nbsp;set&nbsp;}&nbsp;//&nbsp;function&nbsp;to&nbsp;call&nbsp;when&nbsp;greeting&nbsp;did&nbsp;change &nbsp;&nbsp;&nbsp;&nbsp;init(person:&nbsp;Person) &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting() } class&nbsp;GreetingViewModel&nbsp;:&nbsp;GreetingViewModelProtocol&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingDidChange?(self) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())? &nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(person:&nbsp;Person)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;viewModel:&nbsp;GreetingViewModelProtocol!&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.viewModel.greetingDidChange&nbsp;=&nbsp;{&nbsp;[unowned&nbsp;self]&nbsp;viewModel&nbsp;in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;viewModel.greeting &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self.viewModel,&nbsp;action:&nbsp;"showGreeting",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVVM let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;viewModel&nbsp;=&nbsp;GreetingViewModel(person:&nbsp;model) let&nbsp;view&nbsp;=&nbsp;GreetingViewController() view.viewModel&nbsp;=&nbsp;viewModel 让我们再来看看关于三个特性的评估： 任务均摊 – 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。 可测试性 – ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。 易用性 – 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。 “MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。” VIPER–把LEGO建筑经验迁移到iOS app的设计 VIPER是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。 迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次: VIPER 交互器 – 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。 展示器 – 包含UI层面的业务逻辑以及在交互器层面的方法调用。 实体 – 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。 路由器 – 用来连接VIPER的各个模块。 基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程–想想认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。 当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同: Model 逻辑通过把实体作为最小的数据结构转换到交互器中。 Controller/Presenter/ViewModel的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。 VIPER是第一个通过路由器实现明确的地址导航模式。 “找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。” 例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。 import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Entity&nbsp;(usually&nbsp;more&nbsp;complex&nbsp;e.g.&nbsp;NSManagedObject) &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } struct&nbsp;GreetingData&nbsp;{&nbsp;//&nbsp;Transport&nbsp;data&nbsp;structure&nbsp;(not&nbsp;Entity) &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject:&nbsp;String } protocol&nbsp;GreetingProvider&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData() } protocol&nbsp;GreetingOutput:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData) } class&nbsp;GreetingInteractor&nbsp;:&nbsp;GreetingProvider&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;output:&nbsp;GreetingOutput! &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")&nbsp;//&nbsp;usually&nbsp;comes&nbsp;from&nbsp;data&nbsp;access&nbsp;layer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject&nbsp;=&nbsp;person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;GreetingData(greeting:&nbsp;"Hello",&nbsp;subject:&nbsp;subject) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.output.receiveGreetingData(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } protocol&nbsp;GreetingViewEventHandler&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton() } protocol&nbsp;GreetingView:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String) } class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingOutput,&nbsp;GreetingViewEventHandler&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;view:&nbsp;GreetingView! &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingProvider:&nbsp;GreetingProvider! &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingProvider.provideGreetingData() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;greetingData.greeting&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;greetingData.subject &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;eventHandler:&nbsp;GreetingViewEventHandler! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.eventHandler.didTapShowGreetingButton() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;VIPER&nbsp;module,&nbsp;without&nbsp;Router let&nbsp;view&nbsp;=&nbsp;GreetingViewController() let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter() let&nbsp;interactor&nbsp;=&nbsp;GreetingInteractor() view.eventHandler&nbsp;=&nbsp;presenter presenter.view&nbsp;=&nbsp;view presenter.greetingProvider&nbsp;=&nbsp;interactor interactor.output&nbsp;=&nbsp;presenter 让我们再来评估一下特性: 任务均摊 – 毫无疑问，VIPER是任务划分中的佼佼者。 可测试性 – 不出意外地，更好的分布性就有更好的可测试性。 易用性 – 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。 什么是LEGO 当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些问题，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 Generamba 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。 总结 我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。 因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS可视化动态绘制八种排序过程]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F10%2F21%2F16.10.21_iOS%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[原文：http://www.cocoachina.com/ios/20170105/18522.html 前面几篇博客都是关于排序的，在之前陆陆续续发布的博客中，我们先后介绍了冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序以及快速排序。俗话说的好，做事儿要善始善终，本篇博客就算是对之前那几篇博客的总结了。而本篇博客的示例Demo也是在之前那些博客Demo的基础上做的，也算是集成了各种排序的方法，然后给出了可视化的解决方案。今天博客的内容还是比较有趣的。 因为本猿是做iOS开发的，所以就使用iOS相关的组件来表示上述各种排序的过程。使用可视化方式来感受一下上述这些排序方法的异同。本篇博客所使用的相关的排序代码都是来自于之前的博客。因为我们在之前实现各种排序Demo时，我们定义了相应的排序接口SortType，所以上述的七种排序对外的调用方式是一致的，所以在此基础上给出相应排序的可视化解决方案并不困难。本篇博客就会给出其相应的扩展过程。 如果你想对上述7中排序进行详细的了解，请移步与之前的博客《冒泡排序、插入排序、希尔排序、选择排序》、《堆排序》、《归并排序》、《快速排序》、《基数排序》。废话少说，开始今天的博客。 一、可视化解决方案综述 1.交互UI综述 在本篇博客的第一部分我们先来整体的看一下我们Demo的功能。下方就是我们今天博客中的Demo的交互示意图。上方的输入框可以输入要排序元素的个数，下方输入的是300。程序会根据你输入的个数来随机生成数据，你输入300，就会随机生成300个数据提供排序使用。下方的SegmentControl可以选择不同的排序方式，本篇博客给出了7中常用的排序方式，选择完排序方式后可以点击右上方的排序按钮进行相应的排序。 下方显示的不同颜色的颜色条就是我们要排序的东西，我们会按照从小到大的方式对这些色条进行排序。左图中是未排序的状态，右图中是已经排序的状态。我们上面随机生成的数据反应到色条上就是色条的高度，我们按照色条的高度进行从小到大的排序。下方会给出每种排序的介绍。 2、部分核心代码实现 为了实现今天的Demo，我们需要对之前我们实现的那一些列的排序的方法进行扩展。因为我们之前在实现各种排序时，我们先定义了SortType接口，依据“开放封闭原则”，我们可以为各种排序的类创建一个“简单工厂”以供我们的视图层使用。关于设计模式更多以及更详细的内容，可以移步之前发布的设计模式系列博客《设计模式Swift版》。 上方就是为各种Sort类提供的“简单工厂”。上面这个简单工厂在视图控制器中点击SegmentControl时会使用，因为我们在选择不同排序类的时候需要使用不同的排序对象。下方就是我们视图控制器对“简单工厂”的调用，当然我们所有排序类都有父类，你也可以使用“工厂方法”来创建相应的对象，在此就不做过多赘述了。 下方代码段就是点击SegmentControl要调用的方法，其中从“简单工厂”中获取到相应排序方式的对象后，然后在设置相应的闭包回调。 二、冒泡排序 接下来我们来逐一看一下每种排序的具体效果。下方就是冒泡排序的效果，因为冒泡排序的时间复杂度是O(n^2)的，所以我们先设置元素个数是80， 如果太大的话会比较慢。因为我们在排序步骤结果输出时，每进行一次交换操作或者比较操作让排序线程休眠0.001秒，便于我们观察整个排序过程。 从下方这个动图上我们不难看出冒泡的整个过程，较小的数据从右往左以此往外冒。下方这个效果还是比较直观的，整个冒泡过程就是从后往前比较，如果后边的数要比前边的小就交换。冒泡过程如下所示： 三、选择排序 选择排序的时间复杂度也是O(n^2)。下方是“选择排序”的可视化过程，选择排序的过程就是从无序序列中找出最小的那个值放到有序序列中最后方。不断执行这个过程，我们的序列就是有序的了。下方就是选择排序的整个过程，元素的个数是80. 四、插入排序 插入排序的复杂度与上述选择排序的时间复杂度一样，都是O(n^2)。下方就是插入排序的运行结果。插入排序是从无序序列中取出第一个值，然后插入到前方有序序列中相应的位置。每次插入后，有序序列就会增加1，无序序列就会减少1。下方就是插入排序的过程，如下所示： 五、希尔排序 希尔排序的效率要高一些，其时间复杂度是O(n^(3/2))。下方就是希尔排序的具体执行步骤，希尔排序又称为缩小增量排序。该排序方式是插入排序的升级版，等增量缩小到1时，我们的序列就是有序的了。下方就是希尔排序的具体执行步骤，如下所示： 六、堆排序 堆排序比希尔排序更为高效，其时间复杂度为O(nlog2n)。下方的“堆排序”是根据大顶堆来进行排序的，大顶堆第一个值是序列中最大的，我们可以利用这一点获取无序序列中最大的那个值。首先我们将序列调整为大顶堆，然后把大顶堆的第一个值与最后一个值进行交换，然后再将剩下的序列调整成大顶堆，然后进行下一轮的替换。 七、归并排序 归并排序的时间复杂度也是O(nlog2n)。归并排序就是将无序数组拆分成多个只有一个元素的数组，然后进行两两合并。在合并的过程中将两个数组中的元素进行比较，将较小的放在前方，两个有序的数组合并后依然是有序的，然后再次进行两两合并，直到合并成一个数组为止。下方就是归并排序的执行顺序，从执行过程中，我们可以清楚的看到在排序过程中被分割的小的有序序列。归并排序的执行过程如下所示： 八、快速排序 快速排序的时间复杂度为O(nlog2n)。下方是快速排序的执行步骤，快速排序是利用里分治法的思想。从无序序列中取出一个值，比该值大的放在前方，比该值小的放在后方。然后递归执行前半部分和后半部分依次递归下去，我们的序列就是有序的了。 九、基数排序 下方是基数排序的运行效果，我们先输入1000个元素，生成1000个随机数，选择基数排序。如下所示： 十、上述排序的比较 关于上述排序的比较，在此就不做过多赘述了，就引用“维基百科”中的表格来说明吧，如下所示: 今天博客中所涉及的Demo依然会在github上进行分享，分享地址如下。 github源码分享地址：https://github.com/lizelu/DataStruct-Swift/tree/master/AllKindsOfSortForiOS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS Crash 分析]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F09%2F10%2F16.9.10_iOS_Crash%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/diyagoanyhacker/article/details/41247367 iOS Crash 分析（文一）- 开始iOS Crash 分析（文二）-崩溃日志组成iOS Crash 分析（文三）- 符号化崩溃日志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]一步一步写算法（之 算法总结）]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F07%2F13%2F16.7.13%20_%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%8B%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%89%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/feixiaoxing/article/details/6993718 &nbsp;&nbsp; &nbsp;自10月初编写算法系列的博客以来，陆陆续续以来写了几十篇。按照计划，还有三个部分的内容没有介绍，主要是（Dijkstra算法、二叉平衡树、红黑树）。这部分会在后面的博客补充完整。这里主要是做一个总结，有兴趣的朋友可以好好看看，欢迎大家提出宝贵意见。 &nbsp;&nbsp; &nbsp;（1） 排序算法 &nbsp;&nbsp; &nbsp;快速排序 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;合并排序 &nbsp;&nbsp; &nbsp;堆排序 &nbsp;&nbsp; &nbsp;选择排序 &nbsp;&nbsp; &nbsp;基数排序 &nbsp;&nbsp; &nbsp;冒泡排序 &nbsp;&nbsp; &nbsp;插入排序 &nbsp;&nbsp; &nbsp;希尔排序 &nbsp;&nbsp; &nbsp;链表排序 &nbsp;&nbsp; &nbsp;（2） 数据结构 &nbsp;&nbsp; &nbsp;线性队列 &nbsp;&nbsp; &nbsp;线性堆栈 &nbsp;&nbsp; &nbsp;单向链表 &nbsp;&nbsp; &nbsp;双向链表 &nbsp;&nbsp; &nbsp;循环单向链表 &nbsp;&nbsp; &nbsp;排序二叉树（插入，删除上、中、下、保存和加载） &nbsp;&nbsp; &nbsp;哈希表 &nbsp;&nbsp; &nbsp;哈希二叉树 &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;（3）图 &nbsp;&nbsp; &nbsp;图结构 &nbsp;&nbsp; &nbsp;图创建 &nbsp;&nbsp; &nbsp;图的添加、删除 &nbsp;&nbsp; &nbsp;图的保存 &nbsp;&nbsp; &nbsp;prim算法（上、中、下） &nbsp;&nbsp; &nbsp;哈夫曼树（上、下） &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;克鲁斯卡尔算法（上、中、下） &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;（4）常用算法 &nbsp;&nbsp; &nbsp;查找 &nbsp;&nbsp; &nbsp;内存分配 &nbsp;&nbsp; &nbsp;字符串查找（上、中、下） &nbsp;&nbsp; &nbsp;通用数据结构 &nbsp;&nbsp; &nbsp;通用算法 &nbsp;&nbsp; &nbsp;循环和递归 &nbsp;&nbsp; &nbsp;递归和堆栈 &nbsp;&nbsp; &nbsp;内存中的数据 &nbsp;&nbsp; &nbsp;A*算法 &nbsp;&nbsp; &nbsp;可变参数 &nbsp;&nbsp; &nbsp;函数堆栈 &nbsp;&nbsp; &nbsp;递归寻路 &nbsp;&nbsp; &nbsp;广度遍历、深度遍历 &nbsp;&nbsp; &nbsp;排序二叉树线索化 &nbsp;&nbsp; &nbsp;（5）趣味算法题目 &nbsp;&nbsp; &nbsp;链表逆转 &nbsp;&nbsp; &nbsp;大数计算 &nbsp;&nbsp; &nbsp;n！末位0个数计算 &nbsp;&nbsp; &nbsp;洗牌算法 &nbsp;&nbsp; &nbsp;“数星星” &nbsp;&nbsp; &nbsp;八皇后 &nbsp;&nbsp; &nbsp;数据选择 &nbsp;&nbsp; &nbsp;单词统计 &nbsp;&nbsp; &nbsp;爬楼梯 &nbsp;&nbsp; &nbsp;回数 &nbsp;&nbsp; &nbsp;链表重合 &nbsp;&nbsp; &nbsp;寻找丢失的数 &nbsp;&nbsp; &nbsp;最大公约数、最小公倍数 &nbsp;&nbsp; &nbsp;挑选最大的n个数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS用CGContextRef画各种图形]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F06%2F01%2F16.6.1_IOS%E7%94%A8CGContextRef%E7%94%BB%E5%90%84%E7%A7%8D%E5%9B%BE%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/rhljiayou/article/details/9919713 前言首先了解一下CGContextRef:An opaque type that represents a Quartz 2D drawing environment.Graphics Context是图形上下文,可以将其理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.自己学习时实现的demo，希望对大家有帮助，具体的实现看代码，并有完美的注释解释，还有一些对我帮助的博文供大家参考。都在代码里面。看一下demo效果图先： 自定义CustomView类,CustomView.h: 123456#import &lt;UIKit/UIKit.h&gt; #import &lt;QuartzCore/QuartzCore.h&gt; #define PI 3.14159265358979323846 @interface CustomView : UIView @end 实现类CustomView.m： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#import "CustomView.h" @implementation CustomView - (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; &#125; return self; &#125; // 覆盖drawRect方法，你可以在此自定义绘画和动画 - (void)drawRect:(CGRect)rect &#123; //An opaque type that represents a Quartz 2D drawing environment. //一个不透明类型的Quartz 2D绘画环境,相当于一个画布,你可以在上面任意绘画 CGContextRef context = UIGraphicsGetCurrentContext(); /*写文字*/ CGContextSetRGBFillColor (context, 1, 0, 0, 1.0);//设置填充颜色 UIFont *font = [UIFont boldSystemFontOfSize:15.0];//设置 [@"画圆：" drawInRect:CGRectMake(10, 20, 80, 20) withFont:font]; [@"画线及孤线：" drawInRect:CGRectMake(10, 80, 100, 20) withFont:font]; [@"画矩形：" drawInRect:CGRectMake(10, 120, 80, 20) withFont:font]; [@"画扇形和椭圆：" drawInRect:CGRectMake(10, 160, 110, 20) withFont:font]; [@"画三角形：" drawInRect:CGRectMake(10, 220, 80, 20) withFont:font]; [@"画圆角矩形：" drawInRect:CGRectMake(10, 260, 100, 20) withFont:font]; [@"画贝塞尔曲线：" drawInRect:CGRectMake(10, 300, 100, 20) withFont:font]; [@"图片：" drawInRect:CGRectMake(10, 340, 80, 20) withFont:font]; /*画圆*/ //边框圆 CGContextSetRGBStrokeColor(context,1,1,1,1.0);//画笔线的颜色 CGContextSetLineWidth(context, 1.0);//线的宽度 //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度 // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。 CGContextAddArc(context, 100, 20, 15, 0, 2*PI, 0); //添加一个圆 CGContextDrawPath(context, kCGPathStroke); //绘制路径 //填充圆，无边框 CGContextAddArc(context, 150, 30, 30, 0, 2*PI, 0); //添加一个圆 CGContextDrawPath(context, kCGPathFill);//绘制填充 //画大圆并填充颜 UIColor*aColor = [UIColor colorWithRed:1 green:0.0 blue:0 alpha:1]; CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 CGContextSetLineWidth(context, 3.0);//线的宽度 CGContextAddArc(context, 250, 40, 40, 0, 2*PI, 0); //添加一个圆 //kCGPathFill填充非零绕数规则,kCGPathEOFill表示用奇偶规则,kCGPathStroke路径,kCGPathFillStroke路径填充,kCGPathEOFillStroke表示描线，不是填充 CGContextDrawPath(context, kCGPathFillStroke); //绘制路径加填充 /*画线及孤线*/ //画线 CGPoint aPoints[2];//坐标点 aPoints[0] =CGPointMake(100, 80);//坐标1 aPoints[1] =CGPointMake(130, 80);//坐标2 //CGContextAddLines(CGContextRef c, const CGPoint points[],size_t count) //points[]坐标数组，和count大小 CGContextAddLines(context, aPoints, 2);//添加线 CGContextDrawPath(context, kCGPathStroke); //根据坐标绘制路径 //画笑脸弧线 //左 CGContextSetRGBStrokeColor(context, 0, 0, 1, 1);//改变画笔颜色 CGContextMoveToPoint(context, 140, 80);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 148, 68, 156, 80, 10); CGContextStrokePath(context);//绘画路径 //右 CGContextMoveToPoint(context, 160, 80);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 168, 68, 176, 80, 10); CGContextStrokePath(context);//绘画路径 //右 CGContextMoveToPoint(context, 150, 90);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 158, 102, 166, 90, 10); CGContextStrokePath(context);//绘画路径 //注，如果还是没弄明白怎么回事，请参考：http://donbe.blog.163.com/blog/static/138048021201052093633776/ /*画矩形*/ CGContextStrokeRect(context,CGRectMake(100, 120, 10, 10));//画方框 CGContextFillRect(context,CGRectMake(120, 120, 10, 10));//填充框 //矩形，并填弃颜色 CGContextSetLineWidth(context, 2.0);//线的宽度 aColor = [UIColor blueColor];//blue蓝色 CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 aColor = [UIColor yellowColor]; CGContextSetStrokeColorWithColor(context, aColor.CGColor);//线框颜色 CGContextAddRect(context,CGRectMake(140, 120, 60, 30));//画方框 CGContextDrawPath(context, kCGPathFillStroke);//绘画路径 //矩形，并填弃渐变颜色 //关于颜色参考http://blog.sina.com.cn/s/blog_6ec3c9ce01015v3c.html //http://blog.csdn.net/reylen/article/details/8622932 //第一种填充方式，第一种方式必须导入类库quartcore并#import &lt;QuartzCore/QuartzCore.h&gt;，这个就不属于在context上画，而是将层插入到view层上面。那么这里就设计到Quartz Core 图层编程了。 CAGradientLayer *gradient1 = [CAGradientLayer layer]; gradient1.frame = CGRectMake(240, 120, 60, 30); gradient1.colors = [NSArray arrayWithObjects:(id)[UIColor whiteColor].CGColor, (id)[UIColor grayColor].CGColor, (id)[UIColor blackColor].CGColor, (id)[UIColor yellowColor].CGColor, (id)[UIColor blueColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor greenColor].CGColor, (id)[UIColor orangeColor].CGColor, (id)[UIColor brownColor].CGColor,nil]; [self.layer insertSublayer:gradient1 atIndex:0]; //第二种填充方式 CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB(); CGFloat colors[] = &#123; 1,1,1, 1.00, 1,1,0, 1.00, 1,0,0, 1.00, 1,0,1, 1.00, 0,1,1, 1.00, 0,1,0, 1.00, 0,0,1, 1.00, 0,0,0, 1.00, &#125;; CGGradientRef gradient = CGGradientCreateWithColorComponents (rgb, colors, NULL, sizeof(colors)/(sizeof(colors[0])*4));//形成梯形，渐变的效果 CGColorSpaceRelease(rgb); //画线形成一个矩形 //CGContextSaveGState与CGContextRestoreGState的作用 /* CGContextSaveGState函数的作用是将当前图形状态推入堆栈。之后，您对图形状态所做的修改会影响随后的描画操作，但不影响存储在堆栈中的拷贝。在修改完成后，您可以通过CGContextRestoreGState函数把堆栈顶部的状态弹出，返回到之前的图形状态。这种推入和弹出的方式是回到之前图形状态的快速方法，避免逐个撤消所有的状态修改；这也是将某些状态（比如裁剪路径）恢复到原有设置的唯一方式。 */ CGContextSaveGState(context); CGContextMoveToPoint(context, 220, 90); CGContextAddLineToPoint(context, 240, 90); CGContextAddLineToPoint(context, 240, 110); CGContextAddLineToPoint(context, 220, 110); CGContextClip(context);//context裁剪路径,后续操作的路径 //CGContextDrawLinearGradient(CGContextRef context,CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint,CGGradientDrawingOptions options) //gradient渐变颜色,startPoint开始渐变的起始位置,endPoint结束坐标,options开始坐标之前or开始之后开始渐变 CGContextDrawLinearGradient(context, gradient,CGPointMake (220,90) ,CGPointMake(240,110), kCGGradientDrawsAfterEndLocation); CGContextRestoreGState(context);// 恢复到之前的context //再写一个看看效果 CGContextSaveGState(context); CGContextMoveToPoint(context, 260, 90); CGContextAddLineToPoint(context, 280, 90); CGContextAddLineToPoint(context, 280, 100); CGContextAddLineToPoint(context, 260, 100); CGContextClip(context);//裁剪路径 //说白了，开始坐标和结束坐标是控制渐变的方向和形状 CGContextDrawLinearGradient(context, gradient,CGPointMake (260, 90) ,CGPointMake(260, 100), kCGGradientDrawsAfterEndLocation); CGContextRestoreGState(context);// 恢复到之前的context //下面再看一个颜色渐变的圆 CGContextDrawRadialGradient(context, gradient, CGPointMake(300, 100), 0.0, CGPointMake(300, 100), 10, kCGGradientDrawsBeforeStartLocation); /*画扇形和椭圆*/ //画扇形，也就画圆，只不过是设置角度的大小，形成一个扇形 aColor = [UIColor colorWithRed:0 green:1 blue:1 alpha:1]; CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 //以10为半径围绕圆心画指定角度扇形 CGContextMoveToPoint(context, 160, 180); CGContextAddArc(context, 160, 180, 30, -60 * PI / 180, -120 * PI / 180, 1); CGContextClosePath(context); CGContextDrawPath(context, kCGPathFillStroke); //绘制路径 //画椭圆 CGContextAddEllipseInRect(context, CGRectMake(160, 180, 20, 8)); //椭圆 CGContextDrawPath(context, kCGPathFillStroke); /*画三角形*/ //只要三个点就行跟画一条线方式一样，把三点连接起来 CGPoint sPoints[3];//坐标点 sPoints[0] =CGPointMake(100, 220);//坐标1 sPoints[1] =CGPointMake(130, 220);//坐标2 sPoints[2] =CGPointMake(130, 160);//坐标3 CGContextAddLines(context, sPoints, 3);//添加线 CGContextClosePath(context);//封起来 CGContextDrawPath(context, kCGPathFillStroke); //根据坐标绘制路径 /*画圆角矩形*/ float fw = 180; float fh = 280; CGContextMoveToPoint(context, fw, fh-20); // 开始坐标右边开始 CGContextAddArcToPoint(context, fw, fh, fw-20, fh, 10); // 右下角角度 CGContextAddArcToPoint(context, 120, fh, 120, fh-20, 10); // 左下角角度 CGContextAddArcToPoint(context, 120, 250, fw-20, 250, 10); // 左上角 CGContextAddArcToPoint(context, fw, 250, fw, fh-20, 10); // 右上角 CGContextClosePath(context); CGContextDrawPath(context, kCGPathFillStroke); //根据坐标绘制路径 /*画贝塞尔曲线*/ //二次曲线 CGContextMoveToPoint(context, 120, 300);//设置Path的起点 CGContextAddQuadCurveToPoint(context,190, 310, 120, 390);//设置贝塞尔曲线的控制点坐标和终点坐标 CGContextStrokePath(context); //三次曲线函数 CGContextMoveToPoint(context, 200, 300);//设置Path的起点 CGContextAddCurveToPoint(context,250, 280, 250, 400, 280, 300);//设置贝塞尔曲线的控制点坐标和控制点坐标终点坐标 CGContextStrokePath(context); /*图片*/ UIImage *image = [UIImage imageNamed:@"apple.jpg"]; [image drawInRect:CGRectMake(60, 340, 20, 20)];//在坐标中画出图片 // [image drawAtPoint:CGPointMake(100, 340)];//保持图片大小在point点开始画图片，可以把注释去掉看看 CGContextDrawImage(context, CGRectMake(100, 340, 20, 20), image.CGImage);//使用这个使图片上下颠倒了，参考http://blog.csdn.net/koupoo/article/details/8670024 // CGContextDrawTiledImage(context, CGRectMake(0, 0, 20, 20), image.CGImage);//平铺图 &#125; @end 用法： 12CustomView *customView = [[CustomView alloc]initWithFrame:CGRectMake(0, 0, 320, self.view.frame.size.height)]; [self.view addSubview:customView]; ok，完成。大家如果看过我的其它博客，会发现，这遍博客跟我的某一片博客很像，没错，就是http://blog.csdn.net/rhljiayou/article/details/7212620当年写andriod的时候写的一遍博客。请大家尊重一下我的劳动成功，转载请注明原创地址！http://blog.csdn.net/rhljiayou/article/details/9919713]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]AFNetworking、ASIHTTPRequest中SSL的使用]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F05%2F20%2F16.5.20_AFNetworking%E3%80%81ASIHTTPRequest%E4%B8%ADSSL%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原文：https://www.caijixia.net/jianzhanjingyan/2014080371676.html 首先介绍下AFNetworking中的使用：2.0要注意个地方：IOS7及其以后，采用AFHTTPSessionManager，IOS7之前采用AFHTTPRequestOperationManager。以AFHTTPSessionManager为例，代码如下：1AFHTTPSessionManager *httpClient = [AFHTTPSessionManager manager]; httpClient.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient.responseSerializer = [AFHTTPResponseSerializer serializer]; // SSL Pinning NSString *certificatePath = [[NSBundle mainBundle] pathForResource:@certificate ofType:@der]; NSData *certificateData = [NSData dataWithContentsOfFile:certificatePath]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:YES]; [securityPolicy setPinnedCertificates:@[certificateData]]; [securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate]; [httpClient setSecurityPolicy:securityPolicy]; [httpClient GET:@http://xxxx parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; //失败信息 &#125;]; 以AFHTTPRequestOperationManager为例，站群，代码如下： 12345678AFHTTPRequestOperationManager *httpClient1 = [AFHTTPRequestOperationManager manager]; httpClient1.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient1.responseSerializer = [AFHTTPResponseSerializer serializer]; // SSL Pinning NSString *certificatePath1 = [[NSBundle mainBundle] pathForResource:@certificate ofType:@der]; NSData *certificateData1 = [NSData dataWithContentsOfFile:certificatePath1]; AFSecurityPolicy *securityPolicy1 = [[AFSecurityPolicy alloc] init]; [securityPolicy1 setAllowInvalidCertificates:YES]; [securityPolicy1 setPinnedCertificates:@[certificateData1]]; [securityPolicy1 setSSLPinningMode:AFSSLPinningModeCertificate]; [httpClient setSecurityPolicy:securityPolicy1];[httpClient1 GET:@http://xxxx parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //成功信息 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //失败信息 &#125;]; 下面来讲下ASI，以ASIFormDataRequest为例，代码如下： 123456ASIFormDataRequest * request; request = [ASIFormDataRequest requestWithURL:[NSURL URLWithString:@]]; NSData *cerFile = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@d1 ofType:@cer]]; SecCertificateRef cert = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)cerFile); NSArray *array = [NSArray arrayWithObjects:(__bridge id)cert,nil];[request setClientCertificates:array]; [request setValidatesSecureCertificate:NO]; [request startSynchronous]; ASIHTTPRequest的参考http://www.tuicool.com/articles/UN3AveR，代码就不贴了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]让你快速上手Runtime]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F03%2F08%2F16.03.08_%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRuntime%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/e071206103a4 前言本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:袁峥Seemygo,也可以来小码哥，了解下我们的iOS培训课程。后续还会更新更多内容。。。 一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import 消息机制简单使用 123456789101112131415161718 // 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 交换原理： 交换之前： * 交换之后： 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name);&#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243 @implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM);&#125;@end 字典转模型的方式一：KVC 12345678910111213@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS开发之AFNetworking 3.0.4使用]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F02%2F05%2F16.2.9_iOS%E5%BC%80%E5%8F%91%E4%B9%8BAFNetworking3.0.4%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/11bb0d4dc649 前言昨天使用Cocoapods导入AFN做POST的时候，导入的最新版的3.0.4,突然发现找不到AFHTTPRequestOperationManager了。。。上github上一看，发现没有这个了。刚开始以为是cocoapods没有给我导进去，因为是小demo，就想自己写一个网络请求的，发现也没有这NSURLConnection了，被弃用了，突然意识到，这个就是AFHTTPRequestOperationManager找不到的原因了，它是基于NSURLConnection封装的！！于是找了一下，现在都用的是NSURLSession了，AFN中用的是AFHTTPSessionManager了~~ 特地记录下来，以便遇到这个的朋友们看看！ ps:如果想用以前的话，cocoapods 就不要用最新的版本了，2.6的上面有。 GET请求12345678910111213141516AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager GET:URL parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@"这里打印请求成功要做的事"); &#125;failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@"%@",error); //这里打印错误信息&#125;]; POST 请求1234567891011121314AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];NSMutableDictionary *parameters = @&#123;@"":@"",@"":@""&#125;;[manager POST:URL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;&#125;]; 暂时用的比较多的就这两个，用到其他的 再来更新！！ 最近又用到了下载，索性 上传下载都研究了一下 ，补充进来 补充试用AFN3.0下载方法123456789101112131415161718192021222324252627282930313233343536373839/*** AFN3.0 下载*/- (void)downLoad&#123;//1.创建管理者对象AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];//2.确定请求的URL地址NSURL *url = [NSURL URLWithString:@""];//3.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];//下载任务NSURLSessionDownloadTask *task = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;//打印下下载进度WKNSLog(@"%lf",1.0 * downloadProgress.completedUnitCount / downloadProgress.totalUnitCount);&#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;//下载地址WKNSLog(@"默认下载地址:%@",targetPath);//设置下载路径，通过沙盒获取缓存地址，最后返回NSURL对象NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject];return [NSURL fileURLWithPath:filePath];&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;//下载完成调用的方法WKNSLog(@"下载完成：");WKNSLog(@"%@--%@",response,filePath);&#125;];//开始启动任务[task resume];&#125; AFN3.0 上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*** AFN 3.0 上传* 有两种方式* upLoad1 和 upLoad2*///第一种方法是通过工程中的文件进行上传- (void)upLoad1&#123;//1。创建管理者对象AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];//2.上传文件NSDictionary *dict = @&#123;@"username":@"1234"&#125;;NSString *urlString = @"22222";[manager POST:urlString parameters:dict constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;//上传文件参数UIImage *iamge = [UIImage imageNamed:@"123.png"];NSData *data = UIImagePNGRepresentation(iamge);//这个就是参数[formData appendPartWithFileData:data name:@"file" fileName:@"123.png" mimeType:@"image/png"];&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;//打印下上传进度WKNSLog(@"%lf",1.0 *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount);&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;//请求成功WKNSLog(@"请求成功：%@",responseObject);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;//请求失败WKNSLog(@"请求失败：%@",error);&#125;];&#125;//第二种是通过URL来获取路径，进入沙盒或者系统相册等等- (void)upLoda2&#123;//1.创建管理者对象AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];//2.上传文件NSDictionary *dict = @&#123;@"username":@"1234"&#125;;NSString *urlString = @"22222";[manager POST:urlString parameters:dict constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;[formData appendPartWithFileURL:[NSURL fileURLWithPath:@"文件地址"] name:@"file" fileName:@"1234.png" mimeType:@"application/octet-stream" error:nil];&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;//打印下上传进度WKNSLog(@"%lf",1.0 *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount);&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;//请求成功WKNSLog(@"请求成功：%@",responseObject);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;//请求失败WKNSLog(@"请求失败：%@",error);&#125;];&#125; 监测当前网络状态（网络监听）12345678910111213141516171819202122232425262728293031323334353637383940- (void)AFNetworkStatus&#123;//1.创建网络监测者AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];/*枚举里面四个状态 分别对应 未知 无网络 数据 WiFitypedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;AFNetworkReachabilityStatusUnknown = -1, 未知AFNetworkReachabilityStatusNotReachable = 0, 无网络AFNetworkReachabilityStatusReachableViaWWAN = 1, 蜂窝数据网络AFNetworkReachabilityStatusReachableViaWiFi = 2, WiFi&#125;;*/[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;//这里是监测到网络改变的block 可以写成switch方便//在里面可以随便写事件switch (status) &#123;case AFNetworkReachabilityStatusUnknown:WKNSLog(@"未知网络状态");break;case AFNetworkReachabilityStatusNotReachable:WKNSLog(@"无网络");break;case AFNetworkReachabilityStatusReachableViaWWAN:WKNSLog(@"蜂窝数据网");break;case AFNetworkReachabilityStatusReachableViaWiFi:WKNSLog(@"WiFi网络");break;default:break;&#125;&#125;] ;&#125; 有知道新版本用法的各位大神请不吝赐教，小白再次拜谢了！！ 在使用的过程中遇到了一些问题的 总结，在这里，有需要的亲们可以去看一下，就不往这里放了，占地方。。。。 多谢各位道友的指正，在下载里面那个地方return [NSURL fileURLWithPath:filePath]; 已经改过来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]Convert to Objective-C ARC]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F12%2F11%2F15.12.11_Convert_to_Objective-C_ARC%2F</url>
      <content type="text"><![CDATA[原文：http://www.cnblogs.com/tracy-e/p/3151459.html 今天在进行代码走查时，竟然发现了下面这段代码： Bad Code 顿时感觉吐槽无力，虽然我反复强调内存管理问题，无非就是谁申请谁释放，利用强弱引用避免 retain-cycles，但是还是会有这样那样的问题，leaks 每次就是一片红。本来是计划等他们交易都开发完了，进行一次集体代码走查，好好给他们上一课，集中来解决内存问题。但是由于个人原因我 7 月份会离开项目组，恐怕没有时间来这么做了，所以最终还是决定将工程转成 ARC 模式。 该项目是某行手机银行客户端，iOS 开发这块除了我，其他的所有 7 个开发人员都是项目组临时招聘的，技术参差不齐，毕竟公司招聘标准就是：便宜 + 能干事。我的职责就是负责客户端架构，公共机制的设计与实现，公共组件的封装，开发过程中的解疑。其他开发人员每人负责一两个模块的交易开发，其实无非就剩下请求数据绘界面的事了。 其实项目开始时就打算尝试用 ARC 的，但是项目组内其他人员之前都没接触过 ARC，迫于项目进度压力也没有时间做培训，就使用大家比较熟悉的 MRR，还是太信任他们了。 Convertion Steps 1.将不要转成 ARC 的代码标注一下 如开源代码 AFNetworking(因为项目需要支持 4.3，所以用的 AFNetworking 是支持 4.3 的非 ARC 版本)、GDataXML、RegexKitLite、Reachability 等，其实这些也能转，但是感觉没有必要，将这些源文件在 Build Phases / Complie Sources 中标注为-fno-objc-arc，如果之前用到了使用 ARC 的代码，现在可以将-fobjc-arc标记去掉了。 setp1 2.工程检查 我选择使用 Xcode5.0_DP 版本来转，之前使用 Xcode4.6 在转换过程中电脑经常会假死，或者 Xcode4.6 直接崩溃，不知道什么原因。而 Xcode5.0 默认就是 ARC 模式，我想为了能让之前的程序都转换为 ARC，它的转换工具一定比之前强化了不少。 Xcode -&gt; Edit -&gt; Refactor -&gt; Convert to Objective-C ARC&hellip; 选择要转换的 Target，工程 target，如果有单元测试也会出现单元测试的 target，点击&ldquo;Check&rdquo;。 3.解决 ARC 不允许的问题 setp3 转换工具会自动将代码里面的 retain、release、autorelease 等操作去掉，属性中的 retain、copy、assign 转为为对应的关键字（retain、copy -&gt; strong, assign 会根据工程是否支持 5.0 一下版本转出 weak，或 unsafe_unretained）。 但是如果你在宏里面定义如： #define MB_RELEASE_SAFELY(POINTER) { [POINTER release]; __POINTER = nil; } 转换工具是不会自动处理里面的 release 的，需要手动将[__POINTER release];去掉。（我工程里面 4201 个问题基本上都是因为这个导致的） 此外在 CF 对象与 NS 对象之间转换的需要加上关键字__bridge，这个也需要手动来来修改。 4.开始转换 setp4 解决完所有的冲突，再次选择&ldquo;Convert to Objective-C ARC&hellip;&rdquo;，你就能看到这个界面，点击&ldquo;Next&rdquo;后，再次经过漫长的等待， 工具会列出了将会为了转换的代码的对照列表。默认所有出现在列表里面的文件都是选中的，你可以选在不要转换的文件，去掉对勾。确认完后，点击&ldquo;Save&rdquo;就完成了整个工程的转换工作, Congratulations! (我在完成后编译时，发现之前被我标为-fno-objc-arc的文件会有报错，原来在转换过程中工具将之前的标记都去掉了，无奈再次标记了一遍。) 5.其他处理 因为我们工程支持 4.3，所以 weak, __weak 关键字不能用， 可以通过宏定义将 5.0 以下时 weak 关键字定义为 unsafe_unretained: #if (!has_feature(objc_arc)) || \(defined IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; \IPHONE_OS_VERSION_MIN_REQUIRED &lt; IPHONE_5_0) || \(defined MAC_OS_X_VERSION_MIN_REQUIRED &amp;&amp; \ MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_10_7)#undef weak#define weak unsafe_unretained#undef weak#define weak unsafe_unretained#endif 在 ARC 模式下，使用 performSelector 方法会有编译警告：PerformSelector may cause a leak because its selector is unknown，作为有洁癖的程序员是不能容许程序中有警告的： #progma clang diagnostic push#progma clang disgnostic ignored “-Warc-performSelecotr-leaks”[self performSelector:@selector(mySelector:) withObject:object];#progma clang disgnostic pop Posted by&nbsp;XiaoYi_HD&nbsp;- 6月 19 2013如需转载，请注明： 本文来自&nbsp;Esoft Mobile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]AFNetworking 3.0迁移指南]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F12%2F09%2F15.12.09_AFNetworking%203.0%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/047463a7ce9b AFNetworking 3.0 AFNetworking是一款在OS X和iOS下都令人喜爱的网络库。为了迎合iOS新版本的升级, AFNetworking在3.0版本中删除了基于 NSURLConnection API的所有支持。如果你的项目以前使用过这些API，建议您立即升级到基于 NSURLSession 的API的AFNetworking的版本。本指南将引导您完成这个过程。 本指南是为了引导使用AFNetworking 2.x升级到最新的版本API，以达到过渡的目的，并且解释了新增和更改的设计结构。 新设备要求: iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7AFNetworking 3.0正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。如果你想使用AFNetworking在针对较旧版本的SDK项目，请检查README的兼容性信息。 NSURLConnection的API已废弃AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。 AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。 弃用的类下面的类已从AFNetworking 3.0中废弃： AFURLConnectionOperation AFHTTPRequestOperation AFHTTPRequestOperationManager 修改的类下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构: UIImageView+AFNetworking UIWebView+AFNetworking UIButton+AFNetworking 迁移 AFHTTPRequestOperationManager 核心代码如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化： securityPolicy requestSerializer responseSerializer 接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。 AFNetworking 2.x123456AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];[manager GET:@"请求的url" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@"成功");&#125; failure:^(AFHTTPRequestOperation *operation, NSError*error) &#123; NSLog(@"失败");&#125;]; AFNetworking 3.0123456AFHTTPSessionManager *session = [AFHTTPSessionManager manager];[session GET:@"请求的url" parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"成功");&#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"失败"); &#125;]; AFHTTPRequestOperation 核心代码与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。 在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。 接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。 AFNetworking 2.x12345678910NSURL *URL = [NSURL URLWithString:@""];NSURLRequest *request = [NSURLRequest requestWithURL:URL];AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];op.responseSerializer = [AFJSONResponseSerializer serializer];[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@"JSON: %@", responseObject);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@"Error: %@", error);&#125;];[[NSOperationQueue mainQueue] addOperation:op]; AFNetworking 3.01234567NSURL *URL = [NSURL URLWithString:@""];AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager GET:URL.absoluteString parameters:nil success:^(NSURLSessionTask *task, id responseObject) &#123; NSLog(@"JSON: %@", responseObject);&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123; NSLog(@"Error: %@", error);&#125;]; UIKit的迁移图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。 UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。 UIAlertView的类目被废弃从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。 原文链接: AFNetworking 3.0纯属个人翻译，如有错误，还请纠正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]使用AFNetworking, SDWebimage和OHHTTPStubs]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F11%2F20%2F15.11.20_%E4%BD%BF%E7%94%A8AFNetworking%2C%20SDWebimage%E5%92%8COHHTTPStubs%2F</url>
      <content type="text"><![CDATA[原文：http://blog.shiqichan.com/using-afnetworking-sdwebimage-and-ohhttpstubs/ 写了个示例，放在GitHub上。 这是运行的动画：以下内容主要介绍： 基于AFNetworking的HTTP操作，GET获取网页和JSON数据，上传文件，下载文件，以及加载图片 基于SDWebimage的加载图片 基于OHHTTPStubs的伪造网络响应用于测试（stub），而且可以模拟出网络的延时 使用基于NSURLSession的AFNetworking APIAFNetworking有2套用于网络操作的API： 基于NSURLConnection 基于NSURLSession 后者是新的API，用于iOS 7 / Mac OS X 10.9及以上版本。 这篇文章写的很好：从 NSURLConnection 到 NSURLSession，说明后者做了哪些改善和加强。 现在越来越多的iOS项目最低要求iOS 7，让我们可以开始尝试使用这种新的方式。 GET请求，获取普通网页文本AFHTTPSessionManager是使用NSURLSession的API。 12345678910111213141516171819NSURL baseURL = [NSURL URLWithString:@”http://localhost/“]; //设置和加入头信息NSURLSessionConfiguration config = [NSURLSessionConfiguration defaultSessionConfiguration];[config setHTTPAdditionalHeaders:@&#123; @”User-Agent” : @”My Browser”&#125;];AFHTTPSessionManager manager=[[AFHTTPSessionManager alloc] initWithBaseURL:baseURL sessionConfiguration:config];manager.responseSerializer = [AFHTTPResponseSerializer serializer];manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@”text/html”];//设置GET请求的参数NSDictionary params=[[NSDictionary alloc] initWithObjectsAndKeys:@”3”,@”id”,nil];//发起GET请求[manager GET:@”” parameters:params success:^(NSURLSessionDataTask task, id responseObject) &#123; NSLog(@”HTML: %@”, [[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125; failure:^(NSURLSessionDataTask task, NSError *error) &#123; NSLog(@”visit error: %@”,error);&#125;]; 为了方便测试，这个示例里写了个简单的Web Server，httpServer.js。 运行httpServer.js，需要安装node.js环境。然后： &lt;span class=&quot;title&quot;&gt;sudo&lt;/span&gt; node httpServer 我使用了80端口，在Mac环境下是需要root权限的。 GET请求，获取JSON数据方法和GET请求网页文本大同小异，个别参数或者设置对象上有不同： 12345678910111213NSURL baseURL = [NSURL URLWithString:@”http://localhost/“];NSURLSessionConfiguration config = [NSURLSessionConfiguration defaultSessionConfiguration];[config setHTTPAdditionalHeaders:@&#123; @”User-Agent” : @”My Browser”&#125;];AFHTTPSessionManager manager=[[AFHTTPSessionManager alloc] initWithBaseURL:baseURL sessionConfiguration:config];NSDictionary params=[[NSDictionary alloc] initWithObjectsAndKeys:@”8”,@”id”,nil];[manager GET:@”/json” parameters:params success:^(NSURLSessionDataTask task, id responseObject) &#123; NSDictionary object=(NSDictionary )responseObject; NSLog(@”response message: %@”,object[@”message”]);&#125; failure:^(NSURLSessionDataTask task, NSError *error) &#123; NSLog(@”visit error: %@”,error);&#125;]; 下载文件AFNetworking API会返回NSURLSessionDownloadTask，可用于网络请求的取消、暂停和恢复。 其实上文中的GET方法也返回了这个对象，只不过下载文件时间可能会较长，有可能有这方面的需求。 1234567891011121314NSURLSessionConfiguration configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL URL = [NSURL URLWithString:@”http://www.baidu.com/img/bdlogo.png“];NSURLRequest request = [NSURLRequest requestWithURL:URL];NSURLSessionDownloadTask downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL (NSURL targetPath, NSURLResponse response) &#123; NSURL documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];&#125; completionHandler:^(NSURLResponse response, NSURL filePath, NSError error) &#123; NSLog(@”File downloaded to: %@”, filePath); uploadFilePath=filePath;&#125;];[downloadTask resume]; 使用AFNetworking加载图片需要引入一下： 1#import &lt;UIImageView+AFNetworking.h&gt; 然后，UIImageView就会有setImageWithURL供使用。 12NSURL *URL = [NSURL URLWithString:@”http://www.baidu.com/img/bdlogo.png“];[imageView setImageWithURL:URL]; 另外，提供了其他方法，可设置占位图片，图片下载成功和失败的处理，以及停止图片下载的方法。 1234– setImageWithURL:– setImageWithURL:placeholderImage:– setImageWithURLRequest:placeholderImage:success:failure:– cancelImageRequestOperation 使用SDWebimage加载图片SDWebImage，调用方式和AFNetworking类似，功能更强大，使用也很普及。 需要引入： 1#import &lt;SDWebImage/UIImageView+WebCache.h&gt; 代码： 12NSURL *URL = [NSURL URLWithString:@”http://www.sogou.com/images/logo/new/sogou.png“];[imageView sd_setImageWithURL:URL]; 下面是完整的方法列表： 123456789101112– sd_imageURL– sd_setImageWithURL:– sd_setImageWithURL:placeholderImage:– sd_setImageWithURL:placeholderImage:options:– sd_setImageWithURL:completed:– sd_setImageWithURL:placeholderImage:completed:– sd_setImageWithURL:placeholderImage:options:completed:– sd_setImageWithURL:placeholderImage:options:progress:completed:– sd_setImageWithPreviousCachedImageWithURL:andPlaceholderImage:options:progress:completed:– sd_setAnimationImagesWithURLs:– sd_cancelCurrentImageLoad– sd_cancelCurrentAnimationImagesLoad 比AFNetworking选项更多一些，比如可以设置SDWebImageOptions： 12345678910typedef NS_OPTIONS(NSUInteger, SDWebImageOptions ) &#123; SDWebImageRetryFailed = 1 &lt; &lt; 0, SDWebImageLowPriority = 1 &lt; &lt; 1, SDWebImageCacheMemoryOnly = 1 &lt; &lt; 2, SDWebImageProgressiveDownload = 1 &lt; &lt; 3, SDWebImageRefreshCached = 1 &lt; &lt; 4, SDWebImageContinueInBackground = 1 &lt; &lt; 5, SDWebImageHandleCookies = 1 &lt; &lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt; &lt; 7,&#125;; 还有：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize) 可以用一组图片生成动画：sd_setAnimationImagesWithURLs 使用之前的Cache先显示图片？sd_setImageWithPreviousCachedImageWithURL，这个我从字面意思理解，还没有使用 有个process block，sd_setImageWithURL:placeholderImage:options:progress:completed:，可以获得receivedSize和expectedSize字节参数，用来显示进程百分比 另外，iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)，这篇文章测试和对比，结论也是SDWebimage更好一些。 AFNetworking上传文件12345678910111213141516NSMutableURLRequest request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@”POST” URLString:@”http://localhost/upload“ parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123; [formData appendPartWithFileURL:uploadFilePath name:@”file” fileName:@”filename.jpg” mimeType:@”image/jpeg” error:nil];&#125; error:nil];AFURLSessionManager manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSProgress progress = nil;NSURLSessionUploadTask uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse response, id responseObject, NSError error) &#123; if (error) &#123; NSLog(@”Error: %@”, error); &#125; else &#123; NSLog(@”%@ %@”, response, responseObject); &#125;&#125;];[uploadTask resume]; 可以通过NSProgress获取上传进度（具体怎么做呢？） 使用OHHTTPStubs伪造HTTP响应OHHTTPStubs，可用来伪造HTTP响应，这样不依赖服务器端，iOS的开发人员就可以测试网络服务了。 这个API，同时支持： NSURLConnection NSURLSession 不过，有个问题需要注意，如果App要上AppStore，是不能连接OHHTTPStubs的。 下面说下怎么使用，先看代码： 123456789101112131415NSString baseUrl=@”http://localhost“;//针对http://locahost/json请求的mock[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) &#123; NSDictionary params=[NSDictionary objectsFromURLQueryString:request.URL.query]; NSLog(@”id: %@”,params[@”id”]); return [[request.URL absoluteString] rangeOfString:[NSString stringWithFormat:@”%@/json”,baseUrl]].location==0;&#125; withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) &#123; NSLog(@”reqeust: %@”,request); NSString fixture = OHPathForFileInBundle(@”test.json”,nil); return [[OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@&#123;@”Content-Type”:@”text/json”&#125; ]requestTime:0 responseTime:0];&#125;]; 基本思路是，调用方法，通过2个回调（Block）实现对指定HTTP请求的响应伪造： 是否是要拦截的请求 拦截后，创建一个响应 在上述代码里还演示了： 如何从URL中提取GET请求的参数，这里用到了：URLQueryToCocoa 使用本地文件作为JSON数据，加入到HTTP响应中 可以设置请求和响应的延时，requestTime:0 responseTime:0，这个相当有用 ## 还可以用于伪造图片的响应，测试了一下，上述的AFNetworking以及SDWebimage都有效。 12345678910//GET image with sdwebimage[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) &#123; return [[request.URL absoluteString] isEqualToString:@”http://www.sogou.com/images/logo/new/sogou.png“];&#125; withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) &#123; NSLog(@”reqeust: %@”,request); NSString fixture = OHPathForFileInBundle(@”taobao.png”,nil); return [[OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@&#123;@”Content-Type”:@”image/png”&#125; ]requestTime:0 responseTime:0];&#125;]; 测试的时候，要注意，之前可能是通过真实网络获取的，因此会有缓存。需要把App删除，重新安装测试。 应该能看到类似下面的效果（使用的时本地图片了）： ## OHHTTPStubs这些代码，只需在App启动加载一次即可，可写在AppDelegate中： 123456789101112131415- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions &#123; [[AFNetworkReachabilityManager sharedManager] startMonitoring]; [HttpMock initMock];1234567891011121314151617181920212223242526272829303132&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;代码屏蔽掉，自然就使用真实网络了。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;编译正式使用代码的时候，可以考虑条件编译。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;## &lt;span class=&quot;tag&quot;&gt;AFNetworking&lt;/span&gt;的网络监控&lt;span class=&quot;tag&quot;&gt;API&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;提供的`&lt;span class=&quot;tag&quot;&gt;AFNetworkReachabilityManager&lt;/span&gt;`可以单独使用，很方便，用于监控网络变化。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;比如，可以在&lt;span class=&quot;tag&quot;&gt;App&lt;/span&gt;启动后执行下面操作，启动监控器：&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;* (BOOL)application:(UIApplication _)application didFinishLaunchingWithOptions:(NSDictionary _)launchOptions &#123; [[AFNetworkReachabilityManager sharedManager] startMonitoring];&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;header&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;在ViewController中：&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;-(void)viewDidLoad&#123; [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@”Reachability: %@”, AFStringFromNetworkReachabilityStatus(status)); &#125;];&#125; 监听网络变化，做出相应的操作，比如弹出提示框。 ## 正式使用时： 可考虑在AppDelegate中setReachabilityStatusChangeBlock，当状态变化后，通过NSNotification发出通知 在各个ViewController的viewDidAppear和viewWillDisappear中监听和取消监听通知 这是设想，还没有付诸实施，也许还有问题。 不过至少不应该像本例中的，在ViewController中使用setReachabilityStatusChangeBlock。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇文章]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F11%2F12%2F15.11.12_%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[NSLog(@&quot;Hello World&quot;); 捣腾了两天的终于出炉了，一路走来坑坑洼洼，实属不易！此时的心情犹如刚学OC时，控制台打印出“Hello World”一般。 后期会将珍藏已久的好文章陆续放上去，文章主要以技术分享为主，但时而也会有一些自己的小心情、小想法之类的！恭请敬阅。 由于刚开始弄所以排版和功能肯定有不足之处，欢迎批评指正。]]></content>
    </entry>

    
  
  
</search>
