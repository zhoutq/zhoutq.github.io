<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[[转]教你搭建App内测下载平台]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F08%2F10%2F%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAApp%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[转自简书作者:zhao0 前言App开发测试过程中，我们会把安装包传到各种第三方的内测分发平台方便下载。这些平台或多或少有这样那样的限制，比如下载量啊、付费啊、不能方便找到历史版本啊。还有一方面，我们经常会打Debug版本的包方便调试，又不希望Debug包流传到外部去，这样就很有必要自己搭一个下载平台，于是就有了这个项目(github地址)。 技术调研怎么下载先说安卓，apk文件通过最简单的http/ftp下载就可以安装了，略过。iOS稍微复杂一点，需要两步才能完成。第一，下载链接必须是这样的格式 itms-services://?action=download-manifest&amp;url=一个plist文件的地址` 第二，plist内容如下 `&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;ipa文件的地址&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;bundleID&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;AppTitle&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt;` 其中，最重要的就是ipa文件的地址，要求必须是https协议，那就需要SSL证书，幸运的是我们可以信任自签名的证书。下载的过程就是这样，当然我们希望这个链接和plist的生成是自动完成的。 自签名证书参考如何创建一个自签名的SSL证书(X509) 包信息提取单单只能下载还不够，我们希望看到更多的信息：App名字、版本号、build号、更新时间、图标等。这些信息虽然可以留给上传者在上传的时候一并带上，但是作为有追求的程序员，把方便留给别人的最基本的，因此我们要从ipa/apk中提取这些信息。无论是ipa还是apk，本质都是zip压缩文件。对于iOS的ipa，包信息都放在Info.plist中，主要有CFBundleVersion、CFBundleIdentifier、CFBundleShortVersionString、CFBundleName等。图标文件的名字也是固定的，只要解压就可以得到。不过，苹果对png图片进行了了自定义的pngcrush压缩，有压缩自然就有还原工具pngdefry。对于Android的apk，解压后还能看到AndroidManifest.xml，但是里面的内容经过编码显示为乱码，不方便查看，需要借助开发工具aapt(Android Asset Packaging Tool)，方法如下aapt dump badging apkPath输出的文本格式如下，不是标准的歌声，需要手动转换一下。 `package: name='com.jianshu.haruki' versionCode='16070101' versionName='1.11.2' sdkVersion:'14' targetSdkVersion:'22' ... application: label='简书' icon='res/drawable-hdpi-v4/icon_jianshu_new.png' ...` 找轮子程序员有一个习惯，需要某个东西的时候会先一番搜索，直接用别人写好的，用着用着发现别人写的东西有这样那样的不足，然后撸起袖子自己造一个。这次也不例外，我在github上找到了一个ios-ipa-server，它的特点是简单，ipa文件存储在一个目录下，没有数据库，包信息只有上传时间(其实就是文件更新时间)，不能对app归类，只靠文件名区别，不支持上传，如下图： 浏览器访问下载页面时，后端实时解析包信息、解压icon图片，这样做效率是非常低的。这么多不足我们就有了造轮子的理由了。 自己造一个既然ios-ipa-server是基于node-express写的，正好我没写过nodejs，那就在它的基础上继续写吧，借机学(zhuang)习(bi)一下。整个项目的结构是这样的，提供四个API：包上传、获取所有App最新版本、获取某个App的所有版本、动态生成plist文件，数据存储使用sqlite3。 包上传接口设计如下： `path: POST /upload param: package:安装包文件 response: { id: 6, guid: "46269d71-9fda-76fc-3442-a118d6b08bf1", bundleID: "com.jianshu.Hugo", version: "2.11.4", build: "1608051045", icon: "https://10.20.30.233:1234/icon/46269d71-9fda-76fc-3442-a118d6b08bf1.png", name: "Hugo", uploadTime: "2016-12-01 20:50:05", platform: "ios", url: "itms-services://?action=download-manifest&amp;url=https://10.20.30.233:1234/plist/46269d71-9fda-76fc-3442-a118d6b08bf1" }` 后端需要拿到安装包，提取出包信息和png图标图片，然后插入到数据库中，最后存储安装包文件和png图片，这也是最关键、最复杂的一个API。 ` app.post('/upload', function(req, res) { var form = new multiparty.Form(); form.parse(req, function(err, fields, files) { var obj = files.package[0]; var tmp_path = obj.path; parseAppAndInsertToDb(tmp_path, info =&gt; { storeApp(tmp_path, info["guid"], error =&gt; { if (error) { errorHandler(error,res) } }) console.log(info) res.send(info) }, error =&gt; { errorHandler(error,res) }); }); });` 接收表单信息用到了multiparty模块，parseAppAndInsertToDb内部完成了包信息的提取和存储，storeApp存储包文件。parseAppAndInsertToDb的实现如下， `function parseAppAndInsertToDb(filePath, callback, errorCallback) { var guid = Guid.create().toString(); var parse, extract if (path.extname(filePath) === ".ipa") { parse = parseIpa extract = extractIpaIcon } else if (path.extname(filePath) === ".apk") { parse = parseApk extract = extractApkIcon } Promise.all([parse(filePath),extract(filePath,guid)]).then(values =&gt; { var info = values[0] info["guid"] = guid excuteDB("INSERT INTO info (guid, platform, build, bundleID, version, name) VALUES (?, ?, ?, ?, ?, ?);", [info["guid"], info["platform"], info["build"], info["bundleID"], info["version"], info["name"]],function(error){ if (!error){ callback(info) } else { errorCallback(error) } }); }, reason =&gt; { errorCallback(reason) }) }` 首先根据文件后缀名判断安装包类型，因为ipa和apk的处理逻辑不一样，所以分别对应两个方法，包信息的提取和icon提取可以同时进行，所以这里用了Promise.all。parseIpa和parseApk就是包信息的提取。extractApkIcon和extractIpaIcon则是icon的提取，extractIpaIcon多了一步还原png图片的处理。parseIpa用到了ipa-extract-info模块，parseApk则使用了apk-parser3，代码都非常简单。详细可进入github地址。 其他其他三个API则比较简单了，无非就是根据参数取数据，不再赘述。 集成和使用安装步骤非常简单，首先需要安装node，有了node之后只要一行命令 `npm install -g ipapk-server` 安装完成之后输入命令 `ipapk-server 手机浏览器访问https://ip:port 即可打开下载页面 App的信息获取都设计成了API，提供给开发者更灵活的接入方式，可以做web页面，也可以做成App，我的好朋友mask(人格分裂术)贡献了不少工作，完成默认的web下载页面。更详细的内容请参考github。 写在最后简书作为一个优质原创内容社区，拥有大量优质原创内容，提供了极佳的阅读和书写体验，吸引了大量文字爱好者和程序员。简书技术团队在这里分享技术心得体会，是希望抛砖引玉，吸引更多的程序员大神来简书记录、分享、交流自己的心得体会。这个专题以后会不定期更新简书技术团队的文章，包括Android、iOS、前端、后端等等，欢迎大家关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]让你快速上手Runtime]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F08%2F%E8%BD%AC-%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRuntime%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/e071206103a4 前言本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:袁峥Seemygo,也可以来小码哥，了解下我们的iOS培训课程。后续还会更新更多内容。。。 一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import 消息机制简单使用 123456789101112131415161718 // 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 交换原理： 交换之前： * 交换之后： 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name);&#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243 @implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM);&#125;@end 字典转模型的方式一：KVC 12345678910111213@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇文章]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F08%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[NSLog(@&quot;Hello World&quot;); 捣腾了两天的终于出炉了，一路走来坑坑洼洼，实属不易！此时的心情犹如刚学OC时，控制台打印出“Hello World”一般。 后期会将珍藏已久的好文章陆续放上去，文章主要以技术分享为主，但时而也会有一些自己的小心情、小想法之类的！恭请敬阅。 由于刚开始弄所以排版和功能肯定有不足之处，欢迎批评指正。]]></content>
    </entry>

    
  
  
</search>
