<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[[转]教你搭建App内测下载平台]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F08%2F10%2F%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAApp%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[转自简书作者:zhao0 前言App开发测试过程中，我们会把安装包传到各种第三方的内测分发平台方便下载。这些平台或多或少有这样那样的限制，比如下载量啊、付费啊、不能方便找到历史版本啊。还有一方面，我们经常会打Debug版本的包方便调试，又不希望Debug包流传到外部去，这样就很有必要自己搭一个下载平台，于是就有了这个项目(github地址)。 技术调研怎么下载先说安卓，apk文件通过最简单的http/ftp下载就可以安装了，略过。iOS稍微复杂一点，需要两步才能完成。第一，下载链接必须是这样的格式 1itms-services://?action=download-manifest&amp;amp;url=一个plist文件的地址 第二，plist内容如下12345678910111213141516171819202122232425262728293031&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&amp;lt;plist version="1.0"&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;items&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;assets&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software-package&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;url&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ipa文件的地址&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;key&amp;gt;metadata&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;bundle-identifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;bundleID&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;bundle-version&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;title&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;AppTitle&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/plist&amp;gt; 其中，最重要的就是ipa文件的地址，要求必须是https协议，那就需要SSL证书，幸运的是我们可以信任自签名的证书。下载的过程就是这样，当然我们希望这个链接和plist的生成是自动完成的。 自签名证书参考如何创建一个自签名的SSL证书(X509) 包信息提取单单只能下载还不够，我们希望看到更多的信息：App名字、版本号、build号、更新时间、图标等。这些信息虽然可以留给上传者在上传的时候一并带上，但是作为有追求的程序员，把方便留给别人的最基本的，因此我们要从ipa/apk中提取这些信息。无论是ipa还是apk，本质都是zip压缩文件。对于iOS的ipa，包信息都放在Info.plist中，主要有CFBundleVersion、CFBundleIdentifier、CFBundleShortVersionString、CFBundleName等。图标文件的名字也是固定的，只要解压就可以得到。不过，苹果对png图片进行了了自定义的pngcrush压缩，有压缩自然就有还原工具pngdefry。对于Android的apk，解压后还能看到AndroidManifest.xml，但是里面的内容经过编码显示为乱码，不方便查看，需要借助开发工具aapt(Android Asset Packaging Tool)，方法如下aapt dump badging apkPath输出的文本格式如下，不是标准的歌声，需要手动转换一下。 123456package: name='com.jianshu.haruki' versionCode='16070101' versionName='1.11.2'sdkVersion:'14'targetSdkVersion:'22'...application: label='简书' icon='res/drawable-hdpi-v4/icon_jianshu_new.png'... 找轮子程序员有一个习惯，需要某个东西的时候会先一番搜索，直接用别人写好的，用着用着发现别人写的东西有这样那样的不足，然后撸起袖子自己造一个。这次也不例外，我在github上找到了一个ios-ipa-server，它的特点是简单，ipa文件存储在一个目录下，没有数据库，包信息只有上传时间(其实就是文件更新时间)，不能对app归类，只靠文件名区别，不支持上传，如下图： 浏览器访问下载页面时，后端实时解析包信息、解压icon图片，这样做效率是非常低的。这么多不足我们就有了造轮子的理由了。 自己造一个既然ios-ipa-server是基于node-express写的，正好我没写过nodejs，那就在它的基础上继续写吧，借机学(zhuang)习(bi)一下。整个项目的结构是这样的，提供四个API：包上传、获取所有App最新版本、获取某个App的所有版本、动态生成plist文件，数据存储使用sqlite3。 包上传接口设计如下： 12345678910111213141516171819path:POST /uploadparam: package:安装包文件response:&#123;id: 6,guid: "46269d71-9fda-76fc-3442-a118d6b08bf1",bundleID: "com.jianshu.Hugo",version: "2.11.4",build: "1608051045",icon: "https://10.20.30.233:1234/icon/46269d71-9fda-76fc-3442-a118d6b08bf1.png",name: "Hugo",uploadTime: "2016-12-01 20:50:05",platform: "ios",url: "itms-services://?action=download-manifest&amp;amp;url=https://10.20.30.233:1234/plist/46269d71-9fda-76fc-3442-a118d6b08bf1"&#125; 后端需要拿到安装包，提取出包信息和png图标图片，然后插入到数据库中，最后存储安装包文件和png图片，这也是最关键、最复杂的一个API。 123456789101112131415161718app.post('/upload', function(req, res) &#123;var form = new multiparty.Form();form.parse(req, function(err, fields, files) &#123;var obj = files.package[0];var tmp_path = obj.path;parseAppAndInsertToDb(tmp_path, info =&amp;gt; &#123;storeApp(tmp_path, info["guid"], error =&amp;gt; &#123;if (error) &#123;errorHandler(error,res)&#125;&#125;)console.log(info)res.send(info)&#125;, error =&amp;gt; &#123;errorHandler(error,res)&#125;);&#125;);&#125;); 接收表单信息用到了multiparty模块，parseAppAndInsertToDb内部完成了包信息的提取和存储，storeApp存储包文件。parseAppAndInsertToDb的实现如下， 12345678910111213141516171819202122232425function parseAppAndInsertToDb(filePath, callback, errorCallback) &#123;var guid = Guid.create().toString();var parse, extractif (path.extname(filePath) === ".ipa") &#123;parse = parseIpaextract = extractIpaIcon&#125; else if (path.extname(filePath) === ".apk") &#123;parse = parseApkextract = extractApkIcon&#125;Promise.all([parse(filePath),extract(filePath,guid)]).then(values =&amp;gt; &#123;var info = values[0]info["guid"] = guidexcuteDB("INSERT INTO info (guid, platform, build, bundleID, version, name) VALUES (?, ?, ?, ?, ?, ?);",[info["guid"], info["platform"], info["build"], info["bundleID"], info["version"], info["name"]],function(error)&#123;if (!error)&#123;callback(info)&#125; else &#123;errorCallback(error)&#125;&#125;);&#125;, reason =&amp;gt; &#123;errorCallback(reason)&#125;)&#125; 首先根据文件后缀名判断安装包类型，因为ipa和apk的处理逻辑不一样，所以分别对应两个方法，包信息的提取和icon提取可以同时进行，所以这里用了Promise.all。parseIpa和parseApk就是包信息的提取。extractApkIcon和extractIpaIcon则是icon的提取，extractIpaIcon多了一步还原png图片的处理。parseIpa用到了ipa-extract-info模块，parseApk则使用了apk-parser3，代码都非常简单。详细可进入github地址。 其他其他三个API则比较简单了，无非就是根据参数取数据，不再赘述。 集成和使用安装步骤非常简单，首先需要安装node，有了node之后只要一行命令 1npm install -g ipapk-server 安装完成之后输入命令 1ipapk-server 手机浏览器访问https://ip:port 即可打开下载页面 App的信息获取都设计成了API，提供给开发者更灵活的接入方式，可以做web页面，也可以做成App，我的好朋友mask(人格分裂术)贡献了不少工作，完成默认的web下载页面。更详细的内容请参考github。 写在最后简书作为一个优质原创内容社区，拥有大量优质原创内容，提供了极佳的阅读和书写体验，吸引了大量文字爱好者和程序员。简书技术团队在这里分享技术心得体会，是希望抛砖引玉，吸引更多的程序员大神来简书记录、分享、交流自己的心得体会。这个专题以后会不定期更新简书技术团队的文章，包括Android、iOS、前端、后端等等，欢迎大家关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]简单监测iOS卡顿的demo]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F06%2F21%2F%E7%AE%80%E5%8D%95%E7%9B%91%E6%B5%8BiOS%E5%8D%A1%E9%A1%BF%E7%9A%84demo%2F</url>
      <content type="text"><![CDATA[转自简书作者:game3108 前言本文的demo代码也会更新到github上。 做这个demo思路来源于微信team的：微信iOS卡顿监控系统。主要思路:通过监测Runloop的kCFRunLoopAfterWaiting，用一个子线程去检查，一次循环是否时间太长。其中主要涉及到了runloop的原理。关于整个原理：深入理解RunLoop讲解的比较仔细。以下就是runloop大概的运行方式：123456789101112131415161718192021222324252627282930313233343536373839404142/// 1. 通知Observers，即将进入RunLoop/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);do &#123;/// 2. 通知 Observers: 即将触发 Timer 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 4. 触发 Source0 (非基于port的) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);/// 5. GCD处理main block__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 6. 通知Observers，即将进入休眠/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);/// 7. sleep to wait msg.mach_msg() -&amp;gt; mach_msg_trap();/// 8. 通知Observers，线程被唤醒__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);/// 9. 如果是被Timer唤醒的，回调Timer__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);&#125; while (...);/// 10. 通知Observers，即将退出RunLoop/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 其中UI主要集中在__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);和__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);之前。获取kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting的状态就可以知道是否有卡顿的情况。 NSTimer的实现具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 // MonitorController.h // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface MonitorController : NSObject + (instancetype) sharedInstance; - (void) startMonitor; - (void) endMonitor; - (void) printLogTrace; @end``` ``` objectivec // MonitorController.m // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import "MonitorController.h" #include &amp;lt;libkern/OSAtomic.h&amp;gt; #include &amp;lt;execinfo.h&amp;gt; @interface MonitorController()&#123; CFRunLoopObserverRef _observer; double _lastRecordTime; NSMutableArray *_backtrace; &#125; @end @implementation MonitorController static double _waitStartTime; + (instancetype) sharedInstance&#123; static dispatch_once_t once; static id sharedInstance; dispatch_once(&amp;amp;once, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; - (void) startMonitor&#123; [self addMainThreadObserver]; [self addSecondaryThreadAndObserver]; &#125; - (void) endMonitor&#123; if (!_observer) &#123; return; &#125; CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); CFRelease(_observer); _observer = NULL; &#125; #pragma mark printLogTrace - (void)printLogTrace&#123; NSLog(@"====================堆栈\n %@ \n",_backtrace); &#125; #pragma mark addMainThreadObserver - (void) addMainThreadObserver &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //建立自动释放池 @autoreleasepool &#123; //获得当前thread的Run loop NSRunLoop *myRunLoop = [NSRunLoop currentRunLoop]; //设置Run loop observer的运行环境 CFRunLoopObserverContext context = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;; //创建Run loop observer对象 //第一个参数用于分配observer对象的内存 //第二个参数用以设置observer所要关注的事件，详见回调函数myRunLoopObserver中注释 //第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行 //第四个参数用于设置该observer的优先级 //第五个参数用于设置该observer的回调函数 //第六个参数用于设置该observer的运行环境 _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;amp;myRunLoopObserver, &amp;amp;context); if (_observer) &#123; //将Cocoa的NSRunLoop类型转换成Core Foundation的CFRunLoopRef类型 CFRunLoopRef cfRunLoop = [myRunLoop getCFRunLoop]; //将新建的observer加入到当前thread的run loop CFRunLoopAddObserver(cfRunLoop, _observer, kCFRunLoopDefaultMode); &#125; &#125; &#125;); &#125; void myRunLoopObserver(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; switch (activity) &#123; //The entrance of the run loop, before entering the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopEntry: NSLog(@"run loop entry"); break; //Inside the event processing loop before any timers are processed case kCFRunLoopBeforeTimers: NSLog(@"run loop before timers"); break; //Inside the event processing loop before any sources are processed case kCFRunLoopBeforeSources: NSLog(@"run loop before sources"); break; //Inside the event processing loop before the run loop sleeps, waiting for a source or timer to fire. //This activity does not occur if CFRunLoopRunInMode is called with a timeout of 0 seconds. //It also does not occur in a particular iteration of the event processing loop if a version 0 source fires case kCFRunLoopBeforeWaiting:&#123; _waitStartTime = 0; NSLog(@"run loop before waiting"); break; &#125; //Inside the event processing loop after the run loop wakes up, but before processing the event that woke it up. //This activity occurs only if the run loop did in fact go to sleep during the current loop case kCFRunLoopAfterWaiting:&#123; _waitStartTime = [[NSDate date] timeIntervalSince1970]; NSLog(@"run loop after waiting"); break; &#125; //The exit of the run loop, after exiting the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopExit: NSLog(@"run loop exit"); break; /* A combination of all the preceding stages case kCFRunLoopAllActivities: break; */ default: break; &#125; &#125; #pragma mark addSecondaryThreadAndObserver - (void) addSecondaryThreadAndObserver&#123; NSThread *thread = [self secondaryThread]; [self performSelector:@selector(addSecondaryTimer) onThread:thread withObject:nil waitUntilDone:YES]; &#125; - (NSThread *)secondaryThread &#123; static NSThread *_secondaryThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;amp;oncePredicate, ^&#123; _secondaryThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_secondaryThread start]; &#125;); return _secondaryThread; &#125; - (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"monitorControllerThread"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes]; [runLoop run]; &#125; &#125; - (void) addSecondaryTimer&#123; NSTimer *myTimer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; &#125; - (void)timerFired:(NSTimer *)timer&#123; if ( _waitStartTime &amp;lt; 1 )&#123; return; &#125; double currentTime = [[NSDate date] timeIntervalSince1970]; double timeDiff = currentTime - _waitStartTime; if (timeDiff &amp;gt; 2.0)&#123; if (_lastRecordTime - _waitStartTime &amp;lt; 0.001 &amp;amp;&amp;amp; _lastRecordTime != 0)&#123; NSLog(@"last time no :%f %f",timeDiff, _waitStartTime); return; &#125; [self logStack]; _lastRecordTime = _waitStartTime; &#125; &#125; - (void)logStack&#123; void* callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); int i; _backtrace = [NSMutableArray arrayWithCapacity:frames]; for ( i = 0 ; i &amp;lt; frames ; i++ )&#123; [_backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); &#125; @end 主要内容是首先在主线程注册了runloop observer的回调myRunLoopObserver每次小循环都会记录一下kCFRunLoopAfterWaiting的时间_waitStartTime，并且在kCFRunLoopBeforeWaiting制空。 另外开了一个子线程并开启他的runloop（模仿了AFNetworking的方式），并加上一个timer每隔1秒去进行监测。 如果当前时长与_waitStartTime差距大于2秒，则认为有卡顿情况，并记录了当前堆栈信息。 PS:整个demo写的比较简单，最后获取堆栈也仅获取了当前线程的堆栈信息([NSThread callStackSymbols]有同样效果)，也在寻找获取所有线程堆栈的方法，欢迎指点一下。 更新：了解到 plcrashreporter (github地址) 可以做到获取所有线程堆栈。 更新2:这篇文章也介绍了监测卡顿的方法：检测iOS的APP性能的一些方法通过Dispatch Semaphore保证同步这里记录一下。 写一个Semaphore版本的代码，也放在github上： 12345678910111213141516// SeMonitorController.h// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import &amp;lt;Foundation/Foundation.h&amp;gt;@interface SeMonitorController : NSObject+ (instancetype) sharedInstance;- (void) startMonitor;- (void) endMonitor;- (void) printLogTrace;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// SeMonitorController.m// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import "SeMonitorController.h"#import &amp;lt;libkern/OSAtomic.h&amp;gt;#import &amp;lt;execinfo.h&amp;gt;@interface SeMonitorController()&#123;CFRunLoopObserverRef _observer;dispatch_semaphore_t _semaphore;CFRunLoopActivity _activity;NSInteger _countTime;NSMutableArray *_backtrace;&#125;@end@implementation SeMonitorController+ (instancetype) sharedInstance&#123;static dispatch_once_t once;static id sharedInstance;dispatch_once(&amp;amp;once, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125;- (void) startMonitor&#123;[self registerObserver];&#125;- (void) endMonitor&#123;if (!_observer) &#123;return;&#125;CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);CFRelease(_observer);_observer = NULL;&#125;- (void) printLogTrace&#123;NSLog(@"====================堆栈\n %@ \n",_backtrace);&#125;static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;SeMonitorController *instrance = [SeMonitorController sharedInstance];instrance-&amp;gt;_activity = activity;// 发送信号dispatch_semaphore_t semaphore = instrance-&amp;gt;_semaphore;dispatch_semaphore_signal(semaphore);&#125;- (void)registerObserver&#123;CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;_observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;amp;runLoopObserverCallBack,&amp;amp;context);CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);// 创建信号_semaphore = dispatch_semaphore_create(0);// 在子线程监控时长dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;while (YES)&#123;// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)long st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));if (st != 0)&#123;if (_activity==kCFRunLoopBeforeSources || _activity==kCFRunLoopAfterWaiting)&#123;if (++_countTime &amp;lt; 5)continue;[self logStack];NSLog(@"something lag");&#125;&#125;_countTime = 0;&#125;&#125;);&#125;- (void)logStack&#123;void* callstack[128];int frames = backtrace(callstack, 128);char **strs = backtrace_symbols(callstack, frames);int i;_backtrace = [NSMutableArray arrayWithCapacity:frames];for ( i = 0 ; i &amp;lt; frames ; i++ )&#123;[_backtrace addObject:[NSString stringWithUTF8String:strs[i]]];&#125;free(strs);&#125;@end 用Dispatch Semaphore简化了代码复杂度，更加简洁。 参考资料本文csdn地址1.微信iOS卡顿监控系统2. iphone——使用run loop对象3.深入理解RunLoop4.检测iOS的APP性能的一些方法5.iOS实时卡顿监控]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS开发之AFNetworking 3.0.4使用]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F08%2F16.2.9_iOS%E5%BC%80%E5%8F%91%E4%B9%8BAFNetworking3.0.4%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/11bb0d4dc649 前言本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:袁峥Seemygo,也可以来小码哥，了解下我们的iOS培训课程。后续还会更新更多内容。。。 一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 昨天使用Cocoapods导入AFN做POST的时候，导入的最新版的3.0.4,突然发现找不到AFHTTPRequestOperationManager了。。。上github上一看，发现没有这个了。刚开始以为是cocoapods没有给我导进去，因为是小demo，就想自己写一个网络请求的，发现也没有这NSURLConnection了，被弃用了，突然意识到，这个就是AFHTTPRequestOperationManager找不到的原因了，它是基于NSURLConnection封装的！！于是找了一下，现在都用的是NSURLSession了，AFN中用的是AFHTTPSessionManager了~~特地记录下来，以便遇到这个的朋友们看看！ps:如果想用以前的话，cocoapods 就不要用最新的版本了，2.6的上面有。GET请求 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager GET:URL parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@”这里打印请求成功要做的事”); } failure:^(NSURLSessionDataTask _Nullable task, NSError _Nonnull error) { NSLog(@”%@”,error); //这里打印错误信息 }]; POST 请求 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSMutableDictionary *parameters = @{@””:@””,@””:@””}; [manager POST:URL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask _Nullable task, NSError _Nonnull error) { }]; 暂时用的比较多的就这两个，用到其他的 再来更新！！ 最近又用到了下载，索性 上传下载都研究了一下 ，补充进来 补充试用AFN3.0下载方法 /** AFN3.0 下载*/ (void)downLoad{ //1.创建管理者对象AFHTTPSessionManager manager = [AFHTTPSessionManager manager];//2.确定请求的URL地址NSURL url = [NSURL URLWithString:@””]; //3.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url]; //下载任务NSURLSessionDownloadTask task = [manager downloadTaskWithRequest:request progress:^(NSProgress _Nonnull downloadProgress) { //打印下下载进度 WKNSLog(@&quot;%lf&quot;,1.0 * downloadProgress.completedUnitCount / downloadProgress.totalUnitCount); } destination:^NSURL _Nonnull(NSURL _Nonnull targetPath, NSURLResponse * _Nonnull response) { //下载地址 WKNSLog(@&quot;默认下载地址:%@&quot;,targetPath); //设置下载路径，通过沙盒获取缓存地址，最后返回NSURL对象 NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]; return [NSURL fileURLWithPath:filePath]; } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) { //下载完成调用的方法 WKNSLog(@&quot;下载完成：&quot;); WKNSLog(@&quot;%@--%@&quot;,response,filePath); }]; //开始启动任务 [task resume]; } AFN3.0 上传 /** AFN 3.0 上传 有两种方式 upLoad1 和 upLoad2*/ //第一种方法是通过工程中的文件进行上传 (void)upLoad1{ //1。创建管理者对象 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.上传文件 NSDictionary *dict = @{@”username”:@”1234”}; NSString *urlString = @”22222”; [manager POST:urlString parameters:dict constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { //上传文件参数 UIImage *iamge = [UIImage imageNamed:@&quot;123.png&quot;]; NSData *data = UIImagePNGRepresentation(iamge); //这个就是参数 [formData appendPartWithFileData:data name:@&quot;file&quot; fileName:@&quot;123.png&quot; mimeType:@&quot;image/png&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { //打印下上传进度 WKNSLog(@&quot;%lf&quot;,1.0 *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { //请求成功 WKNSLog(@&quot;请求成功：%@&quot;,responseObject); } failure:^(NSURLSessionDataTask _Nullable task, NSError _Nonnull error) { //请求失败 WKNSLog(@&quot;请求失败：%@&quot;,error); }]; } //第二种是通过URL来获取路径，进入沙盒或者系统相册等等 (void)upLoda2{ //1.创建管理者对象 AFHTTPSessionManager manager = [AFHTTPSessionManager manager]; //2.上传文件 NSDictionary dict = @{@”username”:@”1234”}; NSString *urlString = @”22222”; [manager POST:urlString parameters:dict constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { [formData appendPartWithFileURL:[NSURL fileURLWithPath:@&quot;文件地址&quot;] name:@&quot;file&quot; fileName:@&quot;1234.png&quot; mimeType:@&quot;application/octet-stream&quot; error:nil]; } progress:^(NSProgress * _Nonnull uploadProgress) { //打印下上传进度 WKNSLog(@&quot;%lf&quot;,1.0 *uploadProgress.completedUnitCount / uploadProgress.totalUnitCount); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { //请求成功 WKNSLog(@&quot;请求成功：%@&quot;,responseObject); } failure:^(NSURLSessionDataTask _Nullable task, NSError _Nonnull error) { //请求失败 WKNSLog(@&quot;请求失败：%@&quot;,error); }];}监测当前网络状态（网络监听）- (void)AFNetworkStatus{ //1.创建网络监测者 AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager]; /*枚举里面四个状态 分别对应 未知 无网络 数据 WiFi typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) { AFNetworkReachabilityStatusUnknown = -1, 未知 AFNetworkReachabilityStatusNotReachable = 0, 无网络 AFNetworkReachabilityStatusReachableViaWWAN = 1, 蜂窝数据网络 AFNetworkReachabilityStatusReachableViaWiFi = 2, WiFi }; */ [manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { //这里是监测到网络改变的block 可以写成switch方便 //在里面可以随便写事件 switch (status) { case AFNetworkReachabilityStatusUnknown: WKNSLog(@&quot;未知网络状态&quot;); break; case AFNetworkReachabilityStatusNotReachable: WKNSLog(@&quot;无网络&quot;); break; case AFNetworkReachabilityStatusReachableViaWWAN: WKNSLog(@&quot;蜂窝数据网&quot;); break; case AFNetworkReachabilityStatusReachableViaWiFi: WKNSLog(@&quot;WiFi网络&quot;); break; default: break; } }] ;}有知道新版本用法的各位大神请不吝赐教，小白再次拜谢了！！在使用的过程中遇到了一些问题的 总结，在这里，有需要的亲们可以去看一下，就不往这里放了，占地方。。。。多谢各位道友的指正，在下载里面那个地方return [NSURL fileURLWithPath:filePath]; 已经改过来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F12%2F10%2F16.12.10%20_iOS%20%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F--%E8%A7%A3%E5%AF%86%20MVC%EF%BC%8CMVP%EF%BC%8CMVVM%E4%BB%A5%E5%8F%8AVIPER%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[原文：http://www.cocoachina.com/ios/20160108/14916.html 本文由CocoaChina译者lynulzy（社区ID）翻译 作者：Bohdan Orlov 原文：iOS Architecture Patterns 在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？ 相信你会找到以上问题的答案，如果没找到请在评论中指出。 你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。 掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题： 谁应该来负责网络请求？Model 还是 Controller ？ 应该怎样向一个新的页面的 ViewModel 传入一个 Model ? 谁来创建一个 VIPER 模块，是 Router 还是 Presenter ? 为什么要关注架构设计？ 因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样： 这个类是一个UIViewController的子类 数据直接在UIViewController中存储 UIView类几乎不做任何事情 Model 仅仅是一个数据结构 单元测试覆盖不了任何用例 以上这些情况仍旧会出现，即使是你遵循了Apple的指导原则并且实现了其 MVC(模式，所以，大可不必惊慌。Apple所提出的 MVC 模式存在一些问题，我们之后会详述。 在此，我们可以定义一个好的架构应该具备的特点： 任务均衡分摊给具有清晰角色的实体 可测试性通常都来自与上一条（对于一个合适的架构是非常容易） 易用性和低成本维护 为什么采用分布式? 采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 单一功能原则 的前提下，将功能划分给不同的实体。 为什么需要易测性？ 其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少一周的时间才能再次分发给用户。 为什么需要易用性？ 这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。 MV(X）系列概要 当今我们已经有很架构设计模式方面的选择: MVC MVP MVVM VIPER 前三种设计模式都把一个应用中的实体分为以下三类： Models–负责主要的数据或者操作数据的数据访问层，可以想象 Perspn 和 PersonDataProvider 类。 Views–负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。 Controller/Presenter/ViewModel–负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，同时将更改的信息返回到View上。 将实体进行划分给我们带来了以下好处： 更好的理解它们之间的关系 复用（尤其是对于View和Model） 独立的测试 让我们开始了解MV(X)系列，之后再返回到VIPER模式。 MVC的过去 在我们探讨Apple的MVC模式之前，我们来看下传统的MVC模式。 传统的MVC 在这里，View并没有任何界限，仅仅是简单的在Controller中呈现出Model的变化。想象一下，就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。尽管在iOS平台上实现这这种MVC模式是没有任何难度的，但是它并不会为我们解决架构问题带来任何裨益。因为它本身也是，三个实体间相互都有通信，而且是紧密耦合的。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。 “传统的MVC架构不适用于当下的iOS开发” 苹果推荐的MVC–愿景 Cocoa MVC 由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。 理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，为View controller减负也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？ 苹果推荐的MVC–事实 Realistic Cocoa MVC Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们经常被混杂到View的生命周期中，因此很难说View和ViewController是分离的。尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，View的最大的任务就是向Controller传递用户动作事件。ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。 你可能会看见过很多次这样的代码： var&nbsp;userCell&nbsp;=&nbsp;tableView.dequeueReusableCellWithIdentifier("identifier")&nbsp;as&nbsp;UserCell userCell.configureWithUser(user) 这个cell,正是由View直接来调用Model，所以事实上MVC的原则已经违背了，但是这种情况是一直发生的甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，不向View传递一个Model对象，这样就会大大增加Controller的体积。 “Cocoa 的MVC被写成Massive View Controller 是不无道理的。” 直到进行单元测试的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难–你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。 我们看下一些简单的例子: import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{&nbsp;//&nbsp;View&nbsp;+&nbsp;Controller &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;person:&nbsp;Person! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVC let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;view&nbsp;=&nbsp;GreetingViewController() view.person&nbsp;=&nbsp;model; “MVC可以在一个正在显示的ViewController中实现” 这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。 事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作，因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。 “View和Controller的接口**并不适合单元测试。”** 以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征: 任务均摊–View和Model确实是分开的，但是View和Controller却是紧密耦合的 可测试性–由于糟糕的分散性，只能对Model进行测试 易用性–与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。 如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。 “就开发速度而言，Cocoa MVC是最好的架构选择方案。” MVP&nbsp;实现了Cocoa的MVC的愿景 Passive View variant of MVP 这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字叫做MVC，但是，这就是说苹果的MVC实际上就是MVP了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。 “假如告诉你UIViewController就是View呢？” 就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出： import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } protocol&nbsp;GreetingView:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String) } protocol&nbsp;GreetingViewPresenter&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person) &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting() } class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingViewPresenter&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;unowned&nbsp;let&nbsp;view:&nbsp;GreetingView &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person &nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(view:&nbsp;GreetingView,&nbsp;person:&nbsp;Person)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view&nbsp;=&nbsp;view &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;presenter:&nbsp;GreetingViewPresenter! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.presenter.showGreeting() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVP let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;view&nbsp;=&nbsp;GreetingViewController() let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter(view:&nbsp;view,&nbsp;person:&nbsp;model) view.presenter&nbsp;=&nbsp;presenter 关于整合问题的重要说明 MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View涉及到Model，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下集中方案中。 我们来看下MVP模式下的三个特性的分析： 任务均摊–我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。 可测试性–非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单 易用性–在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰 “iOS 中的MVP意味着可测试性强、代码量大。” MVP–绑定和信号 还有一些其他形态的MVP–监控控制器的MVP。 这个变体包含了View和Model之间的直接绑定，但是Presenter仍然来管理来自View的动作事件，同时也能胜任对View的更新。 Supervising Presenter variant of the MVP 但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。 和传统的MVC一样，写这样的例子没有什么价值，故不再给出。 MVVM–最新且是最伟大的MV(X)系列的一员 MVVM架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。 从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。 MVVM 它和MVP模式看起来非常像: MVVM将ViewController视作View 在View和Model之间没有紧密的联系 此外，它还有像监管版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间而是在View和ViewModel之间。 那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。 绑定 我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。 如果我们自己不想自己实现，那么我们有两种选择: 基于KVO的绑定库如 RZDataBinding 和 SwiftBond 完全的函数响应式编程，比如像ReactiveCocoa、RxSwift或者 PromiseKit 事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。 但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下函数调用栈： Reactive Debugging 在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。 import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Model &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } protocol&nbsp;GreetingViewModelProtocol:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{&nbsp;get&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())?&nbsp;{&nbsp;get&nbsp;set&nbsp;}&nbsp;//&nbsp;function&nbsp;to&nbsp;call&nbsp;when&nbsp;greeting&nbsp;did&nbsp;change &nbsp;&nbsp;&nbsp;&nbsp;init(person:&nbsp;Person) &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting() } class&nbsp;GreetingViewModel&nbsp;:&nbsp;GreetingViewModelProtocol&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person:&nbsp;Person &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greeting:&nbsp;String?&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingDidChange?(self) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingDidChange:&nbsp;((GreetingViewModelProtocol)&nbsp;->&nbsp;())? &nbsp;&nbsp;&nbsp;&nbsp;required&nbsp;init(person:&nbsp;Person)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.person&nbsp;=&nbsp;person &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;showGreeting()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greeting&nbsp;=&nbsp;"Hello"&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;self.person.lastName &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;viewModel:&nbsp;GreetingViewModelProtocol!&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;didSet&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.viewModel.greetingDidChange&nbsp;=&nbsp;{&nbsp;[unowned&nbsp;self]&nbsp;viewModel&nbsp;in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;viewModel.greeting &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self.viewModel,&nbsp;action:&nbsp;"showGreeting",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;MVVM let&nbsp;model&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine") let&nbsp;viewModel&nbsp;=&nbsp;GreetingViewModel(person:&nbsp;model) let&nbsp;view&nbsp;=&nbsp;GreetingViewController() view.viewModel&nbsp;=&nbsp;viewModel 让我们再来看看关于三个特性的评估： 任务均摊 – 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。 可测试性 – ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。 易用性 – 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。 “MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。” VIPER–把LEGO建筑经验迁移到iOS app的设计 VIPER是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。 迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次: VIPER 交互器 – 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。 展示器 – 包含UI层面的业务逻辑以及在交互器层面的方法调用。 实体 – 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。 路由器 – 用来连接VIPER的各个模块。 基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程–想想认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。 当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同: Model 逻辑通过把实体作为最小的数据结构转换到交互器中。 Controller/Presenter/ViewModel的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。 VIPER是第一个通过路由器实现明确的地址导航模式。 “找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。” 例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。 import&nbsp;UIKit struct&nbsp;Person&nbsp;{&nbsp;//&nbsp;Entity&nbsp;(usually&nbsp;more&nbsp;complex&nbsp;e.g.&nbsp;NSManagedObject) &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;firstName:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lastName:&nbsp;String } struct&nbsp;GreetingData&nbsp;{&nbsp;//&nbsp;Transport&nbsp;data&nbsp;structure&nbsp;(not&nbsp;Entity) &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting:&nbsp;String &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject:&nbsp;String } protocol&nbsp;GreetingProvider&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData() } protocol&nbsp;GreetingOutput:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData) } class&nbsp;GreetingInteractor&nbsp;:&nbsp;GreetingProvider&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;output:&nbsp;GreetingOutput! &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;provideGreetingData()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;person&nbsp;=&nbsp;Person(firstName:&nbsp;"David",&nbsp;lastName:&nbsp;"Blaine")&nbsp;//&nbsp;usually&nbsp;comes&nbsp;from&nbsp;data&nbsp;access&nbsp;layer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;subject&nbsp;=&nbsp;person.firstName&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;person.lastName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;GreetingData(greeting:&nbsp;"Hello",&nbsp;subject:&nbsp;subject) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.output.receiveGreetingData(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } protocol&nbsp;GreetingViewEventHandler&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton() } protocol&nbsp;GreetingView:&nbsp;class&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String) } class&nbsp;GreetingPresenter&nbsp;:&nbsp;GreetingOutput,&nbsp;GreetingViewEventHandler&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;weak&nbsp;var&nbsp;view:&nbsp;GreetingView! &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;greetingProvider:&nbsp;GreetingProvider! &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapShowGreetingButton()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingProvider.provideGreetingData() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;receiveGreetingData(greetingData:&nbsp;GreetingData)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greeting&nbsp;=&nbsp;greetingData.greeting&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;greetingData.subject &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.view.setGreeting(greeting) &nbsp;&nbsp;&nbsp;&nbsp;} } class&nbsp;GreetingViewController&nbsp;:&nbsp;UIViewController,&nbsp;GreetingView&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;eventHandler:&nbsp;GreetingViewEventHandler! &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;showGreetingButton&nbsp;=&nbsp;UIButton() &nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greetingLabel&nbsp;=&nbsp;UILabel() &nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;func&nbsp;viewDidLoad()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.showGreetingButton.addTarget(self,&nbsp;action:&nbsp;"didTapButton:",&nbsp;forControlEvents:&nbsp;.TouchUpInside) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;didTapButton(button:&nbsp;UIButton)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.eventHandler.didTapShowGreetingButton() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;setGreeting(greeting:&nbsp;String)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.greetingLabel.text&nbsp;=&nbsp;greeting &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;layout&nbsp;code&nbsp;goes&nbsp;here } //&nbsp;Assembling&nbsp;of&nbsp;VIPER&nbsp;module,&nbsp;without&nbsp;Router let&nbsp;view&nbsp;=&nbsp;GreetingViewController() let&nbsp;presenter&nbsp;=&nbsp;GreetingPresenter() let&nbsp;interactor&nbsp;=&nbsp;GreetingInteractor() view.eventHandler&nbsp;=&nbsp;presenter presenter.view&nbsp;=&nbsp;view presenter.greetingProvider&nbsp;=&nbsp;interactor interactor.output&nbsp;=&nbsp;presenter 让我们再来评估一下特性: 任务均摊 – 毫无疑问，VIPER是任务划分中的佼佼者。 可测试性 – 不出意外地，更好的分布性就有更好的可测试性。 易用性 – 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。 什么是LEGO 当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些问题，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 Generamba 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。 总结 我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。 因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS可视化动态绘制八种排序过程]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F10%2F21%2F16.10.21_iOS%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[原文：http://www.cocoachina.com/ios/20170105/18522.html 前面几篇博客都是关于排序的，在之前陆陆续续发布的博客中，我们先后介绍了冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序以及快速排序。俗话说的好，做事儿要善始善终，本篇博客就算是对之前那几篇博客的总结了。而本篇博客的示例Demo也是在之前那些博客Demo的基础上做的，也算是集成了各种排序的方法，然后给出了可视化的解决方案。今天博客的内容还是比较有趣的。 因为本猿是做iOS开发的，所以就使用iOS相关的组件来表示上述各种排序的过程。使用可视化方式来感受一下上述这些排序方法的异同。本篇博客所使用的相关的排序代码都是来自于之前的博客。因为我们在之前实现各种排序Demo时，我们定义了相应的排序接口SortType，所以上述的七种排序对外的调用方式是一致的，所以在此基础上给出相应排序的可视化解决方案并不困难。本篇博客就会给出其相应的扩展过程。 如果你想对上述7中排序进行详细的了解，请移步与之前的博客《冒泡排序、插入排序、希尔排序、选择排序》、《堆排序》、《归并排序》、《快速排序》、《基数排序》。废话少说，开始今天的博客。 一、可视化解决方案综述 1.交互UI综述 在本篇博客的第一部分我们先来整体的看一下我们Demo的功能。下方就是我们今天博客中的Demo的交互示意图。上方的输入框可以输入要排序元素的个数，下方输入的是300。程序会根据你输入的个数来随机生成数据，你输入300，就会随机生成300个数据提供排序使用。下方的SegmentControl可以选择不同的排序方式，本篇博客给出了7中常用的排序方式，选择完排序方式后可以点击右上方的排序按钮进行相应的排序。 下方显示的不同颜色的颜色条就是我们要排序的东西，我们会按照从小到大的方式对这些色条进行排序。左图中是未排序的状态，右图中是已经排序的状态。我们上面随机生成的数据反应到色条上就是色条的高度，我们按照色条的高度进行从小到大的排序。下方会给出每种排序的介绍。 2、部分核心代码实现 为了实现今天的Demo，我们需要对之前我们实现的那一些列的排序的方法进行扩展。因为我们之前在实现各种排序时，我们先定义了SortType接口，依据“开放封闭原则”，我们可以为各种排序的类创建一个“简单工厂”以供我们的视图层使用。关于设计模式更多以及更详细的内容，可以移步之前发布的设计模式系列博客《设计模式Swift版》。 上方就是为各种Sort类提供的“简单工厂”。上面这个简单工厂在视图控制器中点击SegmentControl时会使用，因为我们在选择不同排序类的时候需要使用不同的排序对象。下方就是我们视图控制器对“简单工厂”的调用，当然我们所有排序类都有父类，你也可以使用“工厂方法”来创建相应的对象，在此就不做过多赘述了。 下方代码段就是点击SegmentControl要调用的方法，其中从“简单工厂”中获取到相应排序方式的对象后，然后在设置相应的闭包回调。 二、冒泡排序 接下来我们来逐一看一下每种排序的具体效果。下方就是冒泡排序的效果，因为冒泡排序的时间复杂度是O(n^2)的，所以我们先设置元素个数是80， 如果太大的话会比较慢。因为我们在排序步骤结果输出时，每进行一次交换操作或者比较操作让排序线程休眠0.001秒，便于我们观察整个排序过程。 从下方这个动图上我们不难看出冒泡的整个过程，较小的数据从右往左以此往外冒。下方这个效果还是比较直观的，整个冒泡过程就是从后往前比较，如果后边的数要比前边的小就交换。冒泡过程如下所示： 三、选择排序 选择排序的时间复杂度也是O(n^2)。下方是“选择排序”的可视化过程，选择排序的过程就是从无序序列中找出最小的那个值放到有序序列中最后方。不断执行这个过程，我们的序列就是有序的了。下方就是选择排序的整个过程，元素的个数是80. 四、插入排序 插入排序的复杂度与上述选择排序的时间复杂度一样，都是O(n^2)。下方就是插入排序的运行结果。插入排序是从无序序列中取出第一个值，然后插入到前方有序序列中相应的位置。每次插入后，有序序列就会增加1，无序序列就会减少1。下方就是插入排序的过程，如下所示： 五、希尔排序 希尔排序的效率要高一些，其时间复杂度是O(n^(3/2))。下方就是希尔排序的具体执行步骤，希尔排序又称为缩小增量排序。该排序方式是插入排序的升级版，等增量缩小到1时，我们的序列就是有序的了。下方就是希尔排序的具体执行步骤，如下所示： 六、堆排序 堆排序比希尔排序更为高效，其时间复杂度为O(nlog2n)。下方的“堆排序”是根据大顶堆来进行排序的，大顶堆第一个值是序列中最大的，我们可以利用这一点获取无序序列中最大的那个值。首先我们将序列调整为大顶堆，然后把大顶堆的第一个值与最后一个值进行交换，然后再将剩下的序列调整成大顶堆，然后进行下一轮的替换。 七、归并排序 归并排序的时间复杂度也是O(nlog2n)。归并排序就是将无序数组拆分成多个只有一个元素的数组，然后进行两两合并。在合并的过程中将两个数组中的元素进行比较，将较小的放在前方，两个有序的数组合并后依然是有序的，然后再次进行两两合并，直到合并成一个数组为止。下方就是归并排序的执行顺序，从执行过程中，我们可以清楚的看到在排序过程中被分割的小的有序序列。归并排序的执行过程如下所示： 八、快速排序 快速排序的时间复杂度为O(nlog2n)。下方是快速排序的执行步骤，快速排序是利用里分治法的思想。从无序序列中取出一个值，比该值大的放在前方，比该值小的放在后方。然后递归执行前半部分和后半部分依次递归下去，我们的序列就是有序的了。 九、基数排序 下方是基数排序的运行效果，我们先输入1000个元素，生成1000个随机数，选择基数排序。如下所示： 十、上述排序的比较 关于上述排序的比较，在此就不做过多赘述了，就引用“维基百科”中的表格来说明吧，如下所示: 今天博客中所涉及的Demo依然会在github上进行分享，分享地址如下。 github源码分享地址：https://github.com/lizelu/DataStruct-Swift/tree/master/AllKindsOfSortForiOS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS Crash 分析]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F09%2F10%2F16.9.10_iOS_Crash%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/diyagoanyhacker/article/details/41247367 iOS Crash 分析（文一）- 开始iOS Crash 分析（文二）-崩溃日志组成iOS Crash 分析（文三）- 符号化崩溃日志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]一步一步写算法（之 算法总结）]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F07%2F13%2F16.7.13%20_%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%8B%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%89%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/feixiaoxing/article/details/6993718 &nbsp;&nbsp; &nbsp;自10月初编写算法系列的博客以来，陆陆续续以来写了几十篇。按照计划，还有三个部分的内容没有介绍，主要是（Dijkstra算法、二叉平衡树、红黑树）。这部分会在后面的博客补充完整。这里主要是做一个总结，有兴趣的朋友可以好好看看，欢迎大家提出宝贵意见。 &nbsp;&nbsp; &nbsp;（1） 排序算法 &nbsp;&nbsp; &nbsp;快速排序 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;合并排序 &nbsp;&nbsp; &nbsp;堆排序 &nbsp;&nbsp; &nbsp;选择排序 &nbsp;&nbsp; &nbsp;基数排序 &nbsp;&nbsp; &nbsp;冒泡排序 &nbsp;&nbsp; &nbsp;插入排序 &nbsp;&nbsp; &nbsp;希尔排序 &nbsp;&nbsp; &nbsp;链表排序 &nbsp;&nbsp; &nbsp;（2） 数据结构 &nbsp;&nbsp; &nbsp;线性队列 &nbsp;&nbsp; &nbsp;线性堆栈 &nbsp;&nbsp; &nbsp;单向链表 &nbsp;&nbsp; &nbsp;双向链表 &nbsp;&nbsp; &nbsp;循环单向链表 &nbsp;&nbsp; &nbsp;排序二叉树（插入，删除上、中、下、保存和加载） &nbsp;&nbsp; &nbsp;哈希表 &nbsp;&nbsp; &nbsp;哈希二叉树 &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;（3）图 &nbsp;&nbsp; &nbsp;图结构 &nbsp;&nbsp; &nbsp;图创建 &nbsp;&nbsp; &nbsp;图的添加、删除 &nbsp;&nbsp; &nbsp;图的保存 &nbsp;&nbsp; &nbsp;prim算法（上、中、下） &nbsp;&nbsp; &nbsp;哈夫曼树（上、下） &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;克鲁斯卡尔算法（上、中、下） &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;（4）常用算法 &nbsp;&nbsp; &nbsp;查找 &nbsp;&nbsp; &nbsp;内存分配 &nbsp;&nbsp; &nbsp;字符串查找（上、中、下） &nbsp;&nbsp; &nbsp;通用数据结构 &nbsp;&nbsp; &nbsp;通用算法 &nbsp;&nbsp; &nbsp;循环和递归 &nbsp;&nbsp; &nbsp;递归和堆栈 &nbsp;&nbsp; &nbsp;内存中的数据 &nbsp;&nbsp; &nbsp;A*算法 &nbsp;&nbsp; &nbsp;可变参数 &nbsp;&nbsp; &nbsp;函数堆栈 &nbsp;&nbsp; &nbsp;递归寻路 &nbsp;&nbsp; &nbsp;广度遍历、深度遍历 &nbsp;&nbsp; &nbsp;排序二叉树线索化 &nbsp;&nbsp; &nbsp;（5）趣味算法题目 &nbsp;&nbsp; &nbsp;链表逆转 &nbsp;&nbsp; &nbsp;大数计算 &nbsp;&nbsp; &nbsp;n！末位0个数计算 &nbsp;&nbsp; &nbsp;洗牌算法 &nbsp;&nbsp; &nbsp;“数星星” &nbsp;&nbsp; &nbsp;八皇后 &nbsp;&nbsp; &nbsp;数据选择 &nbsp;&nbsp; &nbsp;单词统计 &nbsp;&nbsp; &nbsp;爬楼梯 &nbsp;&nbsp; &nbsp;回数 &nbsp;&nbsp; &nbsp;链表重合 &nbsp;&nbsp; &nbsp;寻找丢失的数 &nbsp;&nbsp; &nbsp;最大公约数、最小公倍数 &nbsp;&nbsp; &nbsp;挑选最大的n个数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]iOS用CGContextRef画各种图形]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F06%2F01%2F16.6.1_IOS%E7%94%A8CGContextRef%E7%94%BB%E5%90%84%E7%A7%8D%E5%9B%BE%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/rhljiayou/article/details/9919713 前言首先了解一下CGContextRef:An opaque type that represents a Quartz 2D drawing environment.Graphics Context是图形上下文,可以将其理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.自己学习时实现的demo，希望对大家有帮助，具体的实现看代码，并有完美的注释解释，还有一些对我帮助的博文供大家参考。都在代码里面。看一下demo效果图先： 自定义CustomView类,CustomView.h: 123456#import &lt;UIKit/UIKit.h&gt; #import &lt;QuartzCore/QuartzCore.h&gt; #define PI 3.14159265358979323846 @interface CustomView : UIView @end 实现类CustomView.m： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#import "CustomView.h" @implementation CustomView - (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; &#125; return self; &#125; // 覆盖drawRect方法，你可以在此自定义绘画和动画 - (void)drawRect:(CGRect)rect &#123; //An opaque type that represents a Quartz 2D drawing environment. //一个不透明类型的Quartz 2D绘画环境,相当于一个画布,你可以在上面任意绘画 CGContextRef context = UIGraphicsGetCurrentContext(); /*写文字*/ CGContextSetRGBFillColor (context, 1, 0, 0, 1.0);//设置填充颜色 UIFont *font = [UIFont boldSystemFontOfSize:15.0];//设置 [@"画圆：" drawInRect:CGRectMake(10, 20, 80, 20) withFont:font]; [@"画线及孤线：" drawInRect:CGRectMake(10, 80, 100, 20) withFont:font]; [@"画矩形：" drawInRect:CGRectMake(10, 120, 80, 20) withFont:font]; [@"画扇形和椭圆：" drawInRect:CGRectMake(10, 160, 110, 20) withFont:font]; [@"画三角形：" drawInRect:CGRectMake(10, 220, 80, 20) withFont:font]; [@"画圆角矩形：" drawInRect:CGRectMake(10, 260, 100, 20) withFont:font]; [@"画贝塞尔曲线：" drawInRect:CGRectMake(10, 300, 100, 20) withFont:font]; [@"图片：" drawInRect:CGRectMake(10, 340, 80, 20) withFont:font]; /*画圆*/ //边框圆 CGContextSetRGBStrokeColor(context,1,1,1,1.0);//画笔线的颜色 CGContextSetLineWidth(context, 1.0);//线的宽度 //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度 // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。 CGContextAddArc(context, 100, 20, 15, 0, 2*PI, 0); //添加一个圆 CGContextDrawPath(context, kCGPathStroke); //绘制路径 //填充圆，无边框 CGContextAddArc(context, 150, 30, 30, 0, 2*PI, 0); //添加一个圆 CGContextDrawPath(context, kCGPathFill);//绘制填充 //画大圆并填充颜 UIColor*aColor = [UIColor colorWithRed:1 green:0.0 blue:0 alpha:1]; CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 CGContextSetLineWidth(context, 3.0);//线的宽度 CGContextAddArc(context, 250, 40, 40, 0, 2*PI, 0); //添加一个圆 //kCGPathFill填充非零绕数规则,kCGPathEOFill表示用奇偶规则,kCGPathStroke路径,kCGPathFillStroke路径填充,kCGPathEOFillStroke表示描线，不是填充 CGContextDrawPath(context, kCGPathFillStroke); //绘制路径加填充 /*画线及孤线*/ //画线 CGPoint aPoints[2];//坐标点 aPoints[0] =CGPointMake(100, 80);//坐标1 aPoints[1] =CGPointMake(130, 80);//坐标2 //CGContextAddLines(CGContextRef c, const CGPoint points[],size_t count) //points[]坐标数组，和count大小 CGContextAddLines(context, aPoints, 2);//添加线 CGContextDrawPath(context, kCGPathStroke); //根据坐标绘制路径 //画笑脸弧线 //左 CGContextSetRGBStrokeColor(context, 0, 0, 1, 1);//改变画笔颜色 CGContextMoveToPoint(context, 140, 80);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 148, 68, 156, 80, 10); CGContextStrokePath(context);//绘画路径 //右 CGContextMoveToPoint(context, 160, 80);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 168, 68, 176, 80, 10); CGContextStrokePath(context);//绘画路径 //右 CGContextMoveToPoint(context, 150, 90);//开始坐标p1 //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius) //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度, CGContextAddArcToPoint(context, 158, 102, 166, 90, 10); CGContextStrokePath(context);//绘画路径 //注，如果还是没弄明白怎么回事，请参考：http://donbe.blog.163.com/blog/static/138048021201052093633776/ /*画矩形*/ CGContextStrokeRect(context,CGRectMake(100, 120, 10, 10));//画方框 CGContextFillRect(context,CGRectMake(120, 120, 10, 10));//填充框 //矩形，并填弃颜色 CGContextSetLineWidth(context, 2.0);//线的宽度 aColor = [UIColor blueColor];//blue蓝色 CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 aColor = [UIColor yellowColor]; CGContextSetStrokeColorWithColor(context, aColor.CGColor);//线框颜色 CGContextAddRect(context,CGRectMake(140, 120, 60, 30));//画方框 CGContextDrawPath(context, kCGPathFillStroke);//绘画路径 //矩形，并填弃渐变颜色 //关于颜色参考http://blog.sina.com.cn/s/blog_6ec3c9ce01015v3c.html //http://blog.csdn.net/reylen/article/details/8622932 //第一种填充方式，第一种方式必须导入类库quartcore并#import &lt;QuartzCore/QuartzCore.h&gt;，这个就不属于在context上画，而是将层插入到view层上面。那么这里就设计到Quartz Core 图层编程了。 CAGradientLayer *gradient1 = [CAGradientLayer layer]; gradient1.frame = CGRectMake(240, 120, 60, 30); gradient1.colors = [NSArray arrayWithObjects:(id)[UIColor whiteColor].CGColor, (id)[UIColor grayColor].CGColor, (id)[UIColor blackColor].CGColor, (id)[UIColor yellowColor].CGColor, (id)[UIColor blueColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor greenColor].CGColor, (id)[UIColor orangeColor].CGColor, (id)[UIColor brownColor].CGColor,nil]; [self.layer insertSublayer:gradient1 atIndex:0]; //第二种填充方式 CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB(); CGFloat colors[] = &#123; 1,1,1, 1.00, 1,1,0, 1.00, 1,0,0, 1.00, 1,0,1, 1.00, 0,1,1, 1.00, 0,1,0, 1.00, 0,0,1, 1.00, 0,0,0, 1.00, &#125;; CGGradientRef gradient = CGGradientCreateWithColorComponents (rgb, colors, NULL, sizeof(colors)/(sizeof(colors[0])*4));//形成梯形，渐变的效果 CGColorSpaceRelease(rgb); //画线形成一个矩形 //CGContextSaveGState与CGContextRestoreGState的作用 /* CGContextSaveGState函数的作用是将当前图形状态推入堆栈。之后，您对图形状态所做的修改会影响随后的描画操作，但不影响存储在堆栈中的拷贝。在修改完成后，您可以通过CGContextRestoreGState函数把堆栈顶部的状态弹出，返回到之前的图形状态。这种推入和弹出的方式是回到之前图形状态的快速方法，避免逐个撤消所有的状态修改；这也是将某些状态（比如裁剪路径）恢复到原有设置的唯一方式。 */ CGContextSaveGState(context); CGContextMoveToPoint(context, 220, 90); CGContextAddLineToPoint(context, 240, 90); CGContextAddLineToPoint(context, 240, 110); CGContextAddLineToPoint(context, 220, 110); CGContextClip(context);//context裁剪路径,后续操作的路径 //CGContextDrawLinearGradient(CGContextRef context,CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint,CGGradientDrawingOptions options) //gradient渐变颜色,startPoint开始渐变的起始位置,endPoint结束坐标,options开始坐标之前or开始之后开始渐变 CGContextDrawLinearGradient(context, gradient,CGPointMake (220,90) ,CGPointMake(240,110), kCGGradientDrawsAfterEndLocation); CGContextRestoreGState(context);// 恢复到之前的context //再写一个看看效果 CGContextSaveGState(context); CGContextMoveToPoint(context, 260, 90); CGContextAddLineToPoint(context, 280, 90); CGContextAddLineToPoint(context, 280, 100); CGContextAddLineToPoint(context, 260, 100); CGContextClip(context);//裁剪路径 //说白了，开始坐标和结束坐标是控制渐变的方向和形状 CGContextDrawLinearGradient(context, gradient,CGPointMake (260, 90) ,CGPointMake(260, 100), kCGGradientDrawsAfterEndLocation); CGContextRestoreGState(context);// 恢复到之前的context //下面再看一个颜色渐变的圆 CGContextDrawRadialGradient(context, gradient, CGPointMake(300, 100), 0.0, CGPointMake(300, 100), 10, kCGGradientDrawsBeforeStartLocation); /*画扇形和椭圆*/ //画扇形，也就画圆，只不过是设置角度的大小，形成一个扇形 aColor = [UIColor colorWithRed:0 green:1 blue:1 alpha:1]; CGContextSetFillColorWithColor(context, aColor.CGColor);//填充颜色 //以10为半径围绕圆心画指定角度扇形 CGContextMoveToPoint(context, 160, 180); CGContextAddArc(context, 160, 180, 30, -60 * PI / 180, -120 * PI / 180, 1); CGContextClosePath(context); CGContextDrawPath(context, kCGPathFillStroke); //绘制路径 //画椭圆 CGContextAddEllipseInRect(context, CGRectMake(160, 180, 20, 8)); //椭圆 CGContextDrawPath(context, kCGPathFillStroke); /*画三角形*/ //只要三个点就行跟画一条线方式一样，把三点连接起来 CGPoint sPoints[3];//坐标点 sPoints[0] =CGPointMake(100, 220);//坐标1 sPoints[1] =CGPointMake(130, 220);//坐标2 sPoints[2] =CGPointMake(130, 160);//坐标3 CGContextAddLines(context, sPoints, 3);//添加线 CGContextClosePath(context);//封起来 CGContextDrawPath(context, kCGPathFillStroke); //根据坐标绘制路径 /*画圆角矩形*/ float fw = 180; float fh = 280; CGContextMoveToPoint(context, fw, fh-20); // 开始坐标右边开始 CGContextAddArcToPoint(context, fw, fh, fw-20, fh, 10); // 右下角角度 CGContextAddArcToPoint(context, 120, fh, 120, fh-20, 10); // 左下角角度 CGContextAddArcToPoint(context, 120, 250, fw-20, 250, 10); // 左上角 CGContextAddArcToPoint(context, fw, 250, fw, fh-20, 10); // 右上角 CGContextClosePath(context); CGContextDrawPath(context, kCGPathFillStroke); //根据坐标绘制路径 /*画贝塞尔曲线*/ //二次曲线 CGContextMoveToPoint(context, 120, 300);//设置Path的起点 CGContextAddQuadCurveToPoint(context,190, 310, 120, 390);//设置贝塞尔曲线的控制点坐标和终点坐标 CGContextStrokePath(context); //三次曲线函数 CGContextMoveToPoint(context, 200, 300);//设置Path的起点 CGContextAddCurveToPoint(context,250, 280, 250, 400, 280, 300);//设置贝塞尔曲线的控制点坐标和控制点坐标终点坐标 CGContextStrokePath(context); /*图片*/ UIImage *image = [UIImage imageNamed:@"apple.jpg"]; [image drawInRect:CGRectMake(60, 340, 20, 20)];//在坐标中画出图片 // [image drawAtPoint:CGPointMake(100, 340)];//保持图片大小在point点开始画图片，可以把注释去掉看看 CGContextDrawImage(context, CGRectMake(100, 340, 20, 20), image.CGImage);//使用这个使图片上下颠倒了，参考http://blog.csdn.net/koupoo/article/details/8670024 // CGContextDrawTiledImage(context, CGRectMake(0, 0, 20, 20), image.CGImage);//平铺图 &#125; @end 用法： 12CustomView *customView = [[CustomView alloc]initWithFrame:CGRectMake(0, 0, 320, self.view.frame.size.height)]; [self.view addSubview:customView]; ok，完成。大家如果看过我的其它博客，会发现，这遍博客跟我的某一片博客很像，没错，就是http://blog.csdn.net/rhljiayou/article/details/7212620当年写andriod的时候写的一遍博客。请大家尊重一下我的劳动成功，转载请注明原创地址！http://blog.csdn.net/rhljiayou/article/details/9919713]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]AFNetworking、ASIHTTPRequest中SSL的使用]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F05%2F20%2F16.5.20_AFNetworking%E3%80%81ASIHTTPRequest%E4%B8%ADSSL%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原文：https://www.caijixia.net/jianzhanjingyan/2014080371676.html 首先介绍下AFNetworking中的使用：2.0要注意个地方：IOS7及其以后，采用AFHTTPSessionManager，IOS7之前采用AFHTTPRequestOperationManager。以AFHTTPSessionManager为例，代码如下：1AFHTTPSessionManager *httpClient = [AFHTTPSessionManager manager]; httpClient.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient.responseSerializer = [AFHTTPResponseSerializer serializer]; // SSL Pinning NSString *certificatePath = [[NSBundle mainBundle] pathForResource:@certificate ofType:@der]; NSData *certificateData = [NSData dataWithContentsOfFile:certificatePath]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:YES]; [securityPolicy setPinnedCertificates:@[certificateData]]; [securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate]; [httpClient setSecurityPolicy:securityPolicy]; [httpClient GET:@http://xxxx parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; //失败信息 &#125;]; 以AFHTTPRequestOperationManager为例，站群，代码如下： 12345678AFHTTPRequestOperationManager *httpClient1 = [AFHTTPRequestOperationManager manager]; httpClient1.requestSerializer = [AFHTTPRequestSerializer serializer]; httpClient1.responseSerializer = [AFHTTPResponseSerializer serializer]; // SSL Pinning NSString *certificatePath1 = [[NSBundle mainBundle] pathForResource:@certificate ofType:@der]; NSData *certificateData1 = [NSData dataWithContentsOfFile:certificatePath1]; AFSecurityPolicy *securityPolicy1 = [[AFSecurityPolicy alloc] init]; [securityPolicy1 setAllowInvalidCertificates:YES]; [securityPolicy1 setPinnedCertificates:@[certificateData1]]; [securityPolicy1 setSSLPinningMode:AFSSLPinningModeCertificate]; [httpClient setSecurityPolicy:securityPolicy1];[httpClient1 GET:@http://xxxx parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //成功信息 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //失败信息 &#125;]; 下面来讲下ASI，以ASIFormDataRequest为例，代码如下： 123456ASIFormDataRequest * request; request = [ASIFormDataRequest requestWithURL:[NSURL URLWithString:@]]; NSData *cerFile = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@d1 ofType:@cer]]; SecCertificateRef cert = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)cerFile); NSArray *array = [NSArray arrayWithObjects:(__bridge id)cert,nil];[request setClientCertificates:array]; [request setValidatesSecureCertificate:NO]; [request startSynchronous]; ASIHTTPRequest的参考http://www.tuicool.com/articles/UN3AveR，代码就不贴了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]使用AFNetworking 3.0库进行网络请求时，取消单个队列和全部队列的方法(取消网络请求)]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F05%2F11%2F16.5.11_%E4%BD%BF%E7%94%A8AFNetworking3.0%E5%8F%96%E6%B6%88%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[原文：http://blog.csdn.net/a645258072/article/details/51208360 项目中有时会有这种情况，当界面正在请求数据，但数据为返回之前。返回到上一个界面，这种情况下，应取消此界面的网络请求。此篇就是为了处理此种情况下的操作，可 以取消单个请求队列，如果界面接口很多，可以一次性取消所有请求队列。 AFHTTPSessionManager *manager = [AFHTTPSessionManagermanager]; NSURLSessionDataTask *ljTask = [manager GET:@&quot;url地址&quot;parameters:@&quot;入参&quot;progress:^(NSProgress *_Nonnull downloadProgress) { //数据请求进度 } success:^(NSURLSessionDataTask *_Nonnull task,id _Nullable responseObject) { //请求成功 } failure:^(NSURLSessionDataTask *_Nullable task,NSError *_Nonnull error) { //请求失败 }]; //取消单个网络请求 [ljTask cancel]; //取消所有的网络请求 [manager.operationQueuecancelAllOperations];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]让你快速上手Runtime]]></title>
      <url>%2Fzhoutq.github.io%2F2016%2F03%2F08%2F%E8%BD%AC-%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRuntime%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/e071206103a4 前言本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:袁峥Seemygo,也可以来小码哥，了解下我们的iOS培训课程。后续还会更新更多内容。。。 一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import 消息机制简单使用 123456789101112131415161718 // 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 交换原理： 交换之前： * 交换之后： 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name);&#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243 @implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM);&#125;@end 字典转模型的方式一：KVC 12345678910111213@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]Convert to Objective-C ARC]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F12%2F11%2F15.12.11_Convert_to_Objective-C_ARC%2F</url>
      <content type="text"><![CDATA[原文：http://www.cnblogs.com/tracy-e/p/3151459.html 今天在进行代码走查时，竟然发现了下面这段代码： Bad Code 顿时感觉吐槽无力，虽然我反复强调内存管理问题，无非就是谁申请谁释放，利用强弱引用避免 retain-cycles，但是还是会有这样那样的问题，leaks 每次就是一片红。本来是计划等他们交易都开发完了，进行一次集体代码走查，好好给他们上一课，集中来解决内存问题。但是由于个人原因我 7 月份会离开项目组，恐怕没有时间来这么做了，所以最终还是决定将工程转成 ARC 模式。 该项目是某行手机银行客户端，iOS 开发这块除了我，其他的所有 7 个开发人员都是项目组临时招聘的，技术参差不齐，毕竟公司招聘标准就是：便宜 + 能干事。我的职责就是负责客户端架构，公共机制的设计与实现，公共组件的封装，开发过程中的解疑。其他开发人员每人负责一两个模块的交易开发，其实无非就剩下请求数据绘界面的事了。 其实项目开始时就打算尝试用 ARC 的，但是项目组内其他人员之前都没接触过 ARC，迫于项目进度压力也没有时间做培训，就使用大家比较熟悉的 MRR，还是太信任他们了。 Convertion Steps 1.将不要转成 ARC 的代码标注一下 如开源代码 AFNetworking(因为项目需要支持 4.3，所以用的 AFNetworking 是支持 4.3 的非 ARC 版本)、GDataXML、RegexKitLite、Reachability 等，其实这些也能转，但是感觉没有必要，将这些源文件在 Build Phases / Complie Sources 中标注为-fno-objc-arc，如果之前用到了使用 ARC 的代码，现在可以将-fobjc-arc标记去掉了。 setp1 2.工程检查 我选择使用 Xcode5.0_DP 版本来转，之前使用 Xcode4.6 在转换过程中电脑经常会假死，或者 Xcode4.6 直接崩溃，不知道什么原因。而 Xcode5.0 默认就是 ARC 模式，我想为了能让之前的程序都转换为 ARC，它的转换工具一定比之前强化了不少。 Xcode -&gt; Edit -&gt; Refactor -&gt; Convert to Objective-C ARC&hellip; 选择要转换的 Target，工程 target，如果有单元测试也会出现单元测试的 target，点击&ldquo;Check&rdquo;。 3.解决 ARC 不允许的问题 setp3 转换工具会自动将代码里面的 retain、release、autorelease 等操作去掉，属性中的 retain、copy、assign 转为为对应的关键字（retain、copy -&gt; strong, assign 会根据工程是否支持 5.0 一下版本转出 weak，或 unsafe_unretained）。 但是如果你在宏里面定义如： #define MB_RELEASE_SAFELY(POINTER) { [POINTER release]; __POINTER = nil; } 转换工具是不会自动处理里面的 release 的，需要手动将[__POINTER release];去掉。（我工程里面 4201 个问题基本上都是因为这个导致的） 此外在 CF 对象与 NS 对象之间转换的需要加上关键字__bridge，这个也需要手动来来修改。 4.开始转换 setp4 解决完所有的冲突，再次选择&ldquo;Convert to Objective-C ARC&hellip;&rdquo;，你就能看到这个界面，点击&ldquo;Next&rdquo;后，再次经过漫长的等待， 工具会列出了将会为了转换的代码的对照列表。默认所有出现在列表里面的文件都是选中的，你可以选在不要转换的文件，去掉对勾。确认完后，点击&ldquo;Save&rdquo;就完成了整个工程的转换工作, Congratulations! (我在完成后编译时，发现之前被我标为-fno-objc-arc的文件会有报错，原来在转换过程中工具将之前的标记都去掉了，无奈再次标记了一遍。) 5.其他处理 因为我们工程支持 4.3，所以 weak, __weak 关键字不能用， 可以通过宏定义将 5.0 以下时 weak 关键字定义为 unsafe_unretained: #if (!has_feature(objc_arc)) || \(defined IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; \IPHONE_OS_VERSION_MIN_REQUIRED &lt; IPHONE_5_0) || \(defined MAC_OS_X_VERSION_MIN_REQUIRED &amp;&amp; \ MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_10_7)#undef weak#define weak unsafe_unretained#undef weak#define weak unsafe_unretained#endif 在 ARC 模式下，使用 performSelector 方法会有编译警告：PerformSelector may cause a leak because its selector is unknown，作为有洁癖的程序员是不能容许程序中有警告的： #progma clang diagnostic push#progma clang disgnostic ignored “-Warc-performSelecotr-leaks”[self performSelector:@selector(mySelector:) withObject:object];#progma clang disgnostic pop Posted by&nbsp;XiaoYi_HD&nbsp;- 6月 19 2013如需转载，请注明： 本文来自&nbsp;Esoft Mobile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]AFNetworking 3.0迁移指南]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F12%2F09%2F15.12.09_AFNetworking%203.0%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/047463a7ce9b AFNetworking 3.0 AFNetworking是一款在OS X和iOS下都令人喜爱的网络库。为了迎合iOS新版本的升级, AFNetworking在3.0版本中删除了基于 NSURLConnection API的所有支持。如果你的项目以前使用过这些API，建议您立即升级到基于 NSURLSession 的API的AFNetworking的版本。本指南将引导您完成这个过程。 本指南是为了引导使用AFNetworking 2.x升级到最新的版本API，以达到过渡的目的，并且解释了新增和更改的设计结构。 新设备要求: iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7AFNetworking 3.0正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。如果你想使用AFNetworking在针对较旧版本的SDK项目，请检查README的兼容性信息。 NSURLConnection的API已废弃AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。 AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。 弃用的类下面的类已从AFNetworking 3.0中废弃： AFURLConnectionOperation AFHTTPRequestOperation AFHTTPRequestOperationManager 修改的类下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构: UIImageView+AFNetworking UIWebView+AFNetworking UIButton+AFNetworking 迁移 AFHTTPRequestOperationManager 核心代码如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化： securityPolicy requestSerializer responseSerializer 接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。 AFNetworking 2.xAFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; [manager GET:@&quot;请求的url&quot; parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;成功&quot;); } failure:^(AFHTTPRequestOperation *operation, NSError*error) { NSLog(@&quot;失败&quot;); }];`&lt;/pre&gt; ##### AFNetworking 3.0 &lt;pre&gt;`AFHTTPSessionManager *session = [AFHTTPSessionManager manager]; [session GET:@&quot;请求的url&quot; parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) { NSLog(@&quot;成功&quot;); } failure:^(NSURLSessionDataTask *task, NSError *error) { NSLog(@&quot;失败&quot;); }];`&lt;/pre&gt; #### AFHTTPRequestOperation 核心代码 与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。 在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。 接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。 ##### AFNetworking 2.x &lt;pre&gt;`NSURL *URL = [NSURL URLWithString:@&quot;&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request]; op.responseSerializer = [AFJSONResponseSerializer serializer]; [op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) { NSLog(@&quot;JSON: %@&quot;, responseObject); } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@&quot;Error: %@&quot;, error); }]; [[NSOperationQueue mainQueue] addOperation:op];`&lt;/pre&gt; ##### AFNetworking 3.0 &lt;pre&gt;`NSURL *URL = [NSURL URLWithString:@&quot;&quot;]; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager GET:URL.absoluteString parameters:nil success:^(NSURLSessionTask *task, id responseObject) { NSLog(@&quot;JSON: %@&quot;, responseObject); } failure:^(NSURLSessionTask *operation, NSError *error) { NSLog(@&quot;Error: %@&quot;, error); }]; UIKit的迁移图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。 UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。 UIAlertView的类目被废弃从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。 原文链接: AFNetworking 3.0纯属个人翻译，如有错误，还请纠正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]使用AFNetworking, SDWebimage和OHHTTPStubs]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F11%2F20%2F15.11.20_%E4%BD%BF%E7%94%A8AFNetworking%2C%20SDWebimage%E5%92%8COHHTTPStubs%2F</url>
      <content type="text"><![CDATA[原文：http://blog.shiqichan.com/using-afnetworking-sdwebimage-and-ohhttpstubs/ 写了个示例，放在GitHub上。 这是运行的动画：以下内容主要介绍： 基于AFNetworking的HTTP操作，GET获取网页和JSON数据，上传文件，下载文件，以及加载图片 基于SDWebimage的加载图片 基于OHHTTPStubs的伪造网络响应用于测试（stub），而且可以模拟出网络的延时 使用基于NSURLSession的AFNetworking APIAFNetworking有2套用于网络操作的API： 基于NSURLConnection 基于NSURLSession 后者是新的API，用于iOS 7 / Mac OS X 10.9及以上版本。 这篇文章写的很好：从 NSURLConnection 到 NSURLSession，说明后者做了哪些改善和加强。 现在越来越多的iOS项目最低要求iOS 7，让我们可以开始尝试使用这种新的方式。 GET请求，获取普通网页文本AFHTTPSessionManager是使用NSURLSession的API。 12345678910111213141516171819NSURL baseURL = [NSURL URLWithString:@”http://localhost/“]; //设置和加入头信息NSURLSessionConfiguration config = [NSURLSessionConfiguration defaultSessionConfiguration];[config setHTTPAdditionalHeaders:@&#123; @”User-Agent” : @”My Browser”&#125;];AFHTTPSessionManager manager=[[AFHTTPSessionManager alloc] initWithBaseURL:baseURL sessionConfiguration:config];manager.responseSerializer = [AFHTTPResponseSerializer serializer];manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@”text/html”];//设置GET请求的参数NSDictionary params=[[NSDictionary alloc] initWithObjectsAndKeys:@”3”,@”id”,nil];//发起GET请求[manager GET:@”” parameters:params success:^(NSURLSessionDataTask task, id responseObject) &#123; NSLog(@”HTML: %@”, [[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125; failure:^(NSURLSessionDataTask task, NSError *error) &#123; NSLog(@”visit error: %@”,error);&#125;]; 为了方便测试，这个示例里写了个简单的Web Server，httpServer.js。 运行httpServer.js，需要安装node.js环境。然后： &lt;span class=&quot;title&quot;&gt;sudo&lt;/span&gt; node httpServer 我使用了80端口，在Mac环境下是需要root权限的。 GET请求，获取JSON数据方法和GET请求网页文本大同小异，个别参数或者设置对象上有不同： 12345678910111213NSURL baseURL = [NSURL URLWithString:@”http://localhost/“];NSURLSessionConfiguration config = [NSURLSessionConfiguration defaultSessionConfiguration];[config setHTTPAdditionalHeaders:@&#123; @”User-Agent” : @”My Browser”&#125;];AFHTTPSessionManager manager=[[AFHTTPSessionManager alloc] initWithBaseURL:baseURL sessionConfiguration:config];NSDictionary params=[[NSDictionary alloc] initWithObjectsAndKeys:@”8”,@”id”,nil];[manager GET:@”/json” parameters:params success:^(NSURLSessionDataTask task, id responseObject) &#123; NSDictionary object=(NSDictionary )responseObject; NSLog(@”response message: %@”,object[@”message”]);&#125; failure:^(NSURLSessionDataTask task, NSError *error) &#123; NSLog(@”visit error: %@”,error);&#125;]; 下载文件AFNetworking API会返回NSURLSessionDownloadTask，可用于网络请求的取消、暂停和恢复。 其实上文中的GET方法也返回了这个对象，只不过下载文件时间可能会较长，有可能有这方面的需求。 1234567891011121314NSURLSessionConfiguration configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL URL = [NSURL URLWithString:@”http://www.baidu.com/img/bdlogo.png“];NSURLRequest request = [NSURLRequest requestWithURL:URL];NSURLSessionDownloadTask downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL (NSURL targetPath, NSURLResponse response) &#123; NSURL documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];&#125; completionHandler:^(NSURLResponse response, NSURL filePath, NSError error) &#123; NSLog(@”File downloaded to: %@”, filePath); uploadFilePath=filePath;&#125;];[downloadTask resume]; 使用AFNetworking加载图片需要引入一下： 1#import &lt;UIImageView+AFNetworking.h&gt; 然后，UIImageView就会有setImageWithURL供使用。 12NSURL *URL = [NSURL URLWithString:@”http://www.baidu.com/img/bdlogo.png“];[imageView setImageWithURL:URL]; 另外，提供了其他方法，可设置占位图片，图片下载成功和失败的处理，以及停止图片下载的方法。 1234– setImageWithURL:– setImageWithURL:placeholderImage:– setImageWithURLRequest:placeholderImage:success:failure:– cancelImageRequestOperation 使用SDWebimage加载图片SDWebImage，调用方式和AFNetworking类似，功能更强大，使用也很普及。 需要引入： 1#import &lt;SDWebImage/UIImageView+WebCache.h&gt; 代码： 12NSURL *URL = [NSURL URLWithString:@”http://www.sogou.com/images/logo/new/sogou.png“];[imageView sd_setImageWithURL:URL]; 下面是完整的方法列表： 123456789101112– sd_imageURL– sd_setImageWithURL:– sd_setImageWithURL:placeholderImage:– sd_setImageWithURL:placeholderImage:options:– sd_setImageWithURL:completed:– sd_setImageWithURL:placeholderImage:completed:– sd_setImageWithURL:placeholderImage:options:completed:– sd_setImageWithURL:placeholderImage:options:progress:completed:– sd_setImageWithPreviousCachedImageWithURL:andPlaceholderImage:options:progress:completed:– sd_setAnimationImagesWithURLs:– sd_cancelCurrentImageLoad– sd_cancelCurrentAnimationImagesLoad 比AFNetworking选项更多一些，比如可以设置SDWebImageOptions： 12345678910typedef NS_OPTIONS(NSUInteger, SDWebImageOptions ) &#123; SDWebImageRetryFailed = 1 &lt; &lt; 0, SDWebImageLowPriority = 1 &lt; &lt; 1, SDWebImageCacheMemoryOnly = 1 &lt; &lt; 2, SDWebImageProgressiveDownload = 1 &lt; &lt; 3, SDWebImageRefreshCached = 1 &lt; &lt; 4, SDWebImageContinueInBackground = 1 &lt; &lt; 5, SDWebImageHandleCookies = 1 &lt; &lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt; &lt; 7,&#125;; 还有：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize) 可以用一组图片生成动画：sd_setAnimationImagesWithURLs 使用之前的Cache先显示图片？sd_setImageWithPreviousCachedImageWithURL，这个我从字面意思理解，还没有使用 有个process block，sd_setImageWithURL:placeholderImage:options:progress:completed:，可以获得receivedSize和expectedSize字节参数，用来显示进程百分比 另外，iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)，这篇文章测试和对比，结论也是SDWebimage更好一些。 AFNetworking上传文件12345678910111213141516NSMutableURLRequest request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@”POST” URLString:@”http://localhost/upload“ parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123; [formData appendPartWithFileURL:uploadFilePath name:@”file” fileName:@”filename.jpg” mimeType:@”image/jpeg” error:nil];&#125; error:nil];AFURLSessionManager manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSProgress progress = nil;NSURLSessionUploadTask uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse response, id responseObject, NSError error) &#123; if (error) &#123; NSLog(@”Error: %@”, error); &#125; else &#123; NSLog(@”%@ %@”, response, responseObject); &#125;&#125;];[uploadTask resume]; 可以通过NSProgress获取上传进度（具体怎么做呢？） 使用OHHTTPStubs伪造HTTP响应OHHTTPStubs，可用来伪造HTTP响应，这样不依赖服务器端，iOS的开发人员就可以测试网络服务了。 这个API，同时支持： NSURLConnection NSURLSession 不过，有个问题需要注意，如果App要上AppStore，是不能连接OHHTTPStubs的。 下面说下怎么使用，先看代码： 123456789101112131415NSString baseUrl=@”http://localhost“;//针对http://locahost/json请求的mock[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) &#123; NSDictionary params=[NSDictionary objectsFromURLQueryString:request.URL.query]; NSLog(@”id: %@”,params[@”id”]); return [[request.URL absoluteString] rangeOfString:[NSString stringWithFormat:@”%@/json”,baseUrl]].location==0;&#125; withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) &#123; NSLog(@”reqeust: %@”,request); NSString fixture = OHPathForFileInBundle(@”test.json”,nil); return [[OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@&#123;@”Content-Type”:@”text/json”&#125; ]requestTime:0 responseTime:0];&#125;]; 基本思路是，调用方法，通过2个回调（Block）实现对指定HTTP请求的响应伪造： 是否是要拦截的请求 拦截后，创建一个响应 在上述代码里还演示了： 如何从URL中提取GET请求的参数，这里用到了：URLQueryToCocoa 使用本地文件作为JSON数据，加入到HTTP响应中 可以设置请求和响应的延时，requestTime:0 responseTime:0，这个相当有用 ## 还可以用于伪造图片的响应，测试了一下，上述的AFNetworking以及SDWebimage都有效。 12345678910//GET image with sdwebimage[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) &#123; return [[request.URL absoluteString] isEqualToString:@”http://www.sogou.com/images/logo/new/sogou.png“];&#125; withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) &#123; NSLog(@”reqeust: %@”,request); NSString fixture = OHPathForFileInBundle(@”taobao.png”,nil); return [[OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@&#123;@”Content-Type”:@”image/png”&#125; ]requestTime:0 responseTime:0];&#125;]; 测试的时候，要注意，之前可能是通过真实网络获取的，因此会有缓存。需要把App删除，重新安装测试。 应该能看到类似下面的效果（使用的时本地图片了）： ## OHHTTPStubs这些代码，只需在App启动加载一次即可，可写在AppDelegate中： 123456789101112131415- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions &#123; [[AFNetworkReachabilityManager sharedManager] startMonitoring]; [HttpMock initMock];1234567891011121314151617181920212223242526272829303132&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;代码屏蔽掉，自然就使用真实网络了。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;编译正式使用代码的时候，可以考虑条件编译。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;## &lt;span class=&quot;tag&quot;&gt;AFNetworking&lt;/span&gt;的网络监控&lt;span class=&quot;tag&quot;&gt;API&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;提供的`&lt;span class=&quot;tag&quot;&gt;AFNetworkReachabilityManager&lt;/span&gt;`可以单独使用，很方便，用于监控网络变化。&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;比如，可以在&lt;span class=&quot;tag&quot;&gt;App&lt;/span&gt;启动后执行下面操作，启动监控器：&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;* (BOOL)application:(UIApplication _)application didFinishLaunchingWithOptions:(NSDictionary _)launchOptions &#123; [[AFNetworkReachabilityManager sharedManager] startMonitoring];&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;header&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;在ViewController中：&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;-(void)viewDidLoad&#123; [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@”Reachability: %@”, AFStringFromNetworkReachabilityStatus(status)); &#125;];&#125; 监听网络变化，做出相应的操作，比如弹出提示框。 ## 正式使用时： 可考虑在AppDelegate中setReachabilityStatusChangeBlock，当状态变化后，通过NSNotification发出通知 在各个ViewController的viewDidAppear和viewWillDisappear中监听和取消监听通知 这是设想，还没有付诸实施，也许还有问题。 不过至少不应该像本例中的，在ViewController中使用setReachabilityStatusChangeBlock。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇文章]]></title>
      <url>%2Fzhoutq.github.io%2F2015%2F11%2F12%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[NSLog(@&quot;Hello World&quot;); 捣腾了两天的终于出炉了，一路走来坑坑洼洼，实属不易！此时的心情犹如刚学OC时，控制台打印出“Hello World”一般。 后期会将珍藏已久的好文章陆续放上去，文章主要以技术分享为主，但时而也会有一些自己的小心情、小想法之类的！恭请敬阅。 由于刚开始弄所以排版和功能肯定有不足之处，欢迎批评指正。]]></content>
    </entry>

    
  
  
</search>
