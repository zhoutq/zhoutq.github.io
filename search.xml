<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[[转]教你搭建App内测下载平台]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F08%2F10%2F%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAApp%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[转自简书作者:zhao0 前言App开发测试过程中，我们会把安装包传到各种第三方的内测分发平台方便下载。这些平台或多或少有这样那样的限制，比如下载量啊、付费啊、不能方便找到历史版本啊。还有一方面，我们经常会打Debug版本的包方便调试，又不希望Debug包流传到外部去，这样就很有必要自己搭一个下载平台，于是就有了这个项目(github地址)。 技术调研怎么下载先说安卓，apk文件通过最简单的http/ftp下载就可以安装了，略过。iOS稍微复杂一点，需要两步才能完成。第一，下载链接必须是这样的格式 1itms-services://?action=download-manifest&amp;amp;url=一个plist文件的地址 第二，plist内容如下12345678910111213141516171819202122232425262728293031&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&amp;lt;plist version="1.0"&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;items&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;assets&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software-package&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;url&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ipa文件的地址&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;key&amp;gt;metadata&amp;lt;/key&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;bundle-identifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;bundleID&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;bundle-version&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;1.0&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;kind&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;software&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;title&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;AppTitle&amp;lt;/string&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/plist&amp;gt; 其中，最重要的就是ipa文件的地址，要求必须是https协议，那就需要SSL证书，幸运的是我们可以信任自签名的证书。下载的过程就是这样，当然我们希望这个链接和plist的生成是自动完成的。 自签名证书参考如何创建一个自签名的SSL证书(X509) 包信息提取单单只能下载还不够，我们希望看到更多的信息：App名字、版本号、build号、更新时间、图标等。这些信息虽然可以留给上传者在上传的时候一并带上，但是作为有追求的程序员，把方便留给别人的最基本的，因此我们要从ipa/apk中提取这些信息。无论是ipa还是apk，本质都是zip压缩文件。对于iOS的ipa，包信息都放在Info.plist中，主要有CFBundleVersion、CFBundleIdentifier、CFBundleShortVersionString、CFBundleName等。图标文件的名字也是固定的，只要解压就可以得到。不过，苹果对png图片进行了了自定义的pngcrush压缩，有压缩自然就有还原工具pngdefry。对于Android的apk，解压后还能看到AndroidManifest.xml，但是里面的内容经过编码显示为乱码，不方便查看，需要借助开发工具aapt(Android Asset Packaging Tool)，方法如下aapt dump badging apkPath输出的文本格式如下，不是标准的歌声，需要手动转换一下。 123456package: name='com.jianshu.haruki' versionCode='16070101' versionName='1.11.2'sdkVersion:'14'targetSdkVersion:'22'...application: label='简书' icon='res/drawable-hdpi-v4/icon_jianshu_new.png'... 找轮子程序员有一个习惯，需要某个东西的时候会先一番搜索，直接用别人写好的，用着用着发现别人写的东西有这样那样的不足，然后撸起袖子自己造一个。这次也不例外，我在github上找到了一个ios-ipa-server，它的特点是简单，ipa文件存储在一个目录下，没有数据库，包信息只有上传时间(其实就是文件更新时间)，不能对app归类，只靠文件名区别，不支持上传，如下图： 浏览器访问下载页面时，后端实时解析包信息、解压icon图片，这样做效率是非常低的。这么多不足我们就有了造轮子的理由了。 自己造一个既然ios-ipa-server是基于node-express写的，正好我没写过nodejs，那就在它的基础上继续写吧，借机学(zhuang)习(bi)一下。整个项目的结构是这样的，提供四个API：包上传、获取所有App最新版本、获取某个App的所有版本、动态生成plist文件，数据存储使用sqlite3。 包上传接口设计如下： 12345678910111213141516171819path:POST /uploadparam: package:安装包文件response:&#123;id: 6,guid: "46269d71-9fda-76fc-3442-a118d6b08bf1",bundleID: "com.jianshu.Hugo",version: "2.11.4",build: "1608051045",icon: "https://10.20.30.233:1234/icon/46269d71-9fda-76fc-3442-a118d6b08bf1.png",name: "Hugo",uploadTime: "2016-12-01 20:50:05",platform: "ios",url: "itms-services://?action=download-manifest&amp;amp;url=https://10.20.30.233:1234/plist/46269d71-9fda-76fc-3442-a118d6b08bf1"&#125; 后端需要拿到安装包，提取出包信息和png图标图片，然后插入到数据库中，最后存储安装包文件和png图片，这也是最关键、最复杂的一个API。 123456789101112131415161718app.post('/upload', function(req, res) &#123;var form = new multiparty.Form();form.parse(req, function(err, fields, files) &#123;var obj = files.package[0];var tmp_path = obj.path;parseAppAndInsertToDb(tmp_path, info =&amp;gt; &#123;storeApp(tmp_path, info["guid"], error =&amp;gt; &#123;if (error) &#123;errorHandler(error,res)&#125;&#125;)console.log(info)res.send(info)&#125;, error =&amp;gt; &#123;errorHandler(error,res)&#125;);&#125;);&#125;); 接收表单信息用到了multiparty模块，parseAppAndInsertToDb内部完成了包信息的提取和存储，storeApp存储包文件。parseAppAndInsertToDb的实现如下， 12345678910111213141516171819202122232425function parseAppAndInsertToDb(filePath, callback, errorCallback) &#123;var guid = Guid.create().toString();var parse, extractif (path.extname(filePath) === ".ipa") &#123;parse = parseIpaextract = extractIpaIcon&#125; else if (path.extname(filePath) === ".apk") &#123;parse = parseApkextract = extractApkIcon&#125;Promise.all([parse(filePath),extract(filePath,guid)]).then(values =&amp;gt; &#123;var info = values[0]info["guid"] = guidexcuteDB("INSERT INTO info (guid, platform, build, bundleID, version, name) VALUES (?, ?, ?, ?, ?, ?);",[info["guid"], info["platform"], info["build"], info["bundleID"], info["version"], info["name"]],function(error)&#123;if (!error)&#123;callback(info)&#125; else &#123;errorCallback(error)&#125;&#125;);&#125;, reason =&amp;gt; &#123;errorCallback(reason)&#125;)&#125; 首先根据文件后缀名判断安装包类型，因为ipa和apk的处理逻辑不一样，所以分别对应两个方法，包信息的提取和icon提取可以同时进行，所以这里用了Promise.all。parseIpa和parseApk就是包信息的提取。extractApkIcon和extractIpaIcon则是icon的提取，extractIpaIcon多了一步还原png图片的处理。parseIpa用到了ipa-extract-info模块，parseApk则使用了apk-parser3，代码都非常简单。详细可进入github地址。 其他其他三个API则比较简单了，无非就是根据参数取数据，不再赘述。 集成和使用安装步骤非常简单，首先需要安装node，有了node之后只要一行命令 1npm install -g ipapk-server 安装完成之后输入命令 1ipapk-server 手机浏览器访问https://ip:port 即可打开下载页面 App的信息获取都设计成了API，提供给开发者更灵活的接入方式，可以做web页面，也可以做成App，我的好朋友mask(人格分裂术)贡献了不少工作，完成默认的web下载页面。更详细的内容请参考github。 写在最后简书作为一个优质原创内容社区，拥有大量优质原创内容，提供了极佳的阅读和书写体验，吸引了大量文字爱好者和程序员。简书技术团队在这里分享技术心得体会，是希望抛砖引玉，吸引更多的程序员大神来简书记录、分享、交流自己的心得体会。这个专题以后会不定期更新简书技术团队的文章，包括Android、iOS、前端、后端等等，欢迎大家关注。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]简单监测iOS卡顿的demo]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F06%2F21%2F%E7%AE%80%E5%8D%95%E7%9B%91%E6%B5%8BiOS%E5%8D%A1%E9%A1%BF%E7%9A%84demo%2F</url>
      <content type="text"><![CDATA[转自简书作者:game3108 前言本文的demo代码也会更新到github上。 做这个demo思路来源于微信team的：微信iOS卡顿监控系统。主要思路:通过监测Runloop的kCFRunLoopAfterWaiting，用一个子线程去检查，一次循环是否时间太长。其中主要涉及到了runloop的原理。关于整个原理：深入理解RunLoop讲解的比较仔细。以下就是runloop大概的运行方式：123456789101112131415161718192021222324252627282930313233343536373839404142/// 1. 通知Observers，即将进入RunLoop/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);do &#123;/// 2. 通知 Observers: 即将触发 Timer 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 4. 触发 Source0 (非基于port的) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);/// 5. GCD处理main block__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);/// 6. 通知Observers，即将进入休眠/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);/// 7. sleep to wait msg.mach_msg() -&amp;gt; mach_msg_trap();/// 8. 通知Observers，线程被唤醒__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);/// 9. 如果是被Timer唤醒的，回调Timer__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);&#125; while (...);/// 10. 通知Observers，即将退出RunLoop/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 其中UI主要集中在__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);和__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);之前。获取kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting的状态就可以知道是否有卡顿的情况。 NSTimer的实现具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209 // MonitorController.h // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface MonitorController : NSObject + (instancetype) sharedInstance; - (void) startMonitor; - (void) endMonitor; - (void) printLogTrace; @end``` ``` objectivec // MonitorController.m // RunloopMonitorDemo // // Created by game3108 on 16/4/13. // Copyright © 2016年 game3108. All rights reserved. // #import "MonitorController.h" #include &amp;lt;libkern/OSAtomic.h&amp;gt; #include &amp;lt;execinfo.h&amp;gt; @interface MonitorController()&#123; CFRunLoopObserverRef _observer; double _lastRecordTime; NSMutableArray *_backtrace; &#125; @end @implementation MonitorController static double _waitStartTime; + (instancetype) sharedInstance&#123; static dispatch_once_t once; static id sharedInstance; dispatch_once(&amp;amp;once, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; - (void) startMonitor&#123; [self addMainThreadObserver]; [self addSecondaryThreadAndObserver]; &#125; - (void) endMonitor&#123; if (!_observer) &#123; return; &#125; CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); CFRelease(_observer); _observer = NULL; &#125; #pragma mark printLogTrace - (void)printLogTrace&#123; NSLog(@"====================堆栈\n %@ \n",_backtrace); &#125; #pragma mark addMainThreadObserver - (void) addMainThreadObserver &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //建立自动释放池 @autoreleasepool &#123; //获得当前thread的Run loop NSRunLoop *myRunLoop = [NSRunLoop currentRunLoop]; //设置Run loop observer的运行环境 CFRunLoopObserverContext context = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;; //创建Run loop observer对象 //第一个参数用于分配observer对象的内存 //第二个参数用以设置observer所要关注的事件，详见回调函数myRunLoopObserver中注释 //第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行 //第四个参数用于设置该observer的优先级 //第五个参数用于设置该observer的回调函数 //第六个参数用于设置该observer的运行环境 _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;amp;myRunLoopObserver, &amp;amp;context); if (_observer) &#123; //将Cocoa的NSRunLoop类型转换成Core Foundation的CFRunLoopRef类型 CFRunLoopRef cfRunLoop = [myRunLoop getCFRunLoop]; //将新建的observer加入到当前thread的run loop CFRunLoopAddObserver(cfRunLoop, _observer, kCFRunLoopDefaultMode); &#125; &#125; &#125;); &#125; void myRunLoopObserver(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; switch (activity) &#123; //The entrance of the run loop, before entering the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopEntry: NSLog(@"run loop entry"); break; //Inside the event processing loop before any timers are processed case kCFRunLoopBeforeTimers: NSLog(@"run loop before timers"); break; //Inside the event processing loop before any sources are processed case kCFRunLoopBeforeSources: NSLog(@"run loop before sources"); break; //Inside the event processing loop before the run loop sleeps, waiting for a source or timer to fire. //This activity does not occur if CFRunLoopRunInMode is called with a timeout of 0 seconds. //It also does not occur in a particular iteration of the event processing loop if a version 0 source fires case kCFRunLoopBeforeWaiting:&#123; _waitStartTime = 0; NSLog(@"run loop before waiting"); break; &#125; //Inside the event processing loop after the run loop wakes up, but before processing the event that woke it up. //This activity occurs only if the run loop did in fact go to sleep during the current loop case kCFRunLoopAfterWaiting:&#123; _waitStartTime = [[NSDate date] timeIntervalSince1970]; NSLog(@"run loop after waiting"); break; &#125; //The exit of the run loop, after exiting the event processing loop. //This activity occurs once for each call to CFRunLoopRun and CFRunLoopRunInMode case kCFRunLoopExit: NSLog(@"run loop exit"); break; /* A combination of all the preceding stages case kCFRunLoopAllActivities: break; */ default: break; &#125; &#125; #pragma mark addSecondaryThreadAndObserver - (void) addSecondaryThreadAndObserver&#123; NSThread *thread = [self secondaryThread]; [self performSelector:@selector(addSecondaryTimer) onThread:thread withObject:nil waitUntilDone:YES]; &#125; - (NSThread *)secondaryThread &#123; static NSThread *_secondaryThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;amp;oncePredicate, ^&#123; _secondaryThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_secondaryThread start]; &#125;); return _secondaryThread; &#125; - (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"monitorControllerThread"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes]; [runLoop run]; &#125; &#125; - (void) addSecondaryTimer&#123; NSTimer *myTimer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; &#125; - (void)timerFired:(NSTimer *)timer&#123; if ( _waitStartTime &amp;lt; 1 )&#123; return; &#125; double currentTime = [[NSDate date] timeIntervalSince1970]; double timeDiff = currentTime - _waitStartTime; if (timeDiff &amp;gt; 2.0)&#123; if (_lastRecordTime - _waitStartTime &amp;lt; 0.001 &amp;amp;&amp;amp; _lastRecordTime != 0)&#123; NSLog(@"last time no :%f %f",timeDiff, _waitStartTime); return; &#125; [self logStack]; _lastRecordTime = _waitStartTime; &#125; &#125; - (void)logStack&#123; void* callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); int i; _backtrace = [NSMutableArray arrayWithCapacity:frames]; for ( i = 0 ; i &amp;lt; frames ; i++ )&#123; [_backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); &#125; @end 主要内容是首先在主线程注册了runloop observer的回调myRunLoopObserver每次小循环都会记录一下kCFRunLoopAfterWaiting的时间_waitStartTime，并且在kCFRunLoopBeforeWaiting制空。 另外开了一个子线程并开启他的runloop（模仿了AFNetworking的方式），并加上一个timer每隔1秒去进行监测。 如果当前时长与_waitStartTime差距大于2秒，则认为有卡顿情况，并记录了当前堆栈信息。 PS:整个demo写的比较简单，最后获取堆栈也仅获取了当前线程的堆栈信息([NSThread callStackSymbols]有同样效果)，也在寻找获取所有线程堆栈的方法，欢迎指点一下。 更新：了解到 plcrashreporter (github地址) 可以做到获取所有线程堆栈。 更新2:这篇文章也介绍了监测卡顿的方法：检测iOS的APP性能的一些方法通过Dispatch Semaphore保证同步这里记录一下。 写一个Semaphore版本的代码，也放在github上： 12345678910111213141516// SeMonitorController.h// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import &amp;lt;Foundation/Foundation.h&amp;gt;@interface SeMonitorController : NSObject+ (instancetype) sharedInstance;- (void) startMonitor;- (void) endMonitor;- (void) printLogTrace;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// SeMonitorController.m// RunloopMonitorDemo//// Created by game3108 on 16/4/14.// Copyright © 2016年 game3108. All rights reserved.//#import "SeMonitorController.h"#import &amp;lt;libkern/OSAtomic.h&amp;gt;#import &amp;lt;execinfo.h&amp;gt;@interface SeMonitorController()&#123;CFRunLoopObserverRef _observer;dispatch_semaphore_t _semaphore;CFRunLoopActivity _activity;NSInteger _countTime;NSMutableArray *_backtrace;&#125;@end@implementation SeMonitorController+ (instancetype) sharedInstance&#123;static dispatch_once_t once;static id sharedInstance;dispatch_once(&amp;amp;once, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125;- (void) startMonitor&#123;[self registerObserver];&#125;- (void) endMonitor&#123;if (!_observer) &#123;return;&#125;CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);CFRelease(_observer);_observer = NULL;&#125;- (void) printLogTrace&#123;NSLog(@"====================堆栈\n %@ \n",_backtrace);&#125;static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;SeMonitorController *instrance = [SeMonitorController sharedInstance];instrance-&amp;gt;_activity = activity;// 发送信号dispatch_semaphore_t semaphore = instrance-&amp;gt;_semaphore;dispatch_semaphore_signal(semaphore);&#125;- (void)registerObserver&#123;CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;_observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;amp;runLoopObserverCallBack,&amp;amp;context);CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);// 创建信号_semaphore = dispatch_semaphore_create(0);// 在子线程监控时长dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;while (YES)&#123;// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)long st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));if (st != 0)&#123;if (_activity==kCFRunLoopBeforeSources || _activity==kCFRunLoopAfterWaiting)&#123;if (++_countTime &amp;lt; 5)continue;[self logStack];NSLog(@"something lag");&#125;&#125;_countTime = 0;&#125;&#125;);&#125;- (void)logStack&#123;void* callstack[128];int frames = backtrace(callstack, 128);char **strs = backtrace_symbols(callstack, frames);int i;_backtrace = [NSMutableArray arrayWithCapacity:frames];for ( i = 0 ; i &amp;lt; frames ; i++ )&#123;[_backtrace addObject:[NSString stringWithUTF8String:strs[i]]];&#125;free(strs);&#125;@end 用Dispatch Semaphore简化了代码复杂度，更加简洁。 参考资料本文csdn地址1.微信iOS卡顿监控系统2. iphone——使用run loop对象3.深入理解RunLoop4.检测iOS的APP性能的一些方法5.iOS实时卡顿监控]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]让你快速上手Runtime]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F08%2F%E8%BD%AC-%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BRuntime%2F</url>
      <content type="text"><![CDATA[原文：http://www.jianshu.com/p/e071206103a4 前言本篇主要介绍Runtime在开发中的一些使用场景，顺便讲解了下MJExtension的底层实现。如果喜欢我的文章，可以关注我微博:袁峥Seemygo,也可以来小码哥，了解下我们的iOS培训课程。后续还会更新更多内容。。。 一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import 消息机制简单使用 123456789101112131415161718 // 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 交换原理： 交换之前： * 交换之后： 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name);&#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243 @implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM);&#125;@end 字典转模型的方式一：KVC 12345678910111213@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇文章]]></title>
      <url>%2Fzhoutq.github.io%2F2017%2F03%2F08%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[NSLog(@&quot;Hello World&quot;); 捣腾了两天的终于出炉了，一路走来坑坑洼洼，实属不易！此时的心情犹如刚学OC时，控制台打印出“Hello World”一般。 后期会将珍藏已久的好文章陆续放上去，文章主要以技术分享为主，但时而也会有一些自己的小心情、小想法之类的！恭请敬阅。 由于刚开始弄所以排版和功能肯定有不足之处，欢迎批评指正。]]></content>
    </entry>

    
  
  
</search>
